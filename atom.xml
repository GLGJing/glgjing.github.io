<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[GLGJing's Blog]]></title>
  <link href="http://glgjing.github.io/atom.xml" rel="self"/>
  <link href="http://glgjing.github.io/"/>
  <updated>2015-02-28T17:10:32+08:00</updated>
  <id>http://glgjing.github.io/</id>
  <author>
    <name><![CDATA[GLGJing]]></name>
    <email><![CDATA[GLGJing@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：指针的类型]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/26/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:zhi-zhen-de-lei-xing/"/>
    <updated>2015-02-26T11:27:18+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/26/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:zhi-zhen-de-lei-xing</id>
    <content type="html"><![CDATA[<p>指针对于<code>c++</code>来说是一个非常强大和灵活的特性，他可以支持多态，可以在不同类型之间进行转换，那么指向不同类型的指针在本质上有什么区别呢？转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a>。例如一个类的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">ZooAnimal</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">ZooAnimal</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="o">~</span><span class="n">ZooAnimal</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="p">();</span>
</span><span class='line'><span class="k">protected</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">loc</span><span class="p">;</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么下面几个指针有什么不同：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">ZooAnimal</span><span class="o">*</span> <span class="n">px</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span><span class="o">*</span> <span class="n">pi</span><span class="p">;</span>
</span><span class='line'><span class="n">Array</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;*</span> <span class="n">pta</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>单纯从内存需求上来看，没有什么不同，在 32 位机器上都是 4 个字节，也就是一个机器地址大小。从存储的内容来看，也没什么不同，都是存储一个地址。真正不同的是寻址出来的内容类型不同，也就是说：</p>

<blockquote><p>&ldquo;指针类型&#8221;会教导编译器如何解释某个特定地址中的内存内容及其大小。</p></blockquote>

<p>所以说虽然一个<code>void*</code>指针可以指向一个地址，但是我们无法通过<code>void*</code>来操作该地址所存储的内容，因为编译器无法知道应该用什么方式来解释和操作该内容，这时需要进行类型转换（<code>cast</code>）来告诉编译器如何进行操作。</p>

<blockquote><p>所以，转型(<code>cast</code>)其实是一种编译器指令。大部分情况下它并不改变一个指针所含的真正地址，它只影响“被指出之内存的大小和其内容”的解释方式。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：class 与 Struct 的区别]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/18/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:claass-yu-struct-de-qu-bie/"/>
    <updated>2015-02-18T01:32:20+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/18/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:claass-yu-struct-de-qu-bie</id>
    <content type="html"><![CDATA[<p><code>class</code>和<code>struct</code>的区别到底是什么，什么时候应该用<code>struct</code>取代<code>class</code>呢？我想大多数从<code>C</code>转到<code>C++</code>的程序员都会有过这样的困惑。看了<code>Lippman</code>的《深度探索C++对象模型》对该问题的回答之后，我只想说一句：尼玛，只要跟哲学沾边的问题就注定不会有一个简单明了的答案！</p>

<p>首先引用<code>Lippman</code>的一句话：</p>

<blockquote><p>嘿，你知道吗，struct 那个关键字其实没什么用。。。“什么时候应该用 struct 取代 class ？” 答案之一是：当他让一个感觉比较好的时候。</p></blockquote>

<p>大部分<code>C++</code>程序员都知道，如果单纯从语法角度来区分<code>struct</code>和<code>class</code>的话，其实除了以下几点没有什么不同：</p>

<ol>
<li>默认继承权限不同。<code>class</code>的默认继承权限为<code>private</code>，而<code>struct</code>的默认继承权限为<code>public</code>；</li>
<li>成员的默认访问权限不同。<code>class</code>的成员默认是<code>private</code>权限，<code>struct</code>默认是<code>public</code>权限。</li>
<li><code>struct</code>不能作为模板参数，而<code>class</code>可以。</li>
</ol>


<p>那&#8217;Lippman&#8217;为什么不直说呢？偏得之乎者也的提升到精神层次，搞的读者一头雾水。<!--more-->个人觉得主要是语法上的区别只是结果，而为什么这么设计才是<code>Lippman</code>想传达的主要内容。在<code>C</code>所支持的<code>struct</code>和<code>C++</code>所支持的<code>class</code>之间有一个观念上的重要差异，而关键词本身并不提供这种差异。你可能会问如果说为了兼容<code>C</code>而提供了<code>struct</code>关键字，那干嘛还创建<code>class</code>这个关键字，都用<code>struct</code>不行吗？当然行，但是<code>Lippman</code>觉得<code>class</code>更能令人满意（其实就是他自己看着更爽），更能表达出封装和继承的哲学。</p>

<p>所以如果你还在电脑前纠结，请释怀吧！谁让人家是<code>C++</code>形象代言人呢，就是这么任性，就像当面对<code>struct</code>用在<code>template</code>参数时无法被语意分析器<code>parser</code>处理时，你只能迷茫的问为什么，而<code>Lippman</code>可以默默的把<code>parser</code>改掉。最后你可以说<code>struct</code>的保留是为了兼容<code>C</code>；也可以说<code>class</code>的引入更具哲学意义；还可以说他们的共存是为了更多程序员从<code>C</code>迁移到<code>C++</code>部落。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：三种对象模型]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/11/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-san-chong-dui-xiang-mo-xing/"/>
    <updated>2015-02-11T15:57:03+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/11/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-san-chong-dui-xiang-mo-xing</id>
    <content type="html"><![CDATA[<p>现在有一个<code>Point</code>类，声明如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Point</span><span class="p">(</span><span class="kt">float</span> <span class="n">xval</span><span class="p">);</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="o">~</span><span class="n">Point</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">float</span> <span class="n">x</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="nf">PointCount</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'> <span class="k">protected</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">float</span> <span class="n">_x</span><span class="p">;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="n">_point_count</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <br/>
这个类在机器上是通过什么模型来表示的呢？下面就介绍三种不同的实现方式。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a><!-- more --></p>

<h2>1. 简单对象模型</h2>

<p>简单对象模型名副其实，十分简单。在简单对象模型中，一个 <code>object</code>是由一系列<code>slots</code>组成，每个<code>slot</code>相当于一个指针，指向一个<code>member</code>，<code>memebers</code>按照声明的顺序与<code>slots</code>一一对应，这里的<code>members</code>包括<code>data members</code>和<code>function members</code>。如果将简单对象模型应用在<code>Point Class</code>上，结构图如下： <br/>
<img class="center" src="http://glgjing.github.io/images/1-8.png" width="400"></p>

<ul>
<li><p>优点：十分简单，降低了编译器设计的复杂度。</p></li>
<li><p>缺点：空间和时间上的效率降低。由于所有<code>member</code>都对应一个<code>slot</code>指针，所以每个<code>object</code>在空间上额外多出：<code>member's number 乘以指针大小</code>的空间。同时由于访问<code>object</code>的每个<code>member</code>都需要一次<code>slot</code>的额外索引，所以在时间的效率也会降低。</p></li>
</ul>


<h2>2. 表格驱动对象模型</h2>

<p>表格驱动对象模型将<code>member data</code>和<code>member function</code>分别映射成两个表格<code>member data table</code>和<code>function member table</code>，而<code>object</code>本身只存储指向这两个表格的指针。  其中<code>function member table</code>是由一系列的<code>slot</code>组成，每个<code>slot</code>指向一个<code>member function</code>; <code>member data table</code>则直接存储的<code>member data</code>本身。如果将表格驱动对象模型应用在<code>Point Class</code>上，结构图如下：       <br/>
<img class="center" src="http://glgjing.github.io/images/1-9.png" width="400"></p>

<ul>
<li>优点：采用两层索引机制，对<code>object</code>变化提供比较好的弹性，在<code>object</code>的<code>nonstatic data member</code>有所改变时，而应用程序代码没有改变，这时是不需要重新编译的。</li>
<li>缺点：空间和时间上的效率降低，具体原因可以参考简单对象模型的缺点分析。</li>
</ul>


<h2>3. C++ 对象模型</h2>

<p>Stroustrup 早期设计的<code>C++</code>对象模型是从简单对象模型改进而来的，并对内存空间和存取时间进行了优化。主要是将<code>nonstatic data members</code>存储在每一个<code>object</code>中，而<code>static data members</code>以及所有的<code>function members</code>被独立存储在所有<code>object</code>之外。对虚函数的支持主要通过以下几点完成的：</p>

<ul>
<li>所有包含虚函数或者继承自有虚函数基类的<code>class</code>都会有一个<code>virtual table</code>，该虚函数表存储着一堆指向该类所包含的虚函数的指针。</li>
<li>每个<code>class</code>所关联的<code>type_info object</code>也是由<code>virtual table</code>存储的，一般会存在该表格的首个<code>slot</code>，<code>type_info</code>用于支持<code>runtime type identification</code> (<code>RTTI</code>)。</li>
</ul>


<p>如果将<code>C++</code>对象模型应用在<code>Point Class</code>上，结构图如下：<br/>
<img class="center" src="http://glgjing.github.io/images/2-1.png" width="400"></p>

<ul>
<li>优点：空间和存取效率高，所有<code>static data members</code>以及所有的<code>function members</code>被独立存储在所有<code>object</code>之外，可以减少每个<code>object</code>的大小，而<code>nonstatic data members</code>存储在每一个<code>object</code>中，又提升了存取效率。</li>
<li>缺点：如果应用程序的代码未曾更改，但所用到的<code>class</code>的<code>nonstatic data members</code>有所更改，那么那些代码仍然需要全部重新编译，而前面的表格驱动模型在这方面提供了较大的弹性，因为他多提供了一层间接性，当然是付出了时间和空间上的代价。</li>
</ul>


<h2>在加上继承情况下的对象模型</h2>

<p><code>C++</code>支持单继承、多继承、虚继承，下面来看下<code>base class</code>实体在<code>derived class</code>中是如何被构建的。</p>

<p><code>简单对象模型</code>中可以通过<code>derived class object</code>中的一个<code>slot</code>来存储<code>base class subobject</code>的地址，这样就可以通过该<code>slot</code>来访问<code>base class</code>的成员。这种实现方式的主要缺点是：因为间接性的存储而导致空间和存取时间上存在额外负担；优点是：<code>derived class</code>的结构不会因为<code>base class</code>的改变而改变。</p>

<p><code>表格驱动对象模型</code>中可以利用一个类似<code>base class table</code>的表格来存储所有基类的信息。该表格中存储一系列<code>slot</code>，每个<code>slot</code>存储一个<code>base class</code>的地址。这种实现方式的缺点是：因为间接性的存储而导致空间和存取时间上存在额外负担；优点是：一是所有继承的<code>class</code>都有一致的表现形式（包含一个<code>base table</code>指针，指向基类表）与基类的大小和数目没有关系，二是<code>base class table</code>增加了子类的扩展性，当基类发生改变时，可以通过扩展、缩小或者更改<code>base class table</code>来进行调整。 <br/>
以上两种实现方式都存在一个重要的问题，就是由于间接性而导致的空间和时间上的额外负担，并且该间接性的级数会随着继承的深度而增加。</p>

<p><code>C++</code>   最初采用的继承模型并不采用任何间接性，所有基类的数据直接存储在子类当中，这样在存储结构和访问效率上是最高效的。当然也有缺点：当<code>base class members</code>有任何改变，用到此<code>base class</code>或者<code>derived class</code>的对象必须重新编译。在<code>C++ 2.0</code>引入了<code>virtual base class</code>，需要一些间接性的方式来支持该特性，一般会导入一个<code>virtual base class table</code>或者扩展已有的<code>virtual table</code>，详细会在后面博文讨论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown 语法新手指南]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/04/markdownyu-fa-xin-shou-zhi-nan/"/>
    <updated>2015-02-04T11:18:16+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/04/markdownyu-fa-xin-shou-zhi-nan</id>
    <content type="html"><![CDATA[<h2>引言</h2>

<p>Markdown 的权威介绍<a href="http://daringfireball.net/projects/markdown/syntax">Markdown Syntax</a>，中文版<a href="http://wowubuntu.com/markdown/">Markdown 语法说明</a>，本文只是把常用的一些语法总结一下，适合新手快速入门。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a><!--more--></p>

<h2>标题</h2>

<p>Markdown 支持在行首插入 1 到 6 个 <code>#</code>来表示 1 到 6 级标题，例如：</p>

<pre><code>## 这是 H2
### 这是 H3
###### 这是 H6
</code></pre>

<p><strong>显示效果：</strong></p>

<h2>这是 H2</h2>

<h3>这是 H3</h3>

<h6>这是 H6</h6>

<p>你可以选择性地「闭合」样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上<code>#</code>，而行尾的<code>#</code> 数量也不用和开头一样。</p>

<h2>段落和换行</h2>

<p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行。Markdown 对换行的处理和其他大部分的 text-to-HTML 格式不太一样，其他的格式会把每个换行自动转换为<code>&lt;br/&gt;</code>标签，而 Markdown 对换行的处理原则是：在换行处需插入两个及以上的空格再回车。例如：</p>

<pre><code>其实我想换行（一个空格 + 回车）
但是没用成功
</code></pre>

<p><strong>显示效果：</strong><br/>
其实我想换行（一个空格 + 回车）
但是没用成功</p>

<pre><code>再试一次（两个空格 + 回车）
成功换行
</code></pre>

<p><strong>显示效果：</strong><br/>
再试一次（两个空格 + 回车）<br/>
成功换行</p>

<h2>列表</h2>

<p>Markdown 支持有序列表和无序列表。无序列表使用<code>*</code>、<code>+</code>或<code>-</code>作为列表标记，且标记后面要有一个空格，例如：</p>

<pre><code>* 星号Red
* 星号Green
* 星号Blue
+ 加号Red
+ 加号Green
+ 加号Blue
- 减号Red
- 减号Green
- 减号Blue
</code></pre>

<p><strong>显示效果：</strong></p>

<ul>
<li>星号Red</li>
<li>星号Green</li>
<li>星号Blue</li>
<li>加号Red</li>
<li>加号Green</li>
<li>加号Blue</li>
<li>减号Red</li>
<li>减号Green</li>
<li>减号Blue</li>
</ul>


<p>有序列表则使用数字接着一个英文句点，而且你在列表标记上使用的数字并不会影响输出的 HTML 结果，例如：</p>

<pre><code>2. Red
1. Green
3. Blue
</code></pre>

<p><strong>显示结果：</strong></p>

<ol>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ol>


<h2>引用</h2>

<p>Markdown 的引用是在行首插入<code>&gt;</code>，例如：</p>

<pre><code>&gt;锄禾日当午，汗滴禾下土。
&gt;谁知盘中餐，粒粒皆辛苦。
</code></pre>

<p><strong>显示结果：</strong></p>

<blockquote><p>锄禾日当午，汗滴禾下土。 <br/>
谁知盘中餐，粒粒皆辛苦。</p></blockquote>

<p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上<code>&gt;</code>，例如：</p>

<pre><code>&gt;锄禾日当午，汗滴禾下土。（换行处要留有 2 个及以上空格）
谁知盘中餐，粒粒皆辛苦。
</code></pre>

<p><strong>显示结果：</strong></p>

<blockquote><p>锄禾日当午，汗滴禾下土。<br/>
谁知盘中餐，粒粒皆辛苦。</p></blockquote>

<p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的<code>&gt;</code> :</p>

<pre><code>&gt; 一级引用内容
&gt;
&gt; &gt; 二级引用内容  
&gt; 
&gt; 一级引用内容
</code></pre>

<p><strong>显示结果：</strong></p>

<blockquote><p>一级引用内容</p>

<blockquote><p>二级引用内容</p></blockquote>

<p>一级引用内容</p></blockquote>

<p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>

<pre><code>&gt; ## 这是一个二级标题。
&gt; 
&gt; 1. 这是第一行列表项。
&gt; 2. 这是第二行列表项。
&gt; 
&gt; 下面是一个代码块：
&gt; 
&gt;     return "Hello Markdown！";
</code></pre>

<p><strong>显示结果：</strong></p>

<blockquote><h2>这是一个二级标题。</h2>

<ol>
<li>这是第一行列表项。</li>
<li>这是第二行列表项。</li>
</ol>


<p>下面是一个代码块：</p>

<pre><code>return "Hello Markdown！";
</code></pre></blockquote>

<h2>链接</h2>

<p>Markdown 的链接格式为：<code>[展现的内容](链接的地址)</code>。要建立一个链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>

<pre><code>我的博客地址 [GLGJing's Blog](http://glgjing.github.io "鼠标 hover 上去会显示该内容")
</code></pre>

<p><strong>显示结果：</strong><br/>
我的博客地址 <a href="http://glgjing.github.io" title="鼠标 hover 上去会显示该内容">GLGJing&rsquo;s Blog</a></p>

<p>如果想要链接到本机的资源，可以使用相对路径：</p>

<pre><code>博客的关于页 [about](/about/)
</code></pre>

<p><strong>显示结果：</strong><br/>
博客的关于页 <a href="http://glgjing.github.io/about/">about</a></p>

<p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>

<pre><code>网址：&lt;http://glgjing.github.io&gt;  
邮箱：&lt;GLGJing@gmail.com&gt;
</code></pre>

<p><strong>显示结果：</strong><br/>
 网址：<a href="http://glgjing.github.io">http://glgjing.github.io</a><br/>
 邮箱：<a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#71;&#x4c;&#71;&#x4a;&#105;&#x6e;&#x67;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;">&#x47;&#x4c;&#x47;&#74;&#105;&#x6e;&#103;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;</a></p>

<h2>强调</h2>

<p>Markdown 使用星号<code>*</code>和底线<code>_</code>作为标记强调字词的符号，被一个<code>*</code>或<code>_</code>包围的字词会被转成用<code>&lt;em&gt;</code>标签包围，被两个<code>*</code>或<code>_</code>包起来的话，则会被转成<code>&lt;strong&gt;</code>，但是如果你的<code>*</code>或<code>_</code>两边都有空白的话，它们就只会被当成普通的符号，例如：</p>

<pre><code>*我要强调一下*
_我要再强调一下_
**我要重点强调一下**
__我要重点再强调一下__
* 此强调没用 * 
</code></pre>

<p><strong>显示结果：</strong><br/>
<em>我要强调一下</em><br/>
<em>我要再强调一下</em><br/>
<strong>我要重点强调一下</strong><br/>
<strong>我要重点再强调一下</strong><br/>
* 此强调没用 *</p>

<h2>代码块</h2>

<p>如果要标记一小段行内代码，你可以用反引号<code>`</code>把它包起来，例如：</p>

<pre><code>这里的`Func()`是一个函数
</code></pre>

<p><strong>显示结果：</strong><br/>
这里的<code>Func()</code>是一个函数</p>

<p>要在 Markdown 中建立代码区块也很简单，只要缩进 4 个空格或是 1 个制表符就可以，但要注意代码段和普通段落之间要留有一个及以上的空行，例如，下面的输入：</p>

<pre><code>这是一个普通段落：（注意此处留有 2 个以上空格和换行）

    这是一个代码区块。
</code></pre>

<p><strong>显示结果：</strong><br/>
这是一个普通段落：（注意此处留有 2 个以上空格和换行）</p>

<pre><code>这是一个代码区块。
</code></pre>

<h2>图片</h2>

<p>Markdown 使用一种和链接很相似的语法来标记图片，具体格式为<code>![]()</code>，其中一个惊叹号<code>!</code>接着一个方括号<code>[]</code>，里面放上图片的替代文字
接着一个普通括号<code>()</code>，里面放上图片的网址，最后还可以用引号包住并加上选择性的 &lsquo;title&rsquo; 文字，例如：</p>

<pre><code>![示例图片](/images/my_photo.png)
</code></pre>

<p><strong>显示结果：</strong><br/>
<img src="http://glgjing.github.io/images/my_photo.png" alt="示例图片" /><br/>
到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的<code>&lt;img&gt;</code>标签。</p>

<h2>反斜杠转义</h2>

<p>介绍完前面各种标记格式，相信有人心里会有疑问：如果我想在正文显示上面的标记该怎么办，例如我就想显示 *Hello Markdown* ,但被显示成 <em>Hello Markdown</em>，<code>*</code>被当成了重点标记。Markdown 是支持反斜杠转义的，可被转义的字符包括：</p>

<pre><code>\   反斜线
`   反引号
*   星号
_   底线
{}  花括号
[]  方括号
()  括弧
#   井字号
+   加号
-   减号
.   英文句点
!   惊叹号
</code></pre>

<p>所以上面那种情况，你就可以输入<code>\*Hello Markdown\*</code>，就会被显示为：*Hello Markdown*。</p>

<h2>Markdown 免费编辑器</h2>

<p><a href="http://wowubuntu.com/markdown/">Markdown 语法说明</a>里面有介绍各个平台的 Markdown 免费编辑器，这里就不再列出，我用的是<a href="http://25.io/mou/">Mou</a>，个人觉得还可以，比较简洁，只是偶尔会卡顿，免费的东西已经算很不错了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为 Git 添加多个公秘钥]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/02/gitru-he-tong-shi-shi-yong-duo-ge-gong-yao/"/>
    <updated>2015-02-02T16:46:55+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/02/gitru-he-tong-shi-shi-yong-duo-ge-gong-yao</id>
    <content type="html"><![CDATA[<h2>小引</h2>


<p>最近将博客从 github 上迁移到了国内的 gitcafe，主要原因是在国内的访问速度你懂的。迁移之后发现问题来了，每次连接时 SSH 客户端发送本地私钥到服务端验证，而这个私钥默认是 ~/.ssh/id_rsa 文件，如果只有一个账户，连接的服务器上保存的公钥和发送的私钥自然是配对的。但是我已经有了两个账户了，当然 username 和 email 是完全不同的，如果还是都读取默认的 ~/.ssh/id_rsa 文件，那么 gitcafe 账户的公钥和私钥显然是不匹配的。所以需要为 gitcafe 账户再添加一对公秘钥，并且可以根据账户自动寻找匹配的公秘钥。转载请注明出处<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code><!-- more --></p>

<h2>生成新的 rsa key</h2>


<p>在命令行输入如下命令，将命令中的 <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x59;&#79;&#85;&#82;&#x5f;&#x45;&#77;&#65;&#x49;&#x4c;&#64;&#89;&#x4f;&#85;&#82;&#x45;&#77;&#x41;&#x49;&#x4c;&#x2e;&#67;&#79;&#x4d;">&#x59;&#x4f;&#x55;&#x52;&#x5f;&#x45;&#77;&#65;&#x49;&#76;&#64;&#x59;&#x4f;&#x55;&#x52;&#69;&#77;&#x41;&#73;&#x4c;&#x2e;&#x43;&#79;&#77;</a> 改为你的 Email 地址。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh-keygen -t rsa -C "YOUR_EMAIL@YOUREMAIL.COM" -f ~/.ssh/gitcafe_rsa</span></code></pre></td></tr></table></div></figure>


<p>生成过程中会出现以下信息，按屏幕提示操作输入 passphrase 口令，也可以直接回车设为空。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Generating public/private rsa key pair.
</span><span class='line'>Enter passphrase (empty for no passphrase):
</span><span class='line'>Enter same passphrase again:
</span><span class='line'>Your identification has been saved in /Users/username/.ssh/gitcafe_rsa.
</span><span class='line'>Your public key has been saved in /Users/username/.ssh/gitcafe_rsa.pub.
</span><span class='line'>The key fingerprint is:
</span><span class='line'>15:81:d2:7a:c6:6c:0f:ec:b0:b6:d4:18:b8:d1:41:48 YOUR_EMAIL@YOUREMAIL.COM</span></code></pre></td></tr></table></div></figure>


<p>此时在 ~/.ssh/ 目录下会生成 gitcafe_rsa 和 gitcafe_rsa.pub两个文件。</p>

<h2>配置新的 rsa key</h2>


<p>在 SSH 用户配置文件 ~/.ssh/config 中指定对应服务所使用的公秘钥名称，如果没有 config 文件的话就新建一个，并输入以下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Host gitcafe.com www.gitcafe.com
</span><span class='line'>  IdentityFile ~/.ssh/gitcafe</span></code></pre></td></tr></table></div></figure>


<p>然后将 gitcafe_rsa.pub 文件中的内容复制到 gitcafe 的 SSH 公钥中，具体参见<a href="https://gitcafe.com/GitCafe/Help/wiki/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AE%20Git">这里</a>，这样就完成了新的公秘钥配置。可以运行下面的命令进行测试</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Host gitcafe.com www.gitcafe.com
</span><span class='line'>ssh -T git@gitcafe.com</span></code></pre></td></tr></table></div></figure>


<p>如果连接成功的话，会出现以下信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Host gitcafe.com www.gitcafe.com
</span><span class='line'>Hi USERNAME! You've successfully authenticated, but GitCafe does not provide shell access.</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>


<p>这里以 gitcafe 为例讲述了如何为git添加多个公秘钥，其他的公秘钥添加方法基本类似。参考：<a href="https://gitcafe.com/GitCafe/Help/wiki/%E5%A6%82%E4%BD%95%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%85%AC%E7%A7%98%E9%92%A5">如何同时使用多个公秘钥</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Octopress和Github搭建个人博客（四）：自定义字体]]></title>
    <link href="http://glgjing.github.io/blog/2015/01/31/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(si-):zi-ding-yi-zi-ti/"/>
    <updated>2015-01-31T17:00:48+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/01/31/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(si-):zi-ding-yi-zi-ti</id>
    <content type="html"><![CDATA[<h2>修改博客字体</h2>


<p>Octopress字体的设置文件是：sass/custom/_fonts.scss，内容类似如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$sans: "Open Sans","Helvetica Neue", Arial, sans-serif !default;
</span><span class='line'>$serif: "PT Serif", Georgia, Times, "Times New Roman", serif !default;
</span><span class='line'>$mono: Menlo, Monaco, "Andale Mono", "lucida console", "Courier New", monospace !default;
</span><span class='line'>$heading-font-family: "Fjalla One", "Georgia", "Helvetica Neue", Arial, sans-serif !default;
</span><span class='line'>$header-title-font-family: $heading-font-family !default;
</span><span class='line'>$header-subtitle-font-family: $serif !default;</span></code></pre></td></tr></table></div></figure>


<ul>
    <li>$sans：定义的是无衬线正文的字体</li>
    <li>$serif：定义的是衬线正文的字体</li>
    <li>$mono：定义的是代码的字体</li>
    <li>$heading-font-family：定义的是文章标题的字体</li>
    <li>$header-title-font-family：定义的是博客标题的字体</li>
    <li>$header-subtitle-font-family：定义的是博客子标题的字体</li>
</ul>


<p>如果需要更改字体，在这里更改对应的值即可。需要注意的是在跨平台的情况下，一些字体在很多机上不一定会有，所以尽量定义一些常用字体作为备选方案。例如Adobe的开源字体Source Code Pro作为代码字体，个人感觉很不错，但很多机器上不一定有装，所以这里最好补上其他字体作为备选，Windows上比较适合的编程字体Consolas，Mac上比较适合的编程字体Monaco，以及Ubuntu上比较适合的编程字体Ubuntu Mono。浏览器在渲染字体的时候会依次进行寻找，如果本机装有Source Code Pro就用该字体进行渲染，如果没有则寻找下一个也就是Consolas，依此类推直到找到一个可用的字体进行渲染，上诉三款字体都是三个平台默认安装的，这样可以最大程度地保证代码阅读质量。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ 自增、自减操作符前缀与后缀的区别]]></title>
    <link href="http://glgjing.github.io/blog/2015/01/12/c-plus-plus-zi-zeng-(-plus-plus-)zi-jian-(-)cao-zuo-fu-qian-zhui-yu-hou-zhui-de-qu-bie/"/>
    <updated>2015-01-12T20:28:11+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/01/12/c-plus-plus-zi-zeng-(-plus-plus-)zi-jian-(-)cao-zuo-fu-qian-zhui-yu-hou-zhui-de-qu-bie</id>
    <content type="html"><![CDATA[<p>自减和自增操作符规则相同，这里就以自增为例进行说明。C++的自增<code>++</code>操作符分为前缀形式和后缀形式，在语法上前缀与后形式的主要区别在于：前缀形式有时叫做“增加然后取回”，后缀形式叫做“取回然后增加”。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="mi">0</span>
</span><span class='line'><span class="mi">1</span>
</span><span class='line'><span class="mi">1</span>
</span><span class='line'><span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>然而有一个句法上的问题，当对<code>operator ++</code>函数进行重载时，需要自增操作符的前缀和后缀形式有不同的参数。但是不论是自增或自减的前缀还是后缀都只有一个参数。为了解决这个语言问题，<code>C++</code>规定后缀形式有一个<code>int</code>类型参数,当函数被调用时,编译器传递一个<code>0</code>做为<code>int</code>参数的值给该函数，具体实现如下：<!-- more --></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">UPInt</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">UPInt</span><span class="p">()</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">UPInt</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">*</span><span class="k">this</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">const</span> <span class="n">UPInt</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UPInt</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>    <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">old</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">UPInt</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="kt">int</span> <span class="n">rValue</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">value</span> <span class="o">+=</span> <span class="n">rValue</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">int</span> <span class="n">getValue</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">protected</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">UPInt</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class='line'>  <span class="n">UPInt</span> <span class="n">a</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 调用 const UPInt operator++(int)</span>
</span><span class='line'>  <span class="n">UPInt</span> <span class="n">b</span> <span class="o">=</span> <span class="o">++</span><span class="n">tmp</span><span class="p">;</span> <span class="c1">// 调用 UPInt&amp; operator++()</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">getValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">getValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="mi">0</span>
</span><span class='line'><span class="mi">2</span>
</span></code></pre></td></tr></table></div></figure>


<p>在重载<code>++</code>和<code>&ndash;</code>操作符时最好是遵从<code>c++</code>规范，否则会写出让其他人很迷惑的代码。这里有几点需要注意的地方：</p>

<ol>
    <li>前缀形式返回值是引用很好理解，但为什么后缀返回值是<code>const</code>类型？</li>
    <li>看到后缀形式的<code>++</code>实现，是否有效率上的问题？</li>
    <li>为什么后缀形式的<code>++</code>内部没有直接实现自增功能，而是调用了前缀形式的<code>++</code>？</li>
</ol>


<h3>1 为什么后缀返回值是<code>const</code>类型？</h3>


<p>假设不是 const 对象,下面的代码就是正确的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">UPInt</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'><span class="n">i</span><span class="o">++++</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码相当于<code>i.operator++(0).operator++(0);</code>。很明显，第一个调用的 <code>operator++</code>函数返回的临时对象调用了第二个<code>operator++</code>函数。这样做的问题是：一是与内置类型行为不一致，当设计一
个类遇到问题时,一个好的准则是使该类的行为与int类型一致，而int类型不允许连续进行两次后缀自增；二是使用两次后缀<code>++</code>所产生的结果与调用者期望的不一致，第二次调用<code>operator++</code>改变的值是第一次调用返回对象的值，而不是原始对象的值。 因此如果<code>i++++;</code>是合法的，<code>i</code>将仅仅增加了一次。</p>

<h3>2 后缀形式的<code>++</code>实现，是否有效率上的问题?</h3>


<p>后缀形式的<code>++</code>函数必须建立一个临时对象以做为它的返回值，上述实现代码建立了一个临时对象(oldValue)，这个临时对象必须被构造并在最后被析构。所以如果仅为了提高代码效率，应该尽量使用前缀形式的<code>++</code>，因为它的效率较高。</p>

<h3>3 为什么后缀形式的<code>++</code>内部没有直接实现自增功能，而是调用了前缀形式的<code>++</code>？</h3>


<p>可以看出后缀与前缀形式的<code>++</code>操作符除了返回值不同外，所完成的功能是一样的。所以需要确保后缀和前缀的<code>++</code>的行为一致性，当不同的程序员去维护和升级代码时，有什么能保证它们不会产生差异？遵守上述代码里的原则，则仅仅需要维护前缀版本,因为后缀形式自动与前缀形式的行为一致。
转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 清除未跟踪文件]]></title>
    <link href="http://glgjing.github.io/blog/2015/01/09/git-qing-chu-wei-gen-zong-wen-jian/"/>
    <updated>2015-01-09T16:34:45+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/01/09/git-qing-chu-wei-gen-zong-wen-jian</id>
    <content type="html"><![CDATA[<p>在利用<code>git</code>工作时，工程目录下经常会出现一些未跟踪文件，虽然<code>git</code>支持通过<code>.gitingore</code>文件添加一些忽略文件类型和文件目录。但有时需要清理一些临时文件和自动生成的文件，手动删除显得太麻烦，这时你可以利用<code>git clean</code>命令来帮你完成这项操作。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<code>git clean</code>命令支持以下参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean [-d] [-f] [-i] [-n] [-q] [-e &lt;pattern>] [-x | -X] [--] &lt;path>...</span></code></pre></td></tr></table></div></figure>


<p>其中几个主要参数用法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-d   # 删除未跟踪目录以及目录下的文件，如果目录下包含其他git仓库文件，并不会删除（-dff可以删除）。
</span><span class='line'>-f   # 如果 git cofig 下的 clean.requireForce 为true，那么clean操作需要-f(--force)来强制执行。
</span><span class='line'>-i   # 进入交互模式
</span><span class='line'>-n   # 查看将要被删除的文件，并不实际删除文件</span></code></pre></td></tr></table></div></figure>


<p>通过以上几根参数组合，基本上可以满足删除未跟踪文件的需求了。例如在删除前先查看有哪些文件将被删除运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean -n</span></code></pre></td></tr></table></div></figure>


<p>想删除当前工作目录下的未跟踪文件，但不删除文件夹运行（如果<code>clean.requireForce</code>为<code>false</code>可以不加<code>-f</code>选项）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean -f</span></code></pre></td></tr></table></div></figure>


<p>想删除当前工作目录下的未跟踪文件以及文件夹运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean -df</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 修改提交历史]]></title>
    <link href="http://glgjing.github.io/blog/2015/01/06/git-xiu-gai-ti-jiao-li-shi/"/>
    <updated>2015-01-06T11:14:40+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/01/06/git-xiu-gai-ti-jiao-li-shi</id>
    <content type="html"><![CDATA[<h2>引言</h2>


<p>在使用git进行工作时，经常会碰到想要修改本地提交记录（还没有push到远程仓库）的情况。例如这样一个场景：你接到一个任务，这个任务可能需要一个星期的开发时间，于是你从<code>master</code>分之上运行<code>git checkout -b new_branch</code>命令，<code>checkout</code>到<code>new_branch</code>分之上进行该任务的开发，在开发的过程中向<code>new_branch</code>分之提交了多个<code>commit</code>，然后发现有些代码不是很合理，于是又更改代码提交新的<code>commit</code>，反反复复终于完成了该任务的开发，是时候提交review并合并到<code>master</code>分之上了，但是你发现提交记录非常混乱，并不利于同事review，而且你的同事也不关心你的具体修改过程，他们只想看到最终的实现，此时问题来了，如果你把所有的<code>commit</code>合并成一个大<code>commit</code>，虽然你的同事可以直接看到最终代码，但你的各个模块都混在一起提交，很难按模块单独进行review并发现问题；如果你直接提交review，你的同事就不得不把你的所有提交历史都review一遍，包括一些实际上已经在后面提交中被你修改掉的代码，脾气好的估计内心一万只草泥马奔过，脾气不好的保证不打死你！当然<code>git</code>是不可能考虑不到这种情况的，扯了这么多，下面就来看一下如何修改<code>git</code>的提交历史。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<!-- more --></p>

<h2>一 修改最近一次提交记录</h2>


<h3>1 只修改提交说明</h3>


<p>修改最近一次提交是非常常见的需求，如果只想更改最近一次的提交说明是非常方便的，只需输入如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git commit —amend</span></code></pre></td></tr></table></div></figure>


<p>然后你就会进入文本编辑器，输入你想要的内容，保存并退出即可。</p>

<h3>2 添加新的更改</h3>


<p>如果你完成提交后又想修改被提交的快照，增加或者修改其中的文件，过程基本和上面一样。先运<code>git add</code>命令，将修改的文件添加到缓存区,然后运行<code>git commit —amend</code>命令，该命令会获取你当前的暂存区的内容一并提交到最后一次<code>commit</code>。例如：新加了一个文件new_file.cpp，想要合并到最后一次提交，过程如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add new_file.cpp
</span><span class='line'>git commit —amend</span></code></pre></td></tr></table></div></figure>


<p>也可以直接运行下面的命令，不过要小心，不要提交了多余的文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git commit -a —amend</span></code></pre></td></tr></table></div></figure>


<h3>3 将文件从本次提交中移除</h3>


<p>如果想把已经<code>commit</code>的文件从这次<code>commit</code>移除的话，可以运行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git reset [—soft] HEAD~1 # —soft可加可不加，默认就是soft选项
</span><span class='line'>git checkout —filename # 要从本次提交移除的文件名
</span><span class='line'>git commit -m “new commit"</span></code></pre></td></tr></table></div></figure>


<h2>二 修改多个提交</h2>


<p>要修改历史中更早的提交，你必须采用更复杂的工具。<code>git</code>没有一个修改历史的工具，但是你可以使用<code>rebase</code>工具来衍合一系列的提交到它们原来所在的<code>HEAD</code>上。依靠这个交互式的<code>rebase</code>工具，你就可以停留在每一次提交后，如果你想修改或改变说明、增加文件或任何其他事情。你可以通过给<code>git rebase -i</code>命令以交互方式进行<code>rebase</code>。例如，你想修改最近三次的提交说明，或者其中任意一次，你必须给<code>git rebase -i</code>提供一个参数，指明你想要修改的提交的父提交。例如<code>HEAD~3</code>是指从<code>HEAD</code>指针到<code>HEAD+3</code>的位置，也就是最近第4次提交。所以想修改最近3次提交，你需要指明第3次提交的父提交（第4次提交）即<code>HEAD~3</code>。运行命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git rebase -i HEAD~3</span></code></pre></td></tr></table></div></figure>


<p>再次提醒这是一个衍合命令，也就是<code>HEAD~3</code>到<code>HEAD</code>范围内的每一次提交都会被重写，不管你是否修改提交说明<code>SHA-1</code>的值都会发生变化。<font color="red">所以千万不要涵盖你已经推送到中心服务器的提交。</font>这么做会使其他开发者产生混乱，因为你提供了同样变更的不同版本。运行该命令后进入交互界面，类似：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>
</span><span class='line'># Rebase f77f585..fecb551 onto f77f585
</span><span class='line'>#
</span><span class='line'># Commands:
</span><span class='line'>#  p, pick = use commit
</span><span class='line'>#  r, reword = use commit, but edit the commit message
</span><span class='line'>#  e, edit = use commit, but stop for amending
</span><span class='line'>#  s, squash = use commit, but meld into previous commit
</span><span class='line'>#  f, fixup = like "squash", but discard this commit's log message
</span><span class='line'>#  x, exec = run command (the rest of the line) using shell
</span><span class='line'>#
</span><span class='line'># These lines can be re-ordered; they are executed from top to bottom.
</span><span class='line'># If you remove a line here THAT COMMIT WILL BE LOST.
</span><span class='line'># However, if you remove everything, the rebase will be aborted.
</span><span class='line'># Note that empty commits are commented out</span></code></pre></td></tr></table></div></figure>


<p>根据命令提示，就可以进行历史更改了。很重要的一点是你得注意这些提交的顺序与你通常通过<code>log</code>命令看到的是相反的。如果你运行<code>log</code>，你会看到下面这样的结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick fecb551 Init the view model</span></code></pre></td></tr></table></div></figure>


<h3>1 修改指定提交</h3>


<p>例如：只修改最近第3次提交说明可以进行如下更改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reword fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>保存并退出编辑器，<code>rebase</code>命令在衍合到第3次提交时会进入提交说明编辑页面，在此进行编辑新的提交说明，保存并退出即可，<code>rebase</code>命令继续进行直至完成全部衍合操作。如果你不仅想要修改提交说明，还要更改提交，可以进行如下更改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>edit fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>保存并退出编辑器，<code>rebase</code>命令在衍合到第三次提交时会等待你提交新的更改，并提示你修改完成后运行<code>git commit &ndash;amend</code>命令，然后运行<code>git rebase &ndash;continue</code>继续进行<code>rebase</code>直至完成全部衍合。</p>

<h3>2 重排提交</h3>


<p>你也可以使用<code>git rebase -i</code>命令对提交历史彻底重排或删除提交。例如你想删除&#8221;Update the version&#8221;这个提交，并且修改其他两次提交的顺序，可以将</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>改为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>pick fecb551 Init the view model</span></code></pre></td></tr></table></div></figure>


<p>然后保存并退出编辑器，此时<code>rebase</code>命令会先应用bc5cd9d (Add new method)，然后应用 fecb551 (Init the view model)bb199a0 Update the version这次提交。
然后保存并退出编辑器，此时<code>rebase</code>命令会先应用bc5cd9d (Add new method)，然后应用 fecb551 (Init the view model)，接着停止。执行完上诉操作，你已经修改了这些提交的顺序，并且删除了bb199a0 (Update the version)这次提交。</p>

<h3>3 合并提交</h3>


<p><code>git rebase -i</code>命令还可以将一系列提交合并成一个提交。从上面的脚本提示中可以看到<code>s, squash = use commit, but meld into previous commit</code>提示。如果用<code>squash</code>修饰提交就可以进行提交之间的合并，例如可以将脚本修改成这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>squash bb199a0 Update the version
</span><span class='line'>squash bc5cd9d Add new method</span></code></pre></td></tr></table></div></figure>


<p>保存并退出编辑器，<code>rebase</code>命令会应用全部三次变更然后进入编辑器来归并三次提交说明。当你保存之后，你就拥有了一个包含前三次提交的全部变更的单一提交。</p>

<h3>4 拆分提交</h3>


<p>拆分提交实际上就是撤销一次提交，然后分多次进行重新提交。例如你想将三次提交中的中间一次拆分。将&#8221;Update the version&#8221;拆分成两次提交：&#8221;Update the version1&#8221;和&#8221;Update the version2&#8221;，可以进行如下修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>edit bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method</span></code></pre></td></tr></table></div></figure>


<p>当<code>rebase</code>到bb199a0时，会进入等待你提交新<code>commit</code>的状态，这时看可以运行<code>git reset HEAD^</code>对当前提交进行重置，然后分别运行<code>git add</code>命令添加想要提交的文件，分别进行<code>git commit</code>，最后运行<code>git rebase &ndash;continue</code>完成所有衍合。整体过程如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git reset HEAD^
</span><span class='line'>git add file1
</span><span class='line'>git commit -m 'Update the version1'
</span><span class='line'>git add file2
</span><span class='line'>git commit -m 'Update the version2'
</span><span class='line'>git rebase --continue</span></code></pre></td></tr></table></div></figure>


<p>执行完上诉操作，提交历史看起来就像这样了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1c002dd Add new method
</span><span class='line'>9b29157 Update the version2
</span><span class='line'>35cfb2b Update the version1
</span><span class='line'>f3cc40e Init the view model</span></code></pre></td></tr></table></div></figure>


<p><font color="red">再次提醒，这会修改你列表中的提交的<code>SHA</code>值，所以请确保这个列表里不包含你已经推送到共享仓库的提交。</font></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++虚函数浅析]]></title>
    <link href="http://glgjing.github.io/blog/2015/01/03/c-plus-plus-xu-han-shu-qian-xi/"/>
    <updated>2015-01-03T01:59:30+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/01/03/c-plus-plus-xu-han-shu-qian-xi</id>
    <content type="html"><![CDATA[<h2>一 引言</h2>


<p>C++面向对象语言的一大特性就是抽象，在程序设计上的体现就是鼓励面向接口编程，而不要面向具体实现编程。这里所说的抽象和接口与C++的多态性密切相关。C++的多态分为静态多态（编译时多态）和动态多态（运行时多态）两大类。静态多态通过重载、模板来实现；动态多态就是通过本文的主角虚函数来体现的。虚函数是C++语言一个非常重要的特性，不同编译器对此特性的实现机制也略有差别，虽然具体实现细节由编译器说的算，在大多情况下我们不需要关心，但虚函数在某些情况下对程序的占用内存大小和执行效率有比较明显的影响，这时候知道虚函数背后的实现原理，知其然、知其所以然是很有必要的。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<!-- more --></p>

<h2>二 虚函数实现原理</h2>


<p>虚函数的作用说白了就是：<font color="red">当调用一个虚函数时，被执行的代码必须和调用函数的对象的动态类型相一致。</font>编译器需要做的就是如何高效的实现提供这种特性。不同编译器实现细节也不相同。大多数编译器通过vtbl（virtual table）和vptr（virtual table pointer）来实现的。
当一个类声明了虚函数或者继承了虚函数，这个类就会有自己的vtbl。vtbl实际上就是一个函数指针数组，有的编译器用的是链表，不过方法都是差不多。vtbl数组中的每一个元素对应一个函数指针指向该类的一个虚函数，同时该类的每一个对象都会包含一个vptr，vptr指向该vtbl的地址。例如一个类的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func1</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Func2</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Func3</span><span class="p">();</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">Func4</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>A</code>类的对象的结构如下：
<img class="center" src="http://glgjing.github.io/images/1-5.png">
从图中可以看出<code>A</code>类对象中包含一个vptr，而vptr的值就是<code>A</code>类的vtbl的地址，vtbl中三个元素的值分别是虚函数<code>Func1</code>、<code>Func2</code>、<code>Func3</code>的地址，而非虚函数<code>Func4</code>并没有在vtbl中。</p>

<h3>1 单继承情况</h3>


<p>下面定义一个类<code>B</code>继承自类<code>A</code>，重写了(override)虚函数<code>Func1</code>，并且定义了自己的虚函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func1</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Func5</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>声明一个<code>A</code>类指针<code>A* a = new B;</code>。a的内容如下：
<img class="center" src="http://glgjing.github.io/images/1-6.png">
同样<code>a</code>的值包含一个vptr，vptr指向<code>B</code>类的vtbl，而<code>B</code>类的vtbl中元素的值相比<code>A</code>类的vtbl有一些变化，<code>B</code>类重写<code>A</code>类虚函数的地址<code>B::Func1</code>取代了<code>A::Func1</code>在vtbl的位置，<code>B</code>类新定义的虚函数<code>B::Func5</code>也被添加到vtbl中，且父类的虚函数在子类的虚函数前面。此时通过指针<code>a</code>调用<code>Func1</code>过程相当于：</p>

<ol>
  <li>通过指针<code>a</code>指向的地址，取出的具体值为类型<code>B</code>，找到里面的vptr，该vptr指向的是<code>B</code>类的vtbl</li>
  <li>通过vptr找到<code>B</code>类的vtbl地址</li>
  <li>然后通过<code>B</code>类的vtbl找到<code>Func1</code>的函数地址，调用执行，最终执行的就是<code>B::Func1</code></li>
</ol>


<p>以上过程就基本解释了C++虚函数是如何做到被执行的代码和调用函数的对象的动态类型相一致的特性了。</p>

<h3>2 多继承情况</h3>


<p>上面讨论的是单继承的情况，下面来看一下多继承情况。定义三个类<code>Base1</code><code>Base2</code><code>Base3</code>，和一个子类<code>SubClass</code>如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Base1</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">FuncB1</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Base2</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">FuncB2</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Base3</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">FuncB3</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">SubClass</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base1</span><span class="p">,</span> <span class="k">public</span> <span class="n">Base2</span><span class="p">,</span> <span class="k">public</span> <span class="n">Base3</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">FuncSub</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>SubClass</code>对象的结构如下：
<img class="center" src="http://glgjing.github.io/images/1-7.png">
可以看到<code>SubClass</code>对象包含三个vptr分别指向三个vtbl，每个vtbl对应一个父类的vtbl。当子类覆盖父类的虚函数时，对应的vtbl变化与单继承情况相同，就是子类的虚函数替换父类相应虚函数在vtbl的位置。子类新定义的虚函数，会放在第一个父类的vtbl的后面，这里的第一个是指继承类的顺序（<font color="red">其实这个并不是一定的，不同编译器有自由去选择不同的实现方式</font>）。之所以这样设计就是为了解决不同的父类类型指针在指向同一个子类实例，能够调用到各自实际的虚函数。具体的调用过程同单继承的情况相同。</p>

<h3>结论：</h3>


<ul>
  <li>每个声明了虚函数或者继承了虚函数的类，都会有一个自己的vtbl</li>
  <li>同时该类的每个对象都会包含一个vptr去指向该vtbl</li>
  <li>虚函数按照其声明顺序放于vtbl表中, vtbl数组中的每一个元素对应一个函数指针指向该类的虚函数</li>
  <li>如果子类覆盖了父类的虚函数，将被放到了虚表中原来父类虚函数的位置</li>
  <li>在多继承的情况下，每个父类都有自己的虚表。子类的成员函数被放到了第一个父类的表中</li>
</ul>


<h2>三 虚函数所需的代价</h2>


<p>上面介绍了虚函数的基本实现原理，虚函数的优点不用多说，实现了运行时多态的特性。下面来分析下虚函数所需的代价，程序运行时代价无非主要体现在时间和空间上。</p>

<h3>调用性能方面</h3>


<p>从前面虚函数的调用过程可知。当调用虚函数时过程如下（引自More Effective C++）:</p>

<ol>
  <li>通过对象的 vptr 找到类的 vtbl。这是一个简单的操作,因为编译器知道在对象内 哪里能找到 vptr(毕竟是由编译器放置的它们)。因此这个代价只是一个偏移调整(以得到 vptr)和一个指针的间接寻址(以得到 vtbl)。</li>
  <li>找到对应 vtbl 内的指向被调用函数的指针。这也是很简单的, 因为编译器为每个虚函数在 vtbl 内分配了一个唯一的索引。这步的代价只是在 vtbl 数组内 的一个偏移。</li>
  <li>调用第二步找到的的指针所指向的函数。</li>
</ol>


<p>在单继承的情况下，调用虚函数所需的代价基本上和非虚函数效率一样，在大多数计算机上它多执行了很少的一些指令，所以有很多人一概而论说虚函数性能不行是不太科学的。在多继承的情况下，由于会根据多个父类生成多个vptr，在对象里为寻找 vptr 而进行的偏移量计算会变得复杂一些，但这些并不是虚函数的性能瓶颈。
<font color="red">虚函数运行时所需的代价主要是虚函数不能是内联函。</font>这也是非常好理解的，是因为内联函数是指在编译期间用被调用的函数体本身来代替函数调用的指令，但是虚函数的“虚”是指“直到运行时才能知道要调用的是哪一个函数。”但虚函数的运行时多态特性就是要在运行时才知道具体调用哪个虚函数，所以没法在编译时进行内联函数展开。当然如果通过对象直接调用虚函数它是可以被内联，但是大多数虚函数是通过对象的指针或引用被调用的，这种调用不能被内联。 因为这种调用是标准的调用方式，所以虚函数实际上不能被内联。</p>

<h3>占用空间方面</h3>


<p>在上面的虚函数实现原理部分，可以看到为了实现运行时多态机制，编译器会给每一个包含虚函数或继承了虚函数的类自动建立一个虚函数表，<font color="red">所以虚函数的一个代价就是会增加类的体积。</font>在虚函数接口较少的类中这个代价并不明显，虚函数表vtbl的体积相当于几个函数指针的体积，如果你有大量的类或者在每个类中有大量的虚函数,你会发现 vtbl 会占用大量的地址空间。但这并不是最主要的代价，主要的代价是发生在类的继承过程中，在上面的分析中，可以看到，当子类继承父类的虚函数时，子类会有自己的vtbl，如果子类只覆盖父类的一两个虚函数接口，子类vtbl的其余部分内容会与父类重复。这在如果存在大量的子类继承，且重写父类的虚函数接口只占总数的一小部分的情况下，会造成大量地址空间浪费。在一些GUI库上这种大量子类继承自同一父类且只覆盖其中一两个虚函数的情况是经常有的，这样就导致UI库的占用内存明显变大。
<font color="red">由于虚函数指针vptr的存在，虚函数也会增加该类的每个对象的体积。</font>在单继承或没有继承的情况下，类的每个对象会多一个vptr指针的体积，也就是4个字节；在多继承的情况下，类的每个对象会多N个（N＝包含虚函数的父类个数）vptr的体积，也就是4N个字节。当一个类的对象体积较大时，这个代价不是很明显，但当一个类的对象很轻量的时候，如成员变量只有4个字节，那么再加上4（或4N）个字节的vptr，对象的体积相当于翻了1（或N）倍，这个代价是非常大的。</p>

<h2>四 总结</h2>


<p>本文主要介绍了虚函数的实现机制，以及实现该机制所付出的代价，这里没有进一步讨论继承的利与弊，但经过上面的一些讨论，也可以从侧面反映出一些问题。理解虚函数的代价是有必要的，一方面是有利于高效恰当的使用它，一方面也该意识到如果你需要这些功能, 不管采取什么样的方法你都得为此付出代价，在多数情况下,你的人工模拟可能比编译器生成的代码效率更低,稳定性更差。例如使用嵌套的<code>switch</code>语句或层叠的<code>if-then-else</code>语句模拟虚函数的调用,其产生的代码比虚函数的调用还要多,而且代码运行速度也更慢。再有你必须自己人工跟踪对象类型,这意味着对象会携带它们自己的类型标签(type tag)，因此你不会得到更小的对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++重载、重写、重定义区别]]></title>
    <link href="http://glgjing.github.io/blog/2014/12/27/c-plus-plus-zhong-zai-,-zhong-xie-,-zhong-ding-yi-qu-bie/"/>
    <updated>2014-12-27T15:32:17+08:00</updated>
    <id>http://glgjing.github.io/blog/2014/12/27/c-plus-plus-zhong-zai-,-zhong-xie-,-zhong-ding-yi-qu-bie</id>
    <content type="html"><![CDATA[<h2>一 重载（overload）</h2>


<h4>概念：</h4>


<p>函数有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数之间，互相称之为重载函数。</p>

<h4>基本条件：</h4>


<ul>
    <li>函数名必须相同；</li>
    <li>函数参数必须不相同，可以是参数类型或者参数个数不同；</li>
    <li>函数返回值可以相同，也可以不相同；</li>
</ul>


<blockquote><p><!-- more --></p></blockquote>

<h4>注意：</h4>


<ul>
    <li>只能通过不同的参数样式进行重载，例如：不同的参数类型，不同的参数个数，不同的参数顺序；</li>
    <li>不能通过访问权限、返回类型、抛出的异常进行重载；</li>
    <li>重载的函数应该在相同的作用域下；</li>
</ul>


<h4>验证程序：</h4>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;func 1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// OK: 通过参数类型不同重载 Func1()</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">double</span> <span class="n">arg1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;func 2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// OK: 通过参数个数不同重载 Func1()</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;func 3&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// OK: 重载函数返回值可以不同</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">arg2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;func 4&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// ERROR: 不能只通过返回值来进行重载</span>
</span><span class='line'>  <span class="cm">/*bool Func1(int arg1) {</span>
</span><span class='line'><span class="cm">    return true;</span>
</span><span class='line'><span class="cm">  } */</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>  <span class="n">a</span><span class="p">.</span><span class="n">Func1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="n">a</span><span class="p">.</span><span class="n">Func1</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">a</span><span class="p">.</span><span class="n">Func1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>  <span class="n">a</span><span class="p">.</span><span class="n">Func1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func 1
</span><span class='line'>func 2
</span><span class='line'>func 3
</span><span class='line'>func 4</span></code></pre></td></tr></table></div></figure>


<h2>二 重写（override）</h2>


<h4>概念：</h4>


<p>也称为覆盖，子类重新定义父类中有相同名称和参数的虚函数，主要在继承关系中出现。</p>

<h4>基本条件：</h4>


<ul>
    <li>重写的函数和被重写的函数必须为virtual函数，分别位于基类和派生类中；</li>
    <li>重写的函数和被重写的函数函数名和函数参数必须一致；</li>
    <li>重写的函数和被重写的函数返回值相同，或者都返回指针或引用，并且派生类虚函数所返回的指针或引用的类型是基类中被替换的虚函数所返回的</li>
    <li>指针或引用的类型的子类型。</li>
</ul>


<h4>注意：</h4>


<ul>
    <li>重写的函数所抛出的异常必须和被重写的函数所抛出的异常一致，或者是其子类；</li>
    <li>重写的函数的访问修饰符可以不同于被重写的函数，如基类的virtual函数的修饰符为private，派生类改为public或protected也是可以的。</li>
    <li>静态方法不能被重写，也就是static和virtual不能同时使用。</li>
    <li>重写的函数可以带virtual关键字，也可以不带。</li>
</ul>


<h4>验证程序：</h4>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func1</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class C: func 1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">virtual</span> <span class="n">A</span><span class="o">*</span> <span class="n">Func2</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class C: func 2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="n">A</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// ERROR:静态函数不能被声明为virtual，也就没办法被重写。</span>
</span><span class='line'>  <span class="c1">// static virtual void FuncStatic() {}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//由于Func3被声明为private，所以需要通过public函数来调用</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">ShowFunc3</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Func3</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func4</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class C: func 4&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'> <span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func3</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class C: func 3&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">C</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="c1">// OK: 重写C类Func1，可以不带virtual关键字</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class D: func 1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// OK: 当返回值为指针或者引用时，返回值可以是父类返回值类型的子类</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="n">B</span><span class="o">*</span> <span class="n">Func2</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class D: func 2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="n">B</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// ERROR: 除上面的情况，返回值类型要和父类一直</span>
</span><span class='line'>  <span class="cm">/*virtual bool Func2() {</span>
</span><span class='line'><span class="cm">  }*/</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// OK: 重写的函数的访问修饰符可以不同于被重写的函数</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func3</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class D: func 3&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'> <span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="c1">// OK: 重写的函数的访问修饰符可以不同于被重写的函数</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func4</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class D: func 4&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">C</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">D</span><span class="p">;</span>
</span><span class='line'>  <span class="n">c</span><span class="o">-&gt;</span><span class="n">Func1</span><span class="p">();</span>
</span><span class='line'>  <span class="n">c</span><span class="o">-&gt;</span><span class="n">Func2</span><span class="p">();</span>
</span><span class='line'>  <span class="n">c</span><span class="o">-&gt;</span><span class="n">ShowFunc3</span><span class="p">();</span>
</span><span class='line'>  <span class="n">c</span><span class="o">-&gt;</span><span class="n">Func4</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class D: func 1
</span><span class='line'>class D: func 2
</span><span class='line'>class D: func 3
</span><span class='line'>class D: func 4</span></code></pre></td></tr></table></div></figure>


<h2>三 重定义（redefining）</h2>


<h4>概念：</h4>


<p>也叫隐藏，子类重新定义父类中的非虚函数，屏蔽了父类的同名函数</p>

<h4>基本条件：</h4>


<ul>
    <li>被隐藏的函数之间作用域不相同</li>
</ul>


<h4>注意：</h4>


<ul>
    <li>子类和父类的函数名称相同，但参数不同，此时不管父类函数是不是virtual函数，都将被隐藏。</li>
    <li>子类和父类的函数名称相同，参数也相同，但是父类函数不是virtual函数，父类的函数将被隐藏。</li>
</ul>


<h4>验证程序：</h4>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class A: Func1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class A: Func2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="c1">// 将会重定义父类的方法</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class B: Func1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 将会重写(override)父类方法</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class B: Func2-1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 将会重定义父类的方法</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class B: Func2-2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">B</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="p">;</span>
</span><span class='line'>  <span class="n">b</span><span class="o">-&gt;</span><span class="n">Func1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="n">b</span><span class="o">-&gt;</span><span class="n">Func2</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="n">b</span><span class="o">-&gt;</span><span class="n">Func2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class B: Func1
</span><span class='line'>class B: Func2-1
</span><span class='line'>class B: Func2-2</span></code></pre></td></tr></table></div></figure>


<h2>四 总结</h2>


<p>重载、重写、重定义书面上的区别，以及各自的规则没有太大意义，而且这些名词本身都是翻译过来的，不同的地方翻译也不尽相同，如果初学C++，弄清每个概念的实际意义，以及为什么这么设计才是最重要的。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Octopress和Github搭建个人博客（三）：添加统计信息]]></title>
    <link href="http://glgjing.github.io/blog/2014/12/22/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(san-):tian-jia-tong-ji-xin-xi/"/>
    <updated>2014-12-22T16:46:14+08:00</updated>
    <id>http://glgjing.github.io/blog/2014/12/22/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(san-):tian-jia-tong-ji-xin-xi</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://glgjing.github.io/images/1-4.png"></p>

<h2>引言</h2>


<p>搭建好基本环境（如果没有请戳<a href="http://glgjing.github.io/blog/2014/12/06/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(%5B%3F%5D-):ji-chu-huan-jing-da-jian/">这里</a>），折腾完主题（如果想折腾请戳<a href="http://glgjing.github.io/blog/2014/12/12/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(er-):zi-ding-yi-zhu-ti/">这里</a>），就可以安安静静的写博客了。但博客毕竟不是日记，还是需要和其他人分享交流的，尤其是技术博客。那么首先你需要别人能够通过搜索引擎找到你的博客，其次你需要别人能够更方便准确的找到你的博客，这就需要为你的博客录入搜索引擎，添加统计信息，以便进行SEO。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<!-- more --></p>

<h2>目录</h2>


<ul>
    <li>一 录入搜索引擎</li>
    <li>二 添加统计信息</li>
    <li>三 总结</li>
</ul>


<h2>一 录入搜索引擎</h2>


<p>在自建博客网站上写的博客，一开始并不会在搜索引擎中搜得到，不像博客平台一样，因为你还没有向搜索引擎提交你的网站URL，让它去抓取你博客网站的内容。所以赶紧提交吧，提交地址：<code><a href="http://www.gongju.com/addurl/">http://www.gongju.com/addurl/</a></code>，也可以自行google：搜索引擎提交入口。提交完成之后，就可以在相应的搜索引擎中找到你的博客了。现在你还需要为你的网站和博文添加描述信息以及关键字，让其他人可以在搜索引擎中更方便准确的找到你的博客。为每篇博文添加关键字和描述的方法是，打开<code>source/_posts/</code>目录下对应的博文文件，在文件头部添加类似如下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>---
</span><span class='line'>layout: post
</span><span class='line'>title: "利用Octopress和Github搭建个人博客（三）：添加统计信息"
</span><span class='line'>date: 2014-12-22 16:46:14 +0800
</span><span class='line'>comments: true
</span><span class='line'>categories: Octopress
</span><span class='line'>keywords: Octopress github 搭建博客 添加统计 SEO 录入搜索引擎
</span><span class='line'>description: 为Octopress博客录入搜索引擎，并添加流量统计信息，进行SEO。
</span><span class='line'>---</span></code></pre></td></tr></table></div></figure>


<p>如果没有为博文添加描述信息，Octopress会自动以文章的前150字作为博文的描述信息。为网站首页添加关键字和描述的方法是，打开<code>source/index.html</code>文件，在文件头部添加类似如下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>---
</span><span class='line'>layout: default
</span><span class='line'>tags: [windows c++ octopress Github DirectUI GDI]
</span><span class='line'>keywords: windows c++ octopress Github
</span><span class='line'>description: 博客网站的描述信息在这里
</span><span class='line'>---</span></code></pre></td></tr></table></div></figure>


<p>通过以上操作，搜索引擎就可以根据用户输入的关键字对你的博文进行更准确的索引。如果想让自己的博客出现在搜索结果中靠前的位置，就需要网站流量统计工具进行进一步的SEO了。</p>

<h2>二 添加统计信息</h2>


<p>常用的网站统计工具有：Google Analytics，Yahoo网站流量统计，百度统计，CNZZ，51.la等等。Octopress自带Google Analytics工具，所以添加Google统计比较方便：</p>

<ol>
    <li>注册<a href="http://www.google.com/analytics/">Google Analytics</a>账号</li>
    <li>获得一个google_analytics_tracking_id，添加到_config.yml中google_analytics_tracking_id:后面</li>
    <li>按照Google Analytics提示，对博客网站进行验证</li>
</ol>


<p>完成以上步骤，就可以利用Google Analytics进行流量统计了，你还可以注册<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">Google站长工具</a>，进行更详细的分析和SEO。
除了自带的Google Analytics你还可以添加其他统计工具，具体步骤都比较类似，这里以CNZZ为例：</p>

<ol>
    <li>注册<a href="http://zhanzhang.cnzz.com/">CNZZ账号</a></li>
    <li>按照提示获取统计代码</li>
    <li>将统计代码添加到需要统计的页面，一般可以添加到<code>source/_includes/custom/footer.html</code>中</li>
</ol>


<p>添加到<code>source/_includes/custom/footer.html</code>中的统计代码类似如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;p&gt;</span>
</span><span class='line'>  Copyright <span class="ni">&amp;copy;</span> 2015 - GLGJing
</span><span class='line'>  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span><span class="nt">&gt;</span><span class="kd">var</span> <span class="nx">cnzz_protocol</span> <span class="o">=</span> <span class="p">((</span><span class="s2">&quot;https:&quot;</span> <span class="o">==</span> <span class="nb">document</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">protocol</span><span class="p">)</span> <span class="o">?</span> <span class="s2">&quot; https://&quot;</span> <span class="o">:</span> <span class="s2">&quot; http://&quot;</span><span class="p">);</span><span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">unescape</span><span class="p">(</span><span class="s2">&quot;%3Cspan id=&#39;cnzz_stat_icon_1253899728&#39;%3E%3C/span%3E%3Cscript src=&#39;&quot;</span> <span class="o">+</span> <span class="nx">cnzz_protocol</span> <span class="o">+</span> <span class="s2">&quot;s4.cnzz.com/z_stat.php%3Fid%3D1253899728&#39; type=&#39;text/javascript&#39;%3E%3C/script%3E&quot;</span><span class="p">));</span><span class="nt">&lt;/script&gt;</span>
</span><span class='line'><span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>三 总结</h2>


<p>这里主要介绍了如何将博客网站添加到搜索引擎，并添加网站流量统计工具，各种流量统计工具的优劣可以自行google，后面需要做的就是SEO了，而SEO是一件长期持续的工作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Octopress和Github搭建个人博客（二）：自定义主题]]></title>
    <link href="http://glgjing.github.io/blog/2014/12/12/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(er-):zi-ding-yi-zhu-ti/"/>
    <updated>2014-12-12T16:19:09+08:00</updated>
    <id>http://glgjing.github.io/blog/2014/12/12/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(er-):zi-ding-yi-zhu-ti</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://glgjing.github.io/images/1-2.png"></p>

<h2>引言</h2>


<p>在为Octopress博客自定义主题之前，你应该已经搭建好了基础环境。如果还没开始搭建可以参考<a href="http://glgjing.github.io/blog/2014/12/06/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(%5B%3F%5D-):ji-chu-huan-jing-da-jian/">利用Octopress和Github搭建个人博客（一）：基础环境搭建</a>。在搭建好基础环境之后，如果单纯的写写博文，默认主题也是可以满足需求的。但既然选择了用Octopress和Github Pages来管理自己的博客，不折腾折腾都对不起自己。不要求效果有多炫，但要方便浏览查找。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<!-- more --></p>

<h2>目录</h2>


<ul>
    <li>一 Octopress目录结构介绍</li>
    <li>二 安装第三方主题</li>
    <li>三 主题样式修改</li>
    <li>四 总结</li>
</ul>


<h2>一 Octopress目录结构介绍</h2>


<p>在更改主题之前有必要了解一下Octopress目录下的文件结构，后续所有的修改都在这个目录下进行的。Octopress的目录文件如下：
<img class="center" src="http://glgjing.github.io/images/1-3.png">
初始的Octopress目录下是没有source、sass、public、_deploy这几个文件夹的，运行<code>rake install[&lsquo;theme_name&rsquo;]</code>命令后会生成这几个文件夹。</p>

<ul>
    <li>_config.yml: 站点的配置文件，也是后续需要修改最多的文件。</li>
    <li>source: 该目录是执行<code>rake install['theme_name']</code>后从.themes\theme_name目录中的source拷贝而来(theme_name是你选择的主题名)，并且添加了一个_posts目录了，当执行了rake new_post[&#8221;title&#8221;]后会在_post生成博文的markdown文件。包括后面的很多设置页是在该目录中进行；</li>
    <li>sass：也是在执行<code>rake install['theme_name']</code>后从.themes\theme_name目录中的sass拷贝而来。关于sass可以参考<a href="http://sass-lang.com/guide">这里</a></li>
    <li>public: 当执行了<code>rake generate</code>命令后会编译source目录下的内容然后将编译后的内容复制到public目录中。</li>
  <li>_deploy: 在执行<code>rake deploy</code>命令后，会将public的内容拷贝到_deploy目录下然后提交到Github的master分支上，我们最终看到的网站内容就是master分支下的内容。所以public和_deploy中的内容都是自动生成的，不要手动修改，否则在运行<code>rake generate</code>和<code>rake deploy</code>命令后所有的更改都会被覆盖掉。</li>
</ul>


<h2>二 安装第三方主题</h2>


<p>在做任何主题相关的修改之前，最好选定一款自己喜欢的主题，否则后续再更换主题，会覆盖之前的修改。Github上有很多第三方的主题，可以到<a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes">这里</a>下载。运行类似如下命令进行主题安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd octopress
</span><span class='line'>git clone git://github.com/macjasp/cleanpress.git .themes/cleanpress
</span><span class='line'>rake install['cleanpress']
</span><span class='line'>rake generate</span></code></pre></td></tr></table></div></figure>


<h2>三 主题样式修改</h2>


<h3>1 基本配置修改</h3>


<p>在选定好主题之后就可以进行自定义修改了。首先更改基本配置，Octopress的基本配置存在_config.yml文件里，具体内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>url: http://glgjing.github.io  # 网站的url
</span><span class='line'>title: GLGJing's Blog          # 网站的标题
</span><span class='line'>author: GLGJing                # 网站作者，会显示在底部等位置
</span><span class='line'>simple_search: https://www.google.com/search #搜索引擎
</span><span class='line'>description:                   # 网站描述</span></code></pre></td></tr></table></div></figure>


<p>此处列出了主要的博客配置信息，有些配置项大概看名字就知道功能了，例如网站title，email等；有些配置项比较复杂，后面单独介绍，如添加评论插件、侧边栏等。</p>

<h3>2 设置标题栏: Header</h3>


<p>Octopress的很多自定义配置是存储在/source/_includes/custom/目录下的，如果想要更改标题栏，可以修改该文件夹下的header.html文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;hgroup&gt;</span>
</span><span class='line'>  <span class="nt">&lt;h1&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;/&quot;</span><span class="nt">&gt;</span>GLGJing&#39;s Blog<span class="nt">&lt;/a&gt;&lt;/h1&gt;</span>
</span><span class='line'>  {% if site.subtitle %}
</span><span class='line'>    <span class="nt">&lt;h2&gt;</span>{{ site.subtitle }}<span class="nt">&lt;/h2&gt;</span>
</span><span class='line'>  {% endif %}
</span><span class='line'><span class="nt">&lt;/hgroup&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中的title和subtitle可以直接在_config.yml中修改。</p>

<h3>3 设置导航栏: Navigation</h3>


<p>Navigation的配置方法和Header类似，直接修改/source/_includes/custom/navigation.html文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;main-navigation&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;/&quot;</span><span class="nt">&gt;</span>主页<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>
</span><span class='line'>  <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;/blog/archives&quot;</span><span class="nt">&gt;</span>文章<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>
</span><span class='line'>  <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;/about&quot;</span><span class="nt">&gt;</span>关于<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果想添加新的页面，可以运行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_page['page_name']</span></code></pre></td></tr></table></div></figure>


<p>该命令会建立source/page_name/index.html文件，然后编辑此文件，添加自己想要展示的内容即可，再在navigation.html里添加正确的路径即可,如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;/page_name&quot;</span><span class="nt">&gt;</span>新标签页<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4 设置尾栏: Footer</h3>


<p>修改/source/_includes/custom/footer.html文件来设置尾栏。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;p&gt;</span>
</span><span class='line'>  Copyright <span class="ni">&amp;copy;</span> 2015 - GLGJing -
</span><span class='line'>  <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&quot;credit&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    Powered by<span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://octopress.org&quot;</span><span class="nt">&gt;</span>Octopress<span class="nt">&lt;/a&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/span&gt;</span>
</span><span class='line'><span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以将不需要的信息去掉，添加自己想要的信息如：流量统计工具，个人声明等。</p>

<h3>5 设置背景图和LOGO</h3>


<p>想要更改背景图片，可以在sass/custom/_styles.scss中添加如下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>html {
</span><span class='line'>  background: #555555 url(&quot;/images/bg3.jpg&quot;);
</span><span class='line'>}
</span><span class='line'>body &gt; div {
</span><span class='line'>  background-image: none;
</span><span class='line'>}
</span><span class='line'>body &gt; div &gt; div {
</span><span class='line'>  background-image: none;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>更改LOGO图片可以直接替换/source目录下的favicon.png, 或者将LOGO图片放入source/images中，然后修改source/_includes/head.html，找到favicon.png，修改其路径指向你的图片即可。</p>

<h2>四 总结</h2>


<p>这里介绍了Octopress主题配置的几个主要部分，其他更细节配置如：字体的配置优化、侧边栏的定制、评论插件的配置等，会在后续的博文中更新。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Octopress和Github搭建个人博客（一）：基础环境搭建]]></title>
    <link href="http://glgjing.github.io/blog/2014/12/06/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(%5B%3F%5D-):ji-chu-huan-jing-da-jian/"/>
    <updated>2014-12-06T15:30:04+08:00</updated>
    <id>http://glgjing.github.io/blog/2014/12/06/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-([?]-):ji-chu-huan-jing-da-jian</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://glgjing.github.io/images/1-1.png"></p>

<h2>引言</h2>


<p>如果你只想安安静静的写博客而不被各种博客网站的条条框框限制，如果你想自建博客网站而又不想买域名租服务器等繁琐流程，如果你恰好懂些shell command和git，那么Octopress + Gitbub搭建个人博客是个不错的选择。<a href="http://octopress.org/">Octopress</a>是一个基于<a href="https://github.com/jekyll/jekyll"><code>Jekyll</code></a>博客引擎开发的博客框架，可以很方便的生成静态页面用于在<a href="https://pages.github.com/">Github Pages</a>上展现。官方说法：<code>A blogging framework for hackers</code>。
本文主要介绍在mac下如何利用Octopress和Github搭建个人博客的基础环境。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<!-- more --></p>

<h2>目录</h2>


<ul>
  <li>一 安装基本环境</li>
  <li>二 通过Octopress将博客部署到Github</li>
  <li>三 发布个人博客</li>
  <li>四 其他配置</li>
</ul>


<h2>一 安装基本环境</h2>


<h3>1 安装Ruby</h3>


<p>Octopress运行需要Ruby环境，所以首先需要安装Ruby（<a href=“https://ruby-china.org/wiki/install_ruby_guide”>详细教程</a>）。
首先安装RVM，RVM是用来安装和管理Ruby环境的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -L https://get.rvm.io | bash -s stable</span></code></pre></td></tr></table></div></figure>


<p>然后，载入 RVM 环境，如果新开 Terminal 就不用这么做了，会自动重新载入的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source ~/.rvm/scripts/rvm</span></code></pre></td></tr></table></div></figure>


<p>检查一下是否安装正确</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rvm -v
</span><span class='line'>rvm 1.22.17 (stable) by Wayne E. Seguin &lt;wayneeseguin@gmail.com>, Michal Papis &lt;mpapis@gmail.com> [https://rvm.io/]</span></code></pre></td></tr></table></div></figure>


<p>通过RVM安装Ruby，后面参数为版本号，可以根据版本进行调整。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rvm install 2.0.0</span></code></pre></td></tr></table></div></figure>


<p>完成以后，Ruby就安装好了。RVM 装好以后，需要执行下面的命令将指定版本的 Ruby 设置为系统默认版本。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rvm 2.0.0 --default</span></code></pre></td></tr></table></div></figure>


<p>测试是否设置正确</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ruby -v
</span><span class='line'>ruby 2.0.0p247 (2013-06-27 revision 41674) [x86_64-darwin13.0.0]</span></code></pre></td></tr></table></div></figure>




<h3>2 安装Octopress</h3>


<p>安装Octopress，需要git。所以先确保你的电脑里已经安装了git，在终端输入<code>git —version</code>，如果看到版本号类似<code>git version x.x.x.x&hellip;</code>，证明git环境已经OK，否则请先<a href="http://git-scm.com/">安装git</a>。
git安装完成之后，就可以把Octopress从Github上clone到本地。切换到你想存储Octopress的目录运行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git://github.com/imathis/octopress.git octopress</span></code></pre></td></tr></table></div></figure>


<p>接下来安装依赖项：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd octopuses
</span><span class='line'>gem install bundler
</span><span class='line'>rbenv rehash # If you use rbenv, rehash to be able to run the bundle command
</span><span class='line'>bundle install</span></code></pre></td></tr></table></div></figure>


<p>然后安装默认主题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>




<h2>二 通过Octopress将博客部署到Github</h2>


<p>首先需要在Github上建立一个仓库，Github号称是程序员的Facebook，如果还没有Github账号那就赶紧注册一个吧，仓库名称格式为：<code>username.github.io</code>。该名称就是博客以后的访问地址：<code><a href="http://username.github.io">http://username.github.io</a></code>。仓库创建完成后，需要运行下面命令来将该仓库和Octopress关联起来：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages</span></code></pre></td></tr></table></div></figure>


<p>运行该命令期间会要求你输入仓库url，按照提示格式进行输入即可。该命令的具体功能详细参考<a href="http://octopress.org/docs/deploying/github/"><code>Deploying to Github Pages</code></a>。主要就是设置Github仓库的URL，在本地创建_deploy，该目录存储的就是后续要部署到Github Pages的文件。详细内容会在后面的Octopress目录结构介绍博文中说明。
接下来就可以将博客相关文件部署到Github Pages上了，运行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate
</span><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<p>上述命令主要是根据<code>source</code>目录下的文件，生成博客文件到<code>public</code>目录下，然后将<code>public</code>目录下的文件拷贝到<code>deploy</code>目录，并将<code>deploy</code>目录下的文件commit和push到Github上的<code>username.github.io</code>仓库里的<code>master</code>分支，执行完上述操作就可以访问<code><a href="http://username.github.io">http://username.github.io</a></code>了。有时会需要过几分钟才能打开，是正常现象。
到此为止我们就完成了，博客的基本部署，但一般习惯性的我们会把生成博客文件的原始文件提交到另外一个<code>source</code>分之上，执行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m 'Initial source commit'
</span><span class='line'>git push origin source</span></code></pre></td></tr></table></div></figure>




<h2>三 发布个人博客</h2>


<p>想要新建一个博文，运行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post[“title"]</span></code></pre></td></tr></table></div></figure>


<p>其中title为博客名，该命令会在<code>source/_posts/</code>目录下创建一个名称类似<code>2014-12-5-title.markdown</code>的文件，当然你也可以不用上述命令，手动在该目录下添加该文件，命名需要遵守<code>year-month-day-title.markdown</code>的规则。这个文件就是后续我们写博客的地方，通过<code>rake new_post</code>命令生成的文件会默认带如下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>---
</span><span class='line'>layout: post
</span><span class='line'>title: “title"
</span><span class='line'>date: 2013-08-03 16:36
</span><span class='line'>comments: true
</span><span class='line'>categories:
</span><span class='line'>---</span></code></pre></td></tr></table></div></figure>


<p>到目前为止我们就可以在这里写自己的博客了。博客完成之后，通过如下步骤部署到Github上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate
</span><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<p>在部署到Github之前可以运行如下命令，在浏览器中输入<code><a href="http://localhost:4000/">http://localhost:4000/</a></code> 进行本地预览：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake preview</span></code></pre></td></tr></table></div></figure>


<p>总结一下发布博文的完成流程：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post[’title’]     # 新建博文文件
</span><span class='line'>rake generate              # 将编辑好的博文生成网页
</span><span class='line'>rake preview               # 提交前可以进行本地预览
</span><span class='line'>rake deploy                # 将博文部署到Github上
</span><span class='line'>git commit -a              # 提交本地更改的文件
</span><span class='line'>git push origin source     # 将源文件push到Github的source分支</span></code></pre></td></tr></table></div></figure>


<h2>四 其他配置</h2>


<p>更多的<code>Octopress</code>配置如：侧边栏定制，添加评论插件，字体高亮等等，会在后续博文中<code>持续更新</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows 文件关联浅析]]></title>
    <link href="http://glgjing.github.io/blog/2014/11/29/windows-wen-jian-guan-lian-qian-xi/"/>
    <updated>2014-11-29T23:43:14+08:00</updated>
    <id>http://glgjing.github.io/blog/2014/11/29/windows-wen-jian-guan-lian-qian-xi</id>
    <content type="html"><![CDATA[<h2>引言</h2>


<p>所谓的文件关联就是指系统把指定扩展名的文件自动关联到相应的应用程序，例如.doc默认打开方式是Microsoft Word，当用户双击时就会启动Word打开该文件。windows平台下的文件默认打开方式一直是各大互联网公司的必争之地，如：各种播放器抢媒体文件的默认打开方式，说白了就是为了争入口你抢我的我抢你的，写这篇文章并不是想比谁更流氓，只是简单的总结下windows下的文件关联方式。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<!-- more --></p>

<h2>一 文件关联相关的注册表</h2>


<p>Windows用注册表来保存当前系统的所有文件关联设置，如果想更改文件关联设置，就要在注册表上做文章。首先简单介绍下注册表的各个目录(<a href="http://msdn.microsoft.com/zh-cn/library/cc776231%28v=ws.10%29.aspx">引用自msdn</a>)。</p>

<ul>
    <li><code>HKEY_LOCAL_MACHINE</code>：包含关于本地计算机系统的信息，包括硬件和操作系统数据，如总线类型、系统内存、设备驱动程序和启动控制数据。</li>
    <li><code>HKEY_CURRENT_USER</code>：包含当前以交互方式（与远程方式相反）登录的用户的用户配置文件，包括环境变量、桌面设置、网络连接、打印机和程序首选项。该子树是 HKEY_USERS 子树的别名，它指向 HKEY_USERS\当前用户的安全 ID。</li>
    <li><code>HKEY_CLASSES_ROOT</code>：包含用于各种 OLE 技术和文件类关联数据的信息。如果HKEY_LOCAL_MACHINE\SOFTWARE\Classes 或HKEY_CURRENT_USER\SOFTWARE\Classes 中存在相应的项或值，则在 HKEY_CLASSES_ROOT中会存在某个特定的项或值。如果两处均存在项或值，则 HKEY_CURRENT_USER 版本将是出现在HKEY_CLASSES_ROOT 中的那一个。</li>
    <li><code>HKEY_USERS</code>：包含关于动态加载的用户配置文件和默认配置文件的信息。它包含同时出现在 HKEY_CURRENT_USER中的信息。正在远程访问服务器的用户在服务器上的该项下没有配置文件；他们的配置文件将加载到自己计算机的注册表中。</li>
    <li><code>HKEY_CURRENT_CONFIG</code>：包含在启动时由本地计算机系统使用的硬件配置文件的相关信息。该信息用于配置一些设置，如要加载的设备驱动程序、显示时要使用的分辨率。该子树属于 HKEY_LOCAL_MACHINE 子树，它指向HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Hardware Profiles\Current。</li>
</ul>


<p>与文件关联相关的注册表项主要有以下几项：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HKEY_CURRENT_USER\Software\Classe
</span><span class='line'>HKEY_LOCAL_MACHINE\Software\Classe
</span><span class='line'>HKEY_CLASS_ROOT
</span><span class='line'>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\</span></code></pre></td></tr></table></div></figure>


<p>以下<code>HKEY_LOCAL_MACHINE</code>简称为<code>HKLM</code>，<code>HKEY_CURRENT_USER</code>简称为<code>HKCU</code>，<code>HKEY_CLASSES_ROOT</code>简称为<code>HKCR</code>。
其中<code>HKCU</code>保存了当前用户的文件关联设置，<code>HKLM</code>保存了本机上所有用户的设置，<code>HKCR</code>是上面两个位置下的键值合并，是为了访问方便而建立的视图，<code>&hellip;\FileExts\</code>保存了右键选择“打开方式”改变默认的关联程序。</p>

<h2>二 各项注册表的关联优先级及权限</h2>


<h3>1 关联优先级</h3>


<p><code>&hellip;\FileExts\</code>高于<code>HKCU</code>高于<code>HKLM</code>。（由于<code>HKCR</code>只是为了访问方便而建立的视图，最好只用于读取，若要更改则可以更改<code>HKCU</code>和<code>HKLM</code>下对应的内容即可）</p>

<h3>2 修改权限</h3>


<p>vista以上的windows版本在开启UAC的情况下，更改<code>HKLM</code>本机设置需要管理员权限（提权），更改<code>HKCU</code>当前用户设置不需要提权。</p>

<h3>3 用户双击文件时查找顺序</h3>


<p>首先检查<code>&hellip;\FileExts\</code>，找不到时查找<code>HKCU</code>，最后才是<code>HKLM</code>。因此检查一个文件是否与某个程序关联可以按照这个顺序检查。</p>

<h2>三 如何关联文件</h2>


<p>以apk文件为例，需要在上面所说几个位置下有 .apk 注册表项，该项的默认值对应ProgId，例如命名为ApkFile）。在.apk的相同层级下写入ApkFile注册表项，包含subkey：DefaultIcon和shell\open\command。其中DefaultIcon子项的值为显示的图标，shell\open\command的值为关联的程序。整体结构如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HKEY_CURRENT_USER\Software\Classes
</span><span class='line'>  .apk
</span><span class='line'>      (Default) = ApkFile
</span><span class='line'>  ApkFile
</span><span class='line'>      DefaultIcon
</span><span class='line'>          (Default) = xxx
</span><span class='line'>  shell
</span><span class='line'>      open
</span><span class='line'>          command
</span><span class='line'>              (Default) = xxx.exe %1</span></code></pre></td></tr></table></div></figure>


<p>在更改了文件关联以后，需要调用<code>SHChangeNotify</code>参数为<code>SHCNE_ASSOCCHANGED</code>通知Windows文件关联设置已经改变，否则要下次登录才能看到变化。</p>

<h2>总结</h2>


<p>文件关联实际上就是更改相应的注册表项，更改<code>HKLM</code>下的注册表项对计算机上所有用户都会有影响，但在开启UAC的计算机上需要提权，而且优先级不如<code>HKCU</code>只对当前用户起作用，且不需要提权，而且优先级高于<code>HKLM</code>，所以一般的桌面软件建议更改这一项，至于以什么方式更改（常驻进程定时查询，暴力抢占等等）就看产品了。<code>&hellip;\FileExts\</code>下的UserChoice是用户选择的默认关联方式，由用户指定，不建议更改。</p>
]]></content>
  </entry>
  
</feed>
