<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[GLGJing's Blog]]></title>
  <link href="http://glgjing.github.io/atom.xml" rel="self"/>
  <link href="http://glgjing.github.io/"/>
  <updated>2015-11-14T17:53:06+08:00</updated>
  <id>http://glgjing.github.io/</id>
  <author>
    <name><![CDATA[GLGJing]]></name>
    <email><![CDATA[GLGJing@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[利用 Android Studio 阅读 Android 源码]]></title>
    <link href="http://glgjing.github.io/blog/2015/11/14/li-yong-android-studio-yue-du-android-yuan-ma/"/>
    <updated>2015-11-14T17:50:48+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/11/14/li-yong-android-studio-yue-du-android-yuan-ma</id>
    <content type="html"><![CDATA[<p>Android 源码中有一个目录 <code>development/tools/idegen</code>, 该目录下的 idegen.sh 脚本可以生成 intellij IDE 的 project 文件，当然也可用于 Android Studio, 这样就可以利用 Android Studio 来阅读 Android 源码了，具体步骤如下：</p>

<ol>
<li><strong>生成 idegen.jar</strong>: 执行 idegen.sh 脚本需要 idegen.jar 文件，生成该文件需要编译源码，如果不想编译源码，也可以下载一个编译好的 idegen.jar，附上<a href="http://glgjing.github.io/assets/idegen.jar">下载链接</a>，并将该文件 copy 到 <code>/out/host/linux-x86/framework/idegen.jar</code>。</li>
<li><strong>运行 idegen.sh</strong>: 切换到 Android 源码根目录，运行<code>development/tools/idegen/idegen.sh</code>，过几秒钟后会在根目录下生成 android.ipr 和 android.iml 两个文件。</li>
<li><strong> 导入到 Android Studio</strong>: 打开 Android studio，点击 File > Open，选择刚刚生成的 android.ipr 打开，等待加载好了就可以了。</li>
</ol>


<p>不得不说函数跳转、查找等&hellip;体验太爽了！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 开发之实时更新 App Widget]]></title>
    <link href="http://glgjing.github.io/blog/2015/11/12/android-kai-fa-zhi-shi-shi-geng-xin-app-widget/"/>
    <updated>2015-11-12T16:14:50+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/11/12/android-kai-fa-zhi-shi-shi-geng-xin-app-widget</id>
    <content type="html"><![CDATA[<p><a href="http://glgjing.github.io/blog/2015/11/05/android-kai-fa-zhi-app-widget-xiang-jie/">Android 开发之 App Widget 详解</a>中说到 updatePeriodMills 定义了 Widget 的刷新频率，但是出于节约用户电量的考虑，Android 系统默认最小更新周期是 30 分钟，也就是说：如果您的程序需要实时更新数据，设置这个更新周期是 2 秒，那么您的程序是不会每隔 2 秒就收到更新通知的，而是要等到 30 分钟以上才可以，要想实时的更新 Widget，一般可以采用 Service 和 AlarmManager 对 Widget 进行更新。</p>

<h3>利用 Service 更新 Widget</h3>

<p>在 onUpdate() 方法中启动 Service：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyWidgetProvider</span> <span class="kd">extends</span> <span class="n">AppWidgetProvider</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onUpdate</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">,</span> <span class="n">AppWidgetManager</span> <span class="n">appWidgetManager</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">appWidgetIds</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">context</span><span class="o">.</span><span class="na">startService</span><span class="o">(</span><span class="k">new</span> <span class="nf">Intent</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">WidgetService</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 Service 中对 Widget 进行更新，这里 Service 利用 AlarmManager 每隔一段时间进行自启，防止 Service 被系统 Kill 掉后无法对 Widget 进行更新，转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a>。</p>

<!-- more -->




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WidgetService</span> <span class="kd">extends</span> <span class="n">Service</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">ALARM_DURATION</span>  <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">;</span> <span class="c1">// service 自启间隔</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">UPDATE_DURATION</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">;</span>     <span class="c1">// Widget 更新间隔</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">UPDATE_MESSAGE</span>  <span class="o">=</span> <span class="mi">1000</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">private</span> <span class="n">UpdateHandler</span> <span class="n">updateHandler</span><span class="o">;</span> <span class="c1">// 更新 Widget 的 Handler</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">IBinder</span> <span class="nf">onBind</span><span class="o">(</span><span class="n">Intent</span> <span class="n">intent</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">onStartCommand</span><span class="o">(</span><span class="n">Intent</span> <span class="n">intent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">,</span> <span class="kt">int</span> <span class="n">startId</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// 每个 ALARM_DURATION 自启一次</span>
</span><span class='line'>    <span class="n">AlarmManager</span> <span class="n">manager</span> <span class="o">=</span> <span class="o">(</span><span class="n">AlarmManager</span><span class="o">)</span> <span class="n">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">ALARM_SERVICE</span><span class="o">);</span>
</span><span class='line'>    <span class="n">Intent</span> <span class="n">alarmIntent</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Intent</span><span class="o">(</span><span class="n">getBaseContext</span><span class="o">(),</span> <span class="n">WidgetService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>    <span class="n">PendingIntent</span> <span class="n">pendingIntent</span> <span class="o">=</span> <span class="n">PendingIntent</span><span class="o">.</span><span class="na">getService</span><span class="o">(</span><span class="n">getBaseContext</span><span class="o">(),</span> <span class="mi">0</span><span class="o">,</span>
</span><span class='line'>      <span class="n">alarmIntent</span><span class="o">,</span> <span class="n">PendingIntent</span><span class="o">.</span><span class="na">FLAG_UPDATE_CURRENT</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">manager</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">AlarmManager</span><span class="o">.</span><span class="na">ELAPSED_REALTIME_WAKEUP</span><span class="o">,</span>
</span><span class='line'>      <span class="n">SystemClock</span><span class="o">.</span><span class="na">elapsedRealtime</span><span class="o">()</span> <span class="o">+</span> <span class="n">ALARM_DURATION</span><span class="o">,</span> <span class="n">pendingIntent</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">START_STICKY</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Message</span> <span class="n">message</span> <span class="o">=</span> <span class="n">updateHandler</span><span class="o">.</span><span class="na">obtainMessage</span><span class="o">();</span>
</span><span class='line'>    <span class="n">message</span><span class="o">.</span><span class="na">what</span> <span class="o">=</span> <span class="n">UPDATE_MESSAGE</span><span class="o">;</span>
</span><span class='line'>    <span class="n">updateHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">UpdateHandler</span><span class="o">();</span>
</span><span class='line'>    <span class="n">updateHandler</span><span class="o">.</span><span class="na">sendMessageDelayed</span><span class="o">(</span><span class="n">message</span><span class="o">,</span> <span class="n">UPDATE_DURATION</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">updateWidget</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// 更新 Widget</span>
</span><span class='line'>    <span class="n">RemoteViews</span> <span class="n">remoteViews</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RemoteViews</span><span class="o">(</span><span class="n">getApplicationContext</span><span class="o">().</span><span class="na">getPackageName</span><span class="o">(),</span> <span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">widget</span><span class="o">);</span>
</span><span class='line'>    <span class="n">AppWidgetManager</span> <span class="n">appWidgetManager</span> <span class="o">=</span> <span class="n">AppWidgetManager</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</span><span class='line'>    <span class="n">appWidgetManager</span><span class="o">.</span><span class="na">updateAppWidget</span><span class="o">(</span><span class="k">new</span> <span class="nf">ComponentName</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">MyWidgetProvider</span><span class="o">.</span><span class="na">class</span><span class="o">),</span> <span class="n">remoteViews</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 发送下次更新的消息</span>
</span><span class='line'>    <span class="n">Message</span> <span class="n">message</span> <span class="o">=</span> <span class="n">updateHandler</span><span class="o">.</span><span class="na">obtainMessage</span><span class="o">();</span>
</span><span class='line'>    <span class="n">message</span><span class="o">.</span><span class="na">what</span> <span class="o">=</span> <span class="n">UPDATE_MESSAGE</span><span class="o">;</span>
</span><span class='line'>    <span class="n">updateHandler</span><span class="o">.</span><span class="na">sendMessageDelayed</span><span class="o">(</span><span class="n">message</span><span class="o">,</span> <span class="n">UPDATE_DURATION</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">protected</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">UpdateHandler</span> <span class="kd">extends</span> <span class="n">Handler</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">switch</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">what</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">UPDATE_MESSAGE:</span>
</span><span class='line'>          <span class="n">updateWidget</span><span class="o">();</span>
</span><span class='line'>          <span class="k">break</span><span class="o">;</span>
</span><span class='line'>        <span class="k">default</span><span class="o">:</span>
</span><span class='line'>          <span class="k">break</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Service + AlarmManager 更新 Widget</h3>

<p>上面是利用 Service 的内部消息循环更新 Widget，也可以利用 AlarmManager 来定时触发更新。在 onUpdate() 中启动 Alarm，通过 AlarmManager 来循环启动 Service，剩下的原理基本就是一样的了。记得在 onDisabled() 取消掉 Alarm。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyWidgetProvider</span> <span class="kd">extends</span> <span class="n">AppWidgetProvider</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">UPDATE_DURATION</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">;</span> <span class="c1">// Widget 更新间隔</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">private</span> <span class="n">PendingIntent</span> <span class="n">pendingIntent</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onUpdate</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">,</span> <span class="n">AppWidgetManager</span> <span class="n">appWidgetManager</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">appWidgetIds</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">AlarmManager</span> <span class="n">manager</span> <span class="o">=</span> <span class="o">(</span><span class="n">AlarmManager</span><span class="o">)</span> <span class="n">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">ALARM_SERVICE</span><span class="o">);</span>
</span><span class='line'>    <span class="n">Intent</span> <span class="n">alarmIntent</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Intent</span><span class="o">(</span><span class="n">getBaseContext</span><span class="o">(),</span> <span class="n">WidgetService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">pendingIntent</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">pendingIntent</span> <span class="o">=</span> <span class="n">PendingIntent</span><span class="o">.</span><span class="na">getService</span><span class="o">(</span><span class="n">getBaseContext</span><span class="o">(),</span> <span class="mi">0</span><span class="o">,</span>
</span><span class='line'>        <span class="n">alarmIntent</span><span class="o">,</span> <span class="n">PendingIntent</span><span class="o">.</span><span class="na">FLAG_UPDATE_CURRENT</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">manager</span><span class="o">.</span><span class="na">setRepeating</span><span class="o">(</span><span class="n">AlarmManager</span><span class="o">.</span><span class="na">ELAPSED_REALTIME_WAKEUP</span><span class="o">,</span>
</span><span class='line'>      <span class="n">SystemClock</span><span class="o">.</span><span class="na">elapsedRealtime</span><span class="o">(),</span> <span class="n">UPDATE_DURATION</span><span class="o">,</span> <span class="n">pendingIntent</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDisabled</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">AlarmManager</span> <span class="n">manager</span> <span class="o">=</span> <span class="o">(</span><span class="n">AlarmManager</span><span class="o">)</span> <span class="n">context</span><span class="o">.</span><span class="na">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">ALARM_SERVICE</span><span class="o">);</span>
</span><span class='line'>    <span class="n">manager</span><span class="o">.</span><span class="na">cancel</span><span class="o">(</span><span class="n">pendingIntent</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>MyService 源码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="kd">extends</span> <span class="n">Service</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">onStartCommand</span><span class="o">(</span><span class="n">Intent</span> <span class="n">intent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">,</span> <span class="kt">int</span> <span class="n">startId</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">buildUpdate</span><span class="o">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">onStartCommand</span><span class="o">(</span><span class="n">intent</span><span class="o">,</span> <span class="n">flags</span><span class="o">,</span> <span class="n">startId</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">buildUpdate</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">RemoteViews</span> <span class="n">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RemoteViews</span><span class="o">(</span><span class="n">getPackageName</span><span class="o">(),</span> <span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">widget</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">RemoteViews</span> <span class="n">remoteViews</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RemoteViews</span><span class="o">(</span><span class="n">getApplicationContext</span><span class="o">().</span><span class="na">getPackageName</span><span class="o">(),</span> <span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">widget</span><span class="o">);</span>
</span><span class='line'>    <span class="n">AppWidgetManager</span> <span class="n">appWidgetManager</span> <span class="o">=</span> <span class="n">AppWidgetManager</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</span><span class='line'>    <span class="n">appWidgetManager</span><span class="o">.</span><span class="na">updateAppWidget</span><span class="o">(</span><span class="k">new</span> <span class="nf">ComponentName</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">MyWidgetProvider</span><span class="o">.</span><span class="na">class</span><span class="o">),</span> <span class="n">remoteViews</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>添加自定义 View</h3>

<p>更新 Widget 是通过 RemoteViews 实现的，而 RemoteViews 支持的 View 有限，详细参考<a href="http://developer.android.com/intl/zh-cn/guide/topics/appwidgets/index.html#CreatingLayout">这里</a>，如果想要在 Widget 中使用自定义 View，可以通过一下方式实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">RemoteViews</span> <span class="n">remoteViews</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RemoteViews</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">getPackageName</span><span class="o">(),</span> <span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">widget</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">MyCustomView</span> <span class="n">customView</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">MyCustomView</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</span><span class='line'><span class="n">customView</span><span class="o">.</span><span class="na">measure</span><span class="o">(</span><span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">);</span>
</span><span class='line'><span class="n">customView</span><span class="o">.</span><span class="na">layout</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">);</span>
</span><span class='line'><span class="n">Bitmap</span> <span class="n">bitmap</span> <span class="o">=</span> <span class="n">Bitmap</span><span class="o">.</span><span class="na">createBitmap</span><span class="o">(</span><span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">,</span> <span class="n">Bitmap</span><span class="o">.</span><span class="na">Config</span><span class="o">.</span><span class="na">ARGB_8888</span><span class="o">);</span>
</span><span class='line'><span class="n">customView</span><span class="o">.</span><span class="na">draw</span><span class="o">(</span><span class="k">new</span> <span class="nf">Canvas</span><span class="o">(</span><span class="n">bitmap</span><span class="o">));</span>
</span><span class='line'><span class="n">remoteViews</span><span class="o">.</span><span class="na">setImageViewBitmap</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">bitmap</span><span class="o">,</span> <span class="n">bitmap</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上就是将自定义 View 在 Bitmap 上绘制，然后通过 ImageView 进行展现。</p>

<h3>处理点击事件</h3>

<p>RemoteViews 可以设置 setOnClickPendingIntent，通过 PendingIntent 来处理点击事件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// 设置 button 事件为启动一个 Activity</span>
</span><span class='line'><span class="n">Intent</span> <span class="n">intent1</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Intent</span><span class="o">(</span><span class="s">&quot;open_widget_activity&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">PendingIntent</span> <span class="n">pendingIntent1</span> <span class="o">=</span> <span class="n">PendingIntent</span><span class="o">.</span><span class="na">getActivity</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">intent1</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'><span class="n">remoteViews</span><span class="o">.</span><span class="na">setOnClickPendingIntent</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">button1</span><span class="o">,</span> <span class="n">pendingIntent1</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 设置 button 事件为发送一个广播</span>
</span><span class='line'><span class="n">Intent</span> <span class="n">intent2</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Intent</span><span class="o">(</span><span class="s">&quot;send_broadcast&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">PendingIntent</span> <span class="n">pendingIntent2</span> <span class="o">=</span> <span class="n">PendingIntent</span><span class="o">.</span><span class="na">getBroadcast</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">intent2</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'><span class="n">remoteViews</span><span class="o">.</span><span class="na">setOnClickPendingIntent</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">button2</span><span class="o">,</span> <span class="n">pendingIntent2</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后需要处理事件的 Activity 或者 Receiver 接受对应的 Intent 即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 开发之锁屏弹窗]]></title>
    <link href="http://glgjing.github.io/blog/2015/11/10/android-kai-fa-zhi-suo-ping-dan-chuang/"/>
    <updated>2015-11-10T20:10:24+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/11/10/android-kai-fa-zhi-suo-ping-dan-chuang</id>
    <content type="html"><![CDATA[<h2>尝试利用 WindowManager 添加浮窗的方式实现</h2>

<p>想在锁屏上面实现弹窗，第一个想法就是利用 WindowManager 设置 Window 的 Flag，通过设置 Flag 的显示优先级来让窗口显示在锁屏的上面。接下来就是试验可能相关的 Window Type 属性，验证该方案是否可行。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a></p>

<p>在尝试各个 Window Type 属性之前需要明确各个 Type 所需要的权限，下面是 com.android.internal.policy.impl.PhoneWindowManager.checkAddPermission 的源码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">int</span> <span class="nf">checkAddPermission</span><span class="o">(</span><span class="n">WindowManager</span><span class="o">.</span><span class="na">LayoutParams</span> <span class="n">attrs</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="na">type</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">WindowManager</span><span class="o">.</span><span class="na">LayoutParams</span><span class="o">.</span><span class="na">FIRST_SYSTEM_WINDOW</span>
</span><span class='line'>            <span class="o">||</span> <span class="n">type</span> <span class="o">&gt;</span> <span class="n">WindowManager</span><span class="o">.</span><span class="na">LayoutParams</span><span class="o">.</span><span class="na">LAST_SYSTEM_WINDOW</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">WindowManagerImpl</span><span class="o">.</span><span class="na">ADD_OKAY</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">permission</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="k">switch</span> <span class="o">(</span><span class="n">type</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">TYPE_TOAST:</span>
</span><span class='line'>            <span class="c1">// XXX right now the app process has complete control over</span>
</span><span class='line'>            <span class="c1">// this...  should introduce a token to let the system</span>
</span><span class='line'>            <span class="c1">// monitor/control what they are doing.</span>
</span><span class='line'>            <span class="k">break</span><span class="o">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">TYPE_INPUT_METHOD:</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">TYPE_WALLPAPER:</span>
</span><span class='line'>            <span class="c1">// The window manager will check these.</span>
</span><span class='line'>            <span class="k">break</span><span class="o">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">TYPE_PHONE:</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">TYPE_PRIORITY_PHONE:</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">TYPE_SYSTEM_ALERT:</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">TYPE_SYSTEM_ERROR:</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">TYPE_SYSTEM_OVERLAY:</span>
</span><span class='line'>            <span class="n">permission</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">Manifest</span><span class="o">.</span><span class="na">permission</span><span class="o">.</span><span class="na">SYSTEM_ALERT_WINDOW</span><span class="o">;</span>
</span><span class='line'>            <span class="k">break</span><span class="o">;</span>
</span><span class='line'>        <span class="k">default</span><span class="o">:</span>
</span><span class='line'>            <span class="n">permission</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">Manifest</span><span class="o">.</span><span class="na">permission</span><span class="o">.</span><span class="na">INTERNAL_SYSTEM_WINDOW</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">permission</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">mContext</span><span class="o">.</span><span class="na">checkCallingOrSelfPermission</span><span class="o">(</span><span class="n">permission</span><span class="o">)</span>
</span><span class='line'>                <span class="o">!=</span> <span class="n">PackageManager</span><span class="o">.</span><span class="na">PERMISSION_GRANTED</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">WindowManagerImpl</span><span class="o">.</span><span class="na">ADD_PERMISSION_DENIED</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">WindowManagerImpl</span><span class="o">.</span><span class="na">ADD_OKAY</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>明显不适合的 Type：TYPE_TOAST, TYPE_INPUT_METHOD, TYPE_WALLPAPER。</li>
<li>可能适合的 Type：TYPE_PHONE, TYPE_PRIORITY_PHONE, TYPE_SYSTEM_ALERT, TYPE_SYSTEM_ERROR, TYPE_SYSTEM_OVERLAY。</li>
<li>其它类型的 Type：需要 android.Manifest.permission.INTERNAL_SYSTEM_WINDOW 权限，而申请该权限需要系统签名，所以我们是无法获取权限的。</li>
</ul>


<!-- more -->


<p><strong>TYPE_PHONE</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Window type: phone.  These are non-application windows providing</span>
</span><span class='line'><span class="cm"> * user interaction with the phone (in particular incoming calls).</span>
</span><span class='line'><span class="cm"> * These windows are normally placed above all applications, but behind</span>
</span><span class='line'><span class="cm"> * the status bar.</span>
</span><span class='line'><span class="cm"> * In multiuser systems shows on all users&#39; windows.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TYPE_PHONE</span>              <span class="o">=</span> <span class="n">FIRST_SYSTEM_WINDOW</span><span class="o">+</span><span class="mi">2</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>TYPE_PHONE 类型的窗口可以显示在其它 APP 的上面，但不能显示在锁屏的上面，所以 PASS。</p>

<p><strong>TYPE_PRIORITY_PHONE</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Window type: priority phone UI, which needs to be displayed even if</span>
</span><span class='line'><span class="cm"> * the keyguard is active.  These windows must not take input</span>
</span><span class='line'><span class="cm"> * focus, or they will interfere with the keyguard.</span>
</span><span class='line'><span class="cm"> * In multiuser systems shows on all users&#39; windows.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TYPE_PRIORITY_PHONE</span>     <span class="o">=</span> <span class="n">FIRST_SYSTEM_WINDOW</span><span class="o">+</span><span class="mi">7</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>TYPE_PRIORITY_PHONE 类型的窗口可以显示在其它 APP 的上面，但不能显示在锁屏的上面，所以 PASS。而且实际的行为和注释并不相符，该类型的窗口是可以获取交互事件的，具体原因待查。</p>

<p><strong>TYPE_SYSTEM_ALERT</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Window type: system window, such as low power alert. These windows</span>
</span><span class='line'><span class="cm"> * are always on top of application windows.</span>
</span><span class='line'><span class="cm"> * In multiuser systems shows only on the owning user&#39;s window.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TYPE_SYSTEM_ALERT</span>       <span class="o">=</span> <span class="n">FIRST_SYSTEM_WINDOW</span><span class="o">+</span><span class="mi">3</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>TYPE_SYSTEM_ALERT 类型的窗口可以显示在其它 APP 的上面，但不能显示在锁屏的上面，所以 PASS。</p>

<p><strong>TYPE_SYSTEM_OVERLAY</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Window type: system overlay windows, which need to be displayed</span>
</span><span class='line'><span class="cm"> * on top of everything else.  These windows must not take input</span>
</span><span class='line'><span class="cm"> * focus, or they will interfere with the keyguard.</span>
</span><span class='line'><span class="cm"> * In multiuser systems shows only on the owning user&#39;s window.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TYPE_SYSTEM_OVERLAY</span>     <span class="o">=</span> <span class="n">FIRST_SYSTEM_WINDOW</span><span class="o">+</span><span class="mi">6</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>TYPE_SYSTEM_OVERLAY 类型的窗口可以显示在所有其它窗口的上面，包括锁屏，而且不会影响它下面窗口的交互事件响应，但是该属性窗口不能获得焦点，无法进行交互（如果该窗口可以获取焦点，那么就可以用来抓取用户的锁屏密码，出于安全考虑，系统是不会允许的），所以只能用来简单的展示内容，如果需要交互的锁屏弹窗，那么该属性 PASS。</p>

<p><strong>TYPE_SYSTEM_ERROR</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Window type: internal system error windows, appear on top of</span>
</span><span class='line'><span class="cm"> * everything they can.</span>
</span><span class='line'><span class="cm"> * In multiuser systems shows only on the owning user&#39;s window.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TYPE_SYSTEM_ERROR</span>       <span class="o">=</span> <span class="n">FIRST_SYSTEM_WINDOW</span><span class="o">+</span><span class="mi">10</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在原生 ROM 5.1 下试验是可以显示出来的，但根据注释来看（appear on top of everything they can）不是在所有情况下都可以显示在锁屏上面的，<font color="#B72712">而且像 MIUI 和 Flyme 等 ROM 默认是屏蔽浮窗权限的，考虑到这点，利用 WindowManager 添加浮窗的方式实现锁屏弹窗的方案基本 PASS。</font></p>

<h2>使用 Activity 的方式实现</h2>

<h4>首先需要对 Activity 进行如下设置</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">Window</span> <span class="n">win</span> <span class="o">=</span> <span class="n">getWindow</span><span class="o">();</span>
</span><span class='line'>    <span class="n">win</span><span class="o">.</span><span class="na">addFlags</span><span class="o">(</span><span class="n">WindowManager</span><span class="o">.</span><span class="na">LayoutParams</span><span class="o">.</span><span class="na">FLAG_SHOW_WHEN_LOCKED</span>
</span><span class='line'>            <span class="o">|</span> <span class="n">WindowManager</span><span class="o">.</span><span class="na">LayoutParams</span><span class="o">.</span><span class="na">FLAG_DISMISS_KEYGUARD</span>
</span><span class='line'>            <span class="o">|</span> <span class="n">WindowManager</span><span class="o">.</span><span class="na">LayoutParams</span><span class="o">.</span><span class="na">FLAG_KEEP_SCREEN_ON</span>
</span><span class='line'>            <span class="o">|</span> <span class="n">WindowManager</span><span class="o">.</span><span class="na">LayoutParams</span><span class="o">.</span><span class="na">FLAG_TURN_SCREEN_ON</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中最主要也是必须要设置的就是：FLAG_SHOW_WHEN_LOCKED，顾名思义就是锁屏下显示该 Activity。而其它几个 Flag 包括：解锁、保持屏幕常亮、点亮屏幕可以根据具体的需求选择设置。</p>

<h4>在 AndroidManifest.xml 中声明 Activity</h4>

<p>同样该 Activity 也需要在 AndroidManifest.xml 中声明，声明时需注意添加 <code>android:excludeFromRecents="true"</code> 属性，是为了将该 Activity 从最近任务列表中去除，否则用户会觉得很奇怪。还有因为这个 Activity 会整个盖在锁屏上面，而且就算设置成背景透明，锁屏界面也不会显示在下面（系统主要是出于安全考虑），所以需要考虑下该 Activity 的背景，这里为了显示不要太突兀将主题设为壁纸。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">&lt;</span><span class="n">activity</span> <span class="nl">android:</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;.LockScreenActivity&quot;</span>
</span><span class='line'>          <span class="nl">android:</span><span class="n">launchMode</span><span class="o">=</span><span class="s">&quot;singleInstance&quot;</span>
</span><span class='line'>          <span class="nl">android:</span><span class="n">excludeFromRecents</span><span class="o">=</span><span class="s">&quot;true&quot;</span>
</span><span class='line'>          <span class="nl">android:</span><span class="n">theme</span><span class="o">=</span><span class="s">&quot;@android:style/Theme.Wallpaper.NoTitleBar&quot;</span><span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>启动 Activity</h4>

<p>由于该 Activity 是为了在锁屏的情况下显示的，所以启动 Activity 时不要忘了判断手机是否处于锁屏状态，可以通过下面这种方式判断锁屏状态：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">KeyguardManager</span> <span class="n">km</span> <span class="o">=</span> <span class="o">(</span><span class="n">KeyguardManager</span><span class="o">)</span> <span class="n">context</span><span class="o">.</span><span class="na">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">KEYGUARD_SERVICE</span><span class="o">);</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">km</span><span class="o">.</span><span class="na">inKeyguardRestrictedInputMode</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// 处于锁屏状态</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 开发之 App Widget 详解]]></title>
    <link href="http://glgjing.github.io/blog/2015/11/05/android-kai-fa-zhi-app-widget-xiang-jie/"/>
    <updated>2015-11-05T13:08:53+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/11/05/android-kai-fa-zhi-app-widget-xiang-jie</id>
    <content type="html"><![CDATA[<h3>简介</h3>

<p>App Widget：应用程序窗口小部件，微型的应用程序视图，它可以被嵌入到其它应用程序中，比如桌面，并接收周期性的更新。你可以通过一个 App Widget Provider 来发布一个 Widget。可以容纳 Widget 的应用叫做 App Widget Host，详细参考<a href="http://developer.android.com/intl/zh-cn/guide/topics/appwidgets/index.html">App Widgets| Android Developers</a>，转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a>。</p>

<h3>创建一个 App Widget 的主要步骤</h3>

<ol>
<li>在 AndroidManifest 中声明 App Widget</li>
<li>在 xml 目录定义 App Widget 的初始化 xml 文件</li>
<li>实现 Widget 具体布局的 Layout xml。</li>
<li>继承 AppWidgetProvider 类，实现具体的 Widget 业务逻辑。</li>
</ol>


<h3>在 AndroidManifest 中声明 App Widget</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;receiver</span> <span class="na">android:name=</span><span class="s">&quot;.sample.MyWidgetProvider&quot;</span> <span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;intent-filter&gt;</span>
</span><span class='line'>        <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">&quot;android.appwidget.action.APPWIDGET_UPDATE&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/intent-filter&gt;</span>
</span><span class='line'>    <span class="nt">&lt;meta-data</span> <span class="na">android:name=</span><span class="s">&quot;android.appwidget.provider&quot;</span>
</span><span class='line'>               <span class="na">android:resource=</span><span class="s">&quot;@xml/appwidget_provider&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/receiver&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p><code>&lt;receiver&gt;</code>的 android:name 属性声明的就是 Widget 所用的 AppWidgetProvider 类，并且<code>&lt;intent-filter&gt;</code>中必须要包含 APPWIDGET_UPDATE 这个 <code>&lt;action&gt;</code>，所有 Widget 的 broadcast 都是通过这个 filter 来接收的。</p>

<p><code>&lt;meta-data&gt;</code> 声明了 Widget 的 AppWidgetProviderInfo 对应的资源 xml 的位置，用的是 xml 目录下的 appwidget_provider.xml。这里需要简单介绍下 AppWidgetProviderInfo 类，该类是用来描述 Widget 的 meta 信息，包括 Widget 的 xml 布局文件、刷新频率、最小宽高等等，而这些信息正是通过上述 xml 的<code>&lt;appwidget-provider&gt;</code> 标签来描述的。</p>

<h3>在 xml 目录定义 App Widget 的初始化 xml 文件</h3>

<p>前面所说的用来描述 AppWidgetProviderInfo 的 xml 定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;appwidget-provider</span>
</span><span class='line'>  <span class="na">xmlns:android=</span><span class="s">&quot;http://schemas.android.com/apk/res/android&quot;</span>
</span><span class='line'>    <span class="na">android:minWidth=</span><span class="s">&quot;200dp&quot;</span>
</span><span class='line'>    <span class="na">android:minHeight=</span><span class="s">&quot;50dp&quot;</span>
</span><span class='line'>    <span class="na">android:updatePeriodMillis=</span><span class="s">&quot;86400000&quot;</span>
</span><span class='line'>    <span class="na">android:previewImage=</span><span class="s">&quot;@drawable/app_icon&quot;</span>
</span><span class='line'>    <span class="na">android:initialLayout=</span><span class="s">&quot;@layout/widget&quot;</span>
</span><span class='line'>    <span class="na">android:configure=</span><span class="s">&quot;com.example.android.ExampleAppWidgetConfigure&quot;</span>
</span><span class='line'>    <span class="na">android:resizeMode=</span><span class="s">&quot;horizontal|vertical&quot;</span>
</span><span class='line'>    <span class="na">android:widgetCategory=</span><span class="s">&quot;home_screen|keyguard&quot;</span><span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>minWidth</strong> &amp; <strong>minHeight</strong>：定义了 Widget 的最小宽高，当 minWidth 和 minHeight 不是桌面 cell 的整数倍时，Widget 的宽高会被阔至与其最接近的 cells 大小。Google 官方给出了一个大致估算 minWidth &amp; minHeight 的公式，根据 Widget 所占的 cell 数量来计算宽高：<code>70 × n − 30</code>，n 是所占的 cell 数量。  <br/>
<strong>updatePeriodMillis</strong>：定义了 Widget 的刷新频率，也就是 App Widget Framework 多久请求一次 AppWidgetProvider 的 onUpdate() 回调函数。该时间间隔并不保证精确，出于节约用户电量的考虑，Android 系统默认最小更新周期是 30 分钟，也就是说：如果您的程序需要实时更新数据，设置这个更新周期是 2 秒，那么您的程序是不会每隔 2 秒就收到更新通知的，而是要等到 30 分钟以上才可以，要想实时的更新 Widget，一般可以采用 Service 和 AlarmManager 对 Widget 进行更新。   <br/>
<strong>previewImage</strong>：当用户选择添加 Widget 时的预览图片。如果该属性没有定义，则展示 application 的 launcher icon。<font color="#B72712">该属性是在 3.0 以后引入的。</font>    <br/>
<strong>initialLayout</strong>：Widget 的布局 Layout 文件。    <br/>
<strong>configure</strong>：定义了用户在添加 Widget 时弹出的配置页面的 Activity，用户可以在此进行 Widget 的一些配置，该 Activity 是可选的，如果不需要可以不进行声明。   <br/>
<strong>resizeMode</strong>：Widget 在水平和垂直方向是否可以调整大小，值可以为：horizontal（水平方向可以调整大小），vertical（垂直方向可以调整大小），none（不可以调整大小），也可以 horizontal|vertical 组合表示水平和垂直方向均可以调整大小。    <br/>
<strong>widgetCategory</strong>：表示 Widget 可以显示的位置，包括 home_screen（桌面），keyguard（锁屏），keyguard 属性需要 5.0 或以上 Android 版本才可以。    <br/>
其它更多详细属性可以参考 <a href="http://developer.android.com/intl/zh-cn/reference/android/appwidget/AppWidgetProviderInfo.html">AppWidgetProviderInfo</a>。</p>

<h3>继承 AppWidgetProvider 类</h3>

<p>AppWidgetProvider 继承自 BroadcastReceiver，内部逻辑非常简单，就是在 onReceive() 中处理 Widget 相关的广播事件（ACTION_APPWIDGET_UPDATE, ACTION_APPWIDGET_DELETED, ACTION_APPWIDGET_ENABLED, ACTION_APPWIDGET_DISABLED, ACTION_APPWIDGET_OPTIONS_CHANGED）分发到各个回调函数中（onUpdate(), onDeleted(), onEnabled(), onDisabled, onAppWidgetOptionsChanged()）。</p>

<p><strong>onUpdate()：</strong>是最重要的回调函数，根据 updatePeriodMillis 定义的定期刷新操作会调用该函数，此外当用户添加 Widget 时
也会调用该函数，可以在这里进行必要的初始化操作。但如果在<code>&lt;appwidget-provider&gt;</code>中声明了 android:configure 的 Activity，在用户添加 Widget 时，不会调用 onUpdate()，需要由 configure Activity 去负责去调用 AppWidgetManager.updateAppWidget() 完成 Widget 更新，后续的定时更新还是会继续调用 onUpdate() 的。    <br/>
<strong>onDeleted()：</strong>当 Widget 被删除时调用该方法。   <br/>
<strong>onEnabled()：</strong>当 Widget 第一次被添加时调用，例如用户添加了两个你的 Widget，那么只有在添加第一个 Widget 时该方法会被调用。所以该方法比较适合执行你所有 Widgets 只需进行一次的操作。   <br/>
<strong>onDisabled()：</strong>与 onEnabled 恰好相反，当你的最后一个 Widget 被删除时调用该方法，所以这里用来清理之前在 onEnabled() 中进行的操作。    <br/>
<strong>onAppWidgetOptionsChanged()：</strong>当 Widget 第一次被添加或者大小发生变化时调用该方法，可以在此控制 Widget 元素的显示和隐藏。</p>

<p>示例代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExampleAppWidgetProvider</span> <span class="kd">extends</span> <span class="n">AppWidgetProvider</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onUpdate</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">,</span> <span class="n">AppWidgetManager</span> <span class="n">appWidgetManager</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">appWidgetIds</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">final</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">appWidgetIds</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Perform this loop procedure for each App Widget that belongs to this provider</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">appWidgetId</span> <span class="o">=</span> <span class="n">appWidgetIds</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Create an Intent to launch ExampleActivity</span>
</span><span class='line'>            <span class="n">Intent</span> <span class="n">intent</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Intent</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">ExampleActivity</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>            <span class="n">PendingIntent</span> <span class="n">pendingIntent</span> <span class="o">=</span> <span class="n">PendingIntent</span><span class="o">.</span><span class="na">getActivity</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">intent</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Get the layout for the App Widget and attach an on-click listener</span>
</span><span class='line'>            <span class="c1">// to the button</span>
</span><span class='line'>            <span class="n">RemoteViews</span> <span class="n">views</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RemoteViews</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">getPackageName</span><span class="o">(),</span> <span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">appwidget_provider_layout</span><span class="o">);</span>
</span><span class='line'>            <span class="n">views</span><span class="o">.</span><span class="na">setOnClickPendingIntent</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">button</span><span class="o">,</span> <span class="n">pendingIntent</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Tell the AppWidgetManager to perform an update on the current app widget</span>
</span><span class='line'>            <span class="n">appWidgetManager</span><span class="o">.</span><span class="na">updateAppWidget</span><span class="o">(</span><span class="n">appWidgetId</span><span class="o">,</span> <span class="n">views</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>创建 App Widget Configuration Activity</h3>

<p>如果你的 Widget 需要用户配置一些选项，你可以为你的 Widget 创建 Configuration Activity，当用户添加 Widget 时会自动弹出该 Activity。Configuration Activity 和普通 Activity 一样需要在 Manifest 中声明，但是需要额外声明一个 intent-filter: APPWIDGET_CONFIGURE，例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;activity</span> <span class="na">android:name=</span><span class="s">&quot;.ExampleAppWidgetConfigure&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;intent-filter&gt;</span>
</span><span class='line'>        <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">&quot;android.appwidget.action.APPWIDGET_CONFIGURE&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/intent-filter&gt;</span>
</span><span class='line'><span class="nt">&lt;/activity&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>同时还需要在上述的 appwidget-provider 中声明：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;appwidget-provider</span> <span class="na">xmlns:android=</span><span class="s">&quot;http://schemas.android.com/apk/res/android&quot;</span>
</span><span class='line'>    <span class="err">...</span>
</span><span class='line'>    <span class="na">android:configure=</span><span class="s">&quot;com.example.android.ExampleAppWidgetConfigure&quot;</span>
</span><span class='line'>    <span class="err">...</span> <span class="nt">&gt;</span>
</span><span class='line'><span class="nt">&lt;/appwidget-provider&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>有两点需要注意的是：</p>

<ol>
<li>Activity 必须返回带 EXTRA_APPWIDGET_ID 的 result。</li>
<li>声明Configuration Activity 后 onUpdate() 在 Widget 添加时不会被调用，Activity 负责调用 AppWidgetManager.updateAppWidget() 完成 Widget 更新。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Intent</span> <span class="n">intent</span> <span class="o">=</span> <span class="n">getIntent</span><span class="o">();</span>
</span><span class='line'><span class="n">Bundle</span> <span class="n">extras</span> <span class="o">=</span> <span class="n">intent</span><span class="o">.</span><span class="na">getExtras</span><span class="o">();</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">extras</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">mAppWidgetId</span> <span class="o">=</span> <span class="n">extras</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span>
</span><span class='line'>        <span class="n">AppWidgetManager</span><span class="o">.</span><span class="na">EXTRA_APPWIDGET_ID</span><span class="o">,</span>
</span><span class='line'>        <span class="n">AppWidgetManager</span><span class="o">.</span><span class="na">INVALID_APPWIDGET_ID</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">AppWidgetManager</span> <span class="n">appWidgetManager</span> <span class="o">=</span> <span class="n">AppWidgetManager</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</span><span class='line'><span class="n">RemoteViews</span> <span class="n">views</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RemoteViews</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">getPackageName</span><span class="o">(),</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">example_appwidget</span><span class="o">);</span>
</span><span class='line'><span class="n">appWidgetManager</span><span class="o">.</span><span class="na">updateAppWidget</span><span class="o">(</span><span class="n">mAppWidgetId</span><span class="o">,</span> <span class="n">views</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">Intent</span> <span class="n">resultValue</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Intent</span><span class="o">();</span>
</span><span class='line'><span class="n">resultValue</span><span class="o">.</span><span class="na">putExtra</span><span class="o">(</span><span class="n">AppWidgetManager</span><span class="o">.</span><span class="na">EXTRA_APPWIDGET_ID</span><span class="o">,</span> <span class="n">mAppWidgetId</span><span class="o">);</span>
</span><span class='line'><span class="n">setResult</span><span class="o">(</span><span class="n">RESULT_OK</span><span class="o">,</span> <span class="n">resultValue</span><span class="o">);</span>
</span><span class='line'><span class="n">finish</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown 插入表格语法]]></title>
    <link href="http://glgjing.github.io/blog/2015/04/03/markdown-biao-ge-yu-fa/"/>
    <updated>2015-04-03T14:52:47+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/04/03/markdown-biao-ge-yu-fa</id>
    <content type="html"><![CDATA[<h2>例子：</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>| 一个普通标题 | 一个普通标题 | 一个普通标题 |
</span><span class='line'>| ------| ------ | ------ |
</span><span class='line'>| 短文本 | 中等文本 | 稍微长一点的文本 |
</span><span class='line'>| 稍微长一点的文本 | 短文本 | 中等文本 |</span></code></pre></td></tr></table></div></figure>


<table>
<thead>
<tr>
<th> 一个普通标题 </th>
<th> 一个普通标题 </th>
<th> 一个普通标题 </th>
</tr>
</thead>
<tbody>
<tr>
<td> 短文本 </td>
<td> 中等文本 </td>
<td> 稍微长一点的文本 </td>
</tr>
<tr>
<td> 稍微长一点的文本 </td>
<td> 短文本 </td>
<td> 中等文本 </td>
</tr>
</tbody>
</table>


<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>| 左对齐标题 | 右对齐标题 | 居中对齐标题 |
</span><span class='line'>| :------| ------: | :------: |
</span><span class='line'>| 短文本 | 中等文本 | 稍微长一点的文本 |
</span><span class='line'>| 稍微长一点的文本 | 短文本 | 中等文本 |</span></code></pre></td></tr></table></div></figure>


<table>
<thead>
<tr>
<th style="text-align:left;"> 左对齐标题 </th>
<th style="text-align:right;"> 右对齐标题 </th>
<th style="text-align:center;"> 居中对齐标题 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 短文本 </td>
<td style="text-align:right;"> 中等文本 </td>
<td style="text-align:center;"> 稍微长一点的文本 </td>
</tr>
<tr>
<td style="text-align:left;"> 稍微长一点的文本 </td>
<td style="text-align:right;"> 短文本 </td>
<td style="text-align:center;"> 中等文本 </td>
</tr>
</tbody>
</table>


<h2>语法说明：</h2>

<ul>
<li><code>|</code>、<code>-</code>、<code>:</code>之间的多余空格会被忽略，不影响布局。</li>
<li>默认标题栏居中对齐，内容居左对齐。</li>
<li><code>-:</code>表示内容和标题栏居右对齐，<code>:-</code>表示内容和标题栏居左对齐，<code>:-:</code>表示内容和标题栏居中对齐。</li>
<li>内容和<code>|</code>之间的多余空格会被忽略，每行第一个<code>|</code>和最后一个<code>|</code>可以省略，<code>-</code>的数量至少有一个。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：类的大小]]></title>
    <link href="http://glgjing.github.io/blog/2015/03/23/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:lei-de-da-xiao/"/>
    <updated>2015-03-23T19:21:06+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/03/23/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:lei-de-da-xiao</id>
    <content type="html"><![CDATA[<p>现在有这样一段代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Y</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">X</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Z</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">X</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">A</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Y</span><span class="p">,</span> <span class="k">public</span> <span class="n">Z</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>对 <code>class X、Y、Z、A</code> 进行 <code>sizeof</code> 运算结果是什么呢？如果你心里已经有了答案，不妨看完下面的分析再说。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a></p>

<p><code>C++</code> 初学者常有一个错误的认识，认为一个 <code>class</code> 的大小就是该 <code>class</code> 内所有 <code>non static members</code> 的大小总和。既然是错误的认识，那么实际上就不是或者不单纯是该 <code>class</code> 内所有 <code>non static members</code> 的大小总和。在 <code>c++</code> 对象模型里，一个 <code>class</code> 的大小主要受下面三个方面影响：<!--more--></p>

<h3>1 语言本身特性造成的额外负担</h3>

<p>这里的额外负担主要是受 <code>virtual</code> 特性影响，包括 <code>virtual base class</code> 和 <code>virtual function</code>。在 <code>derived class</code> 中这种额外负担反映在某种形式的指针上，可以是虚函数指针，或者指向虚基类的 <code>subject class</code> 偏移地址等。详细内容可以参考<a href="http://glgjing.github.io/blog/2015/01/03/c-plus-plus-xu-han-shu-qian-xi/">C++ 虚函数浅析</a>。</p>

<h3>2 编译器对特殊情况的优化处理</h3>

<p>例如对于 <code>empty virtual base class</code> 的特殊支持，在 <code>C++</code> 对象模型中一个空的 <code>class</code> 大小为 <code>1 byte</code>，因为编译器为了使每个 <code>object</code> 在内存中能有独一无二的地址，为空 <code>class</code> 安插了一个 <code>char</code>。如果一个空的 <code>class</code> 大小为 <code>0 byte</code>，那么像该 <code>class</code> 的数组 <code>X x[10];</code>，编译器将无法区分每个元素的地址。但是如果 <code>derived class</code> 的大小不为 <code>0</code>，就不需要 <code>base class</code> 的 <code>1 byte</code> 进行内存地址区分，那么如果编译器对这种情况进行了优化的话，就会将该 <code>1 byte</code> 去掉，如果没有还是会继续保留这个额外的 <code>1 byte</code> 空间。</p>

<p>说到编译器对特殊情况的优化，下面这段话比较恰当表述了编译器演化与<code>C++</code>对象模型的关系：</p>

<blockquote><p>编译器之间的潜在差异正说明了 <code>C++</code> 对象模型的演化。这个模型为一般情况提供了解决之道，当特殊情况渐渐被挖掘出来时，种种启发法于是被引入，提供优化的处理。如果成功，启发法于是就提升为普遍的策略，并跨越各种编译器而合并。他被视为标准（虽然他并不被规范为标准），久而久之也就成了语言的一部分。</p></blockquote>

<h3>3 边界调整（Alignment）的影响</h3>

<p>为了数据能够更有效率的在内存中存取，编译器会 <code>class</code> 的内存边界进行调整，在<code>32</code>位机器上通常 <code>alignment</code> 为 <code>4 bytes</code>，以使总线的运输效率最高。</p>

<p>经过上面的分析后，可以看出具体结果要视编译器而定。首先讨论在编译器没有对 <code>empty virtual base class</code> 进行优化的情况，那么：</p>

<ol>
<li><code>class X</code>  的大小应该是 <code>1 byte</code>，该 <code>1 byte</code> 由编译器插入。</li>
<li><code>class Y</code> 和 <code>class Z</code> 的大小相同为 <code>8</code>，包括 <code>4 byte</code> 的 虚基类指针再加上 <code>1 byte</code> 的基类 X的大小，考虑到内存对齐需要补齐 <code>3 byte</code>，所以最终结果为 <code>8 byte</code>。</li>
<li><code>class A</code> 的大小为<code>12 byte</code>，包括 <code>class Y</code> 和 <code>class Z</code> 内的两个 <code>4 byte</code> 虚基类指针共 <code>8 byte</code>，此外由于 <code>X</code> 为虚基类，所以在 <code>A</code> 内只有一个实体，所以应该再加上 <code>X</code> 的 <code>1 byte</code> 和内存对齐额外补齐的 <code>3 byte</code>，共 <code>12 byte</code>。</li>
</ol>


<p>所以最终结果为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">byte</span>
</span><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">=</span> <span class="mi">8</span> <span class="n">byte</span>
</span><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="mi">12</span> <span class="n">byte</span><span class="err">。</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果编译器对 <code>empty virtual base class</code> 进行了优化，那么 <code>class X</code> 的 <code>1 byte</code> 空间在派生类中将被拿掉，相应的由于内存对齐而引起的 <code>3 byte</code> 也被去掉了，所以最终结果应该是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">byte</span>
</span><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">=</span> <span class="mi">4</span> <span class="n">byte</span>
</span><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="mi">8</span> <span class="n">byte</span><span class="err">。</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：成员变量的初始化列表]]></title>
    <link href="http://glgjing.github.io/blog/2015/03/10/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:cheng-yuan-bian-liang-de-chu-shi-hua-lie-biao/"/>
    <updated>2015-03-10T20:21:00+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/03/10/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:cheng-yuan-bian-liang-de-chu-shi-hua-lie-biao</id>
    <content type="html"><![CDATA[<p>对<code>class members</code>的初始化操作可以放在<code>member initialization list</code>或者<code>construct</code>中进行，但两者之间是有一些区别的，无论是在效率上还是在语法上。</p>

<h2>何时应该使用 initialization list ？</h2>

<p>在语法方面来说，为了程序可以通过编译，下面几种情况必须使用 <code>initialization list</code>：</p>

<ol>
<li>当初始化一个<code>reference member</code>时</li>
<li>当初始化一个<code>const member</code>时</li>
<li>当调用一个<code>base class</code>的<code>constructor</code>，并且它拥有一组参数时</li>
<li>当调用一个<code>member object</code>的<code>constructor</code>，并且它拥有一组参数时</li>
</ol>


<p>至于为什么编译器会有如此要求，看了后面的编译器扩展内容应该就会明白了。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a><!--more--></p>

<p>下面来看一下在效率方面什么时候应该用<code>initialization list</code>。首先看下面一段代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Word</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Word</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">_name</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="k">protected</span><span class="o">:</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">_name</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">_cnt</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面这段代码没有语法错误，程序可以正确的编译执行，但是效率上却不尽人意。首先我们来看编译都干了什么，下面是经过编译器扩展后的<code>constructor</code>伪码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// C++ 伪码</span>
</span><span class='line'><span class="n">Word</span><span class="o">::</span><span class="n">Word</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 调用 _name 的默认构造函数</span>
</span><span class='line'>  <span class="n">_name</span><span class="p">.</span><span class="n">String</span><span class="o">::</span><span class="n">String</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">// 生成临时对象</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// 将临时对象 memberwise 拷贝给 _name</span>
</span><span class='line'>  <span class="n">_name</span><span class="p">.</span><span class="n">String</span><span class="o">::</span><span class="n">Operator</span><span class="o">=</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// 销毁临时对象</span>
</span><span class='line'>  <span class="n">temp</span><span class="p">.</span><span class="n">String</span><span class="o">::~</span><span class="n">String</span><span class="p">();</span>
</span><span class='line'>  <span class="n">_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过编译器扩展后的代码我们可以看到，这种方式的<code>_name</code>初始化效率很差，需要产生一个临时对象，多了一次构造、一次拷贝、一次析构的额外操作。不过通过这种初始化方式对<code>_cnt</code>并没有什么影响。所以改进后的代码应该是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Word</span><span class="o">::</span><span class="n">Word</span><span class="p">()</span> <span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>经过编译器扩展后的伪码类似这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Word</span><span class="o">::</span><span class="n">Word</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">_name</span><span class="p">.</span><span class="n">String</span><span class="o">::</span><span class="n">String</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>member initialization list 到底都做了什么？</h2>

<p>通过上面的分析，可以大概看出<code>initialization list</code>的作用，具体细节是：</p>

<blockquote><p>编译器会一一操作<code>initialization list</code>，以适当的次序在<code>constructor</code>之内安插初始化操作，并且在任何<code>explicit user code</code>之前。</p></blockquote>

<h2>member initialization list 存在的一些风险</h2>

<p>上面所说的<strong>适当次序</strong>是指<code>members</code>在<code>class</code>里的声明次序，而不是在<code>initialization list</code>的排列次序，所以例如下面这段代码就会问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Class</span> <span class="n">X</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="o">:</span> <span class="n">j</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">i</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面代码的本意是先用<code>val</code>初始化<code>j</code>在用<code>j</code>初始化<code>i</code>，但实际上<code>initialization list</code>的初始化次序是按照<code>members</code>在<code>class</code>里的声明次序，所以会先初始化<code>i</code>，然后才是<code>j</code>，而<code>j</code>一开始并未进行初始化，导致<code>i(j)</code>的结果也无法预料。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：拷贝构造函数]]></title>
    <link href="http://glgjing.github.io/blog/2015/03/06/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:kao-bei-gou-zao-han-shu/"/>
    <updated>2015-03-06T20:47:13+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/03/06/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:kao-bei-gou-zao-han-shu</id>
    <content type="html"><![CDATA[<h2>对象之间的拷贝操作</h2>

<p>发生对象之间拷贝操作的三种情况：</p>

<ol>
<li>用一个 object 对另一个 object 进行初始化操作</li>
<li>当 object 被用作函数参数时</li>
<li>当一个函数返回值为一个 object 时</li>
</ol>


<p>如果一个<code>class</code>明确定义了<code>copy constructor</code>，那么在上述几种情况中会调用该<code>copy constructor</code>，但如果一个<code>class</code>没有定义<code>copy constructor</code>呢？转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a>。<!--more--></p>

<h2>memberwise Initialization</h2>

<p><code>memberwise Initialization</code>的规则是：把每一个内建活继承来的<code>data member</code>从一个<code>object</code>拷贝到另一个<code>object</code>，但并不会拷贝<code>member class object</code>，而是以递归的方式对<code>member class object</code>施行<code>memberwise Initialization</code>。这样的操作是如何完成的呢？</p>

<blockquote><p>从概念上而言，对于一个<code>class X</code>，这个操作是被一个<code>copy constructor</code>实现出来&hellip;</p></blockquote>

<p>之所以是“从概念上”，也就是实际上并不是完全由<code>copy constructor</code>实现的。</p>

<blockquote><p>一个良好的编译器可以为大部分<code>class object</code>产生<code>bitwise copies</code>，因为他们有<code>bitewise copy semantics</code>&hellip;</p></blockquote>

<h2>bitewise copy semantics（位逐次拷贝）</h2>

<p><code>bitewise copy semantics</code>（位逐次拷贝）顾名思义就是把一个<code>object</code>的内容按位拷贝给另一个<code>object</code>。如果在<code>bitewise copy semantics</code>完全可以满足一个<code>class</code>的拷贝操作的情况下，编译器是不会合成<code>copy constructor</code>。但在有些情况下单纯的<code>bitewise copy semantics</code>不能满足拷贝操作，也就是说编译器在一个<code>class</code>不会表现出<code>bitewise copy semantics</code>时，需要合成<code>copy constructor</code>来完成拷贝操作。一个<code>class</code>不会表现出<code>bitewise copy semantics</code>的四种情况：</p>

<ol>
<li>当<code>class</code>内含有<code>member object</code>，而且后者的<code>class</code>声明里有一个<code>copy constructor</code>，不管是<code>class</code>的设计者明确声明的，还是被编译器合成的。</li>
<li>当<code>class</code>继承一个<code>base class</code>，而后者含有一个<code>copy constructor</code>(不管是明确声明的还是编译器合成的)。</li>
<li>当<code>class</code>还有<code>virtual functions</code>时。</li>
<li>当<code>class</code>派生链中有<code>virtual base classes</code>时。</li>
</ol>


<h2>编译器合成 copy constructor 做什么？</h2>

<ol>
<li>调用<code>member object</code>以及<code>base class</code>的<code>copy constructor</code>。</li>
<li>重新设定<code>virtual table</code>的指针。</li>
<li>处理<code>virtual base class subobject</code></li>
</ol>


<h2>总结</h2>

<blockquote><p><code>Default constructor</code> 和 <code>copy constructor</code> 在必要的时候才由编译器产生出来。</p></blockquote>

<p><code>copy constructor</code>的合成原则基本上和<code>default constructor</code>的合成原则一致，具体可以参考：<a href="http://glgjing.github.io/blog/2015/03/03/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:mo-ren-gou-zao-han-shu/">
深度探索C++对象模型：默认构造函数 </a>。主要原则就是：编译器只合成他需要的<code>copy constructor</code>并且只做他需要的操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：默认构造函数]]></title>
    <link href="http://glgjing.github.io/blog/2015/03/03/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:mo-ren-gou-zao-han-shu/"/>
    <updated>2015-03-03T19:36:08+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/03/03/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:mo-ren-gou-zao-han-shu</id>
    <content type="html"><![CDATA[<blockquote><p>默认构造函数在被需要的时候被编译器产生出来。</p></blockquote>

<p>这句话的关键部分是：</p>

<ol>
<li>被谁需要？</li>
<li>什么时候被需要？</li>
<li>做什么事情？</li>
</ol>


<h3>被谁需要？</h3>

<p>编译器为程序构建默认构造函数是因为编译器需要它，而不是因为程序需要它。程序需要什么应该是程序员的责任，应该由程序员提供。举个例子，例如下面这段代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Foo</span><span class="o">*</span> <span class="n">pnext</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">foo_bar</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Foo</span> <span class="n">bar</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// 程序需要 bar&#39;s members 都被初始化为 0</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">bar</span><span class="p">.</span><span class="n">val</span> <span class="o">||</span> <span class="n">bar</span><span class="p">.</span><span class="n">pnext</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// do something</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <br/>
该段程序的正确语意是希望<code>Foo</code>的默认构造函数将<code>val</code>和<code>pnext</code>初始化为 0，但此处编译器并不会为<code>Foo</code>生成默认构造函数，因为这里不满足“需要的时候“这个条件，程序需要不代表编译器需要。后面我们会了解到就算此处编译器为<code>Foo</code>生成了默认构造函数，该默认构造函数也不会对<code>val</code>和<code>pnext</code>进行初始化，具体原因请看“做什么事情？”部分。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a> <!--more--></p>

<h3>什么时候需要？</h3>

<p>上面解释了默认构造函数是被编译器需要的，那么编译器什么时候需要它呢？在下列四种情况下编译器会生成默认构造函数：</p>

<ol>
<li><code>class</code>内包含有<code>default constructor</code>的<code>member object</code>，合成<code>default constructor</code>为了调用<code>member object</code>的<code>default constructor</code>。</li>
<li><code>class</code>继承自含有<code>default constructor</code>的基类，合成<code>default constructor</code>为了调用基类的<code>default constructor</code>。</li>
<li>带有虚函数的<code>class</code>，合成<code>default constructor</code>主要为了初始化vptr（虚函数表指针）。</li>
<li><code>class</code> 有一个及以上的虚基类，合成<code>default constructor</code>主要为了初始化虚基类指针。</li>
</ol>


<p>当满足上面的条件时，编译器会对<code>constructor</code>进行扩展，扩展的规则如下：</p>

<ol>
<li>当<code>class</code>没有定义<code>constructor</code>，编译器会合成<code>default constructor</code>，并加入编译器需要的操作，可能包括调用<code>member object</code>的<code>default constructor</code>，调用基类的<code>default constructor</code>，初始化虚函数表指针及虚基类指针。</li>
<li>当<code>class</code>已经定义了一个或多个<code>constructor</code>时，编译器不会再去合成<code>constructor</code>，但会扩展所有<code>constructor</code>加入编译器需要的操作。</li>
</ol>


<h3>做什么事情？</h3>

<p>从上面的分析中可以看出，默认构造函数所做的事情用一句话可以概括：只执行编译器所需要的行为。所以说即使编译器为<code>Foo</code>生成了默认构造函数，该默认构造函数也不会对<code>val</code>和<code>pnext</code>进行初始化，因为编译器并不需要该行为，这是程序员应该做的事情。</p>

<h3>总结：</h3>

<p>编译器只合成他需要的<code>default constructor</code>并且只做他需要的操作。C++ 新手常见的两个<font color="ff0000">误解</font>：</p>

<blockquote><ol>
<li>任何<code>class</code>如果没有定义<code>default constructor</code>，就会被合成出一个来。</li>
<li>编译器合成出来的<code>default constructor</code>会明确设定<code>class</code> 内每一个<code>data member</code>的默认值。</li>
</ol>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：指针的类型]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/26/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:zhi-zhen-de-lei-xing/"/>
    <updated>2015-02-26T11:27:18+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/26/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:zhi-zhen-de-lei-xing</id>
    <content type="html"><![CDATA[<p>指针对于<code>c++</code>来说是一个非常强大和灵活的特性，他可以支持多态，可以在不同类型之间进行转换，那么指向不同类型的指针在本质上有什么区别呢？转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a>。例如一个类的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">ZooAnimal</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">ZooAnimal</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="o">~</span><span class="n">ZooAnimal</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="p">();</span>
</span><span class='line'><span class="k">protected</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">loc</span><span class="p">;</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么下面几个指针有什么不同：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">ZooAnimal</span><span class="o">*</span> <span class="n">px</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span><span class="o">*</span> <span class="n">pi</span><span class="p">;</span>
</span><span class='line'><span class="n">Array</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;*</span> <span class="n">pta</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>单纯从内存需求上来看，没有什么不同，在 32 位机器上都是 4 个字节，也就是一个机器地址大小。从存储的内容来看，也没什么不同，都是存储一个地址。真正不同的是寻址出来的内容类型不同，也就是说：</p>

<blockquote><p>&ldquo;指针类型&#8221;会教导编译器如何解释某个特定地址中的内存内容及其大小。</p></blockquote>

<p>所以说虽然一个<code>void*</code>指针可以指向一个地址，但是我们无法通过<code>void*</code>来操作该地址所存储的内容，因为编译器无法知道应该用什么方式来解释和操作该内容，这时需要进行类型转换（<code>cast</code>）来告诉编译器如何进行操作。</p>

<blockquote><p>所以，转型(<code>cast</code>)其实是一种编译器指令。大部分情况下它并不改变一个指针所含的真正地址，它只影响“被指出之内存的大小和其内容”的解释方式。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：class 与 Struct 的区别]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/18/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:claass-yu-struct-de-qu-bie/"/>
    <updated>2015-02-18T01:32:20+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/18/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:claass-yu-struct-de-qu-bie</id>
    <content type="html"><![CDATA[<p><code>class</code>和<code>struct</code>的区别到底是什么，什么时候应该用<code>struct</code>取代<code>class</code>呢？我想大多数从<code>C</code>转到<code>C++</code>的程序员都会有过这样的困惑。看了<code>Lippman</code>的《深度探索C++对象模型》对该问题的回答之后，我只想说一句：尼玛，只要跟哲学沾边的问题就注定不会有一个简单明了的答案！</p>

<p>首先引用<code>Lippman</code>的一句话：</p>

<blockquote><p>嘿，你知道吗，struct 那个关键字其实没什么用。。。“什么时候应该用 struct 取代 class ？” 答案之一是：当他让一个感觉比较好的时候。</p></blockquote>

<p>大部分<code>C++</code>程序员都知道，如果单纯从语法角度来区分<code>struct</code>和<code>class</code>的话，其实除了以下几点没有什么不同：</p>

<ol>
<li>默认继承权限不同。<code>class</code>的默认继承权限为<code>private</code>，而<code>struct</code>的默认继承权限为<code>public</code>；</li>
<li>成员的默认访问权限不同。<code>class</code>的成员默认是<code>private</code>权限，<code>struct</code>默认是<code>public</code>权限。</li>
<li><code>struct</code>不能作为模板参数，而<code>class</code>可以。</li>
</ol>


<p>那&#8217;Lippman&#8217;为什么不直说呢？偏得之乎者也的提升到精神层次，搞的读者一头雾水。<!--more-->个人觉得主要是语法上的区别只是结果，而为什么这么设计才是<code>Lippman</code>想传达的主要内容。在<code>C</code>所支持的<code>struct</code>和<code>C++</code>所支持的<code>class</code>之间有一个观念上的重要差异，而关键词本身并不提供这种差异。你可能会问如果说为了兼容<code>C</code>而提供了<code>struct</code>关键字，那干嘛还创建<code>class</code>这个关键字，都用<code>struct</code>不行吗？当然行，但是<code>Lippman</code>觉得<code>class</code>更能令人满意（其实就是他自己看着更爽），更能表达出封装和继承的哲学。</p>

<p>所以如果你还在电脑前纠结，请释怀吧！谁让人家是<code>C++</code>形象代言人呢，就是这么任性，就像当面对<code>struct</code>用在<code>template</code>参数时无法被语意分析器<code>parser</code>处理时，你只能迷茫的问为什么，而<code>Lippman</code>可以默默的把<code>parser</code>改掉。最后你可以说<code>struct</code>的保留是为了兼容<code>C</code>；也可以说<code>class</code>的引入更具哲学意义；还可以说他们的共存是为了更多程序员从<code>C</code>迁移到<code>C++</code>部落。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：三种对象模型]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/11/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-san-chong-dui-xiang-mo-xing/"/>
    <updated>2015-02-11T15:57:03+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/11/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-san-chong-dui-xiang-mo-xing</id>
    <content type="html"><![CDATA[<p>现在有一个<code>Point</code>类，声明如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Point</span><span class="p">(</span><span class="kt">float</span> <span class="n">xval</span><span class="p">);</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="o">~</span><span class="n">Point</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">float</span> <span class="n">x</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="nf">PointCount</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'> <span class="k">protected</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">float</span> <span class="n">_x</span><span class="p">;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="n">_point_count</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <br/>
这个类在机器上是通过什么模型来表示的呢？下面就介绍三种不同的实现方式。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a><!-- more --></p>

<h2>1. 简单对象模型</h2>

<p>简单对象模型名副其实，十分简单。在简单对象模型中，一个 <code>object</code>是由一系列<code>slots</code>组成，每个<code>slot</code>相当于一个指针，指向一个<code>member</code>，<code>memebers</code>按照声明的顺序与<code>slots</code>一一对应，这里的<code>members</code>包括<code>data members</code>和<code>function members</code>。如果将简单对象模型应用在<code>Point Class</code>上，结构图如下： <br/>
<img class="center" src="http://glgjing.github.io/images/1-8.png" width="400"></p>

<ul>
<li><p>优点：十分简单，降低了编译器设计的复杂度。</p></li>
<li><p>缺点：空间和时间上的效率降低。由于所有<code>member</code>都对应一个<code>slot</code>指针，所以每个<code>object</code>在空间上额外多出：<code>member's number 乘以指针大小</code>的空间。同时由于访问<code>object</code>的每个<code>member</code>都需要一次<code>slot</code>的额外索引，所以在时间的效率也会降低。</p></li>
</ul>


<h2>2. 表格驱动对象模型</h2>

<p>表格驱动对象模型将<code>member data</code>和<code>member function</code>分别映射成两个表格<code>member data table</code>和<code>function member table</code>，而<code>object</code>本身只存储指向这两个表格的指针。  其中<code>function member table</code>是由一系列的<code>slot</code>组成，每个<code>slot</code>指向一个<code>member function</code>; <code>member data table</code>则直接存储的<code>member data</code>本身。如果将表格驱动对象模型应用在<code>Point Class</code>上，结构图如下：       <br/>
<img class="center" src="http://glgjing.github.io/images/1-9.png" width="400"></p>

<ul>
<li>优点：采用两层索引机制，对<code>object</code>变化提供比较好的弹性，在<code>object</code>的<code>nonstatic data member</code>有所改变时，而应用程序代码没有改变，这时是不需要重新编译的。</li>
<li>缺点：空间和时间上的效率降低，具体原因可以参考简单对象模型的缺点分析。</li>
</ul>


<h2>3. C++ 对象模型</h2>

<p>Stroustrup 早期设计的<code>C++</code>对象模型是从简单对象模型改进而来的，并对内存空间和存取时间进行了优化。主要是将<code>nonstatic data members</code>存储在每一个<code>object</code>中，而<code>static data members</code>以及所有的<code>function members</code>被独立存储在所有<code>object</code>之外。对虚函数的支持主要通过以下几点完成的：</p>

<ul>
<li>所有包含虚函数或者继承自有虚函数基类的<code>class</code>都会有一个<code>virtual table</code>，该虚函数表存储着一堆指向该类所包含的虚函数的指针。</li>
<li>每个<code>class</code>所关联的<code>type_info object</code>也是由<code>virtual table</code>存储的，一般会存在该表格的首个<code>slot</code>，<code>type_info</code>用于支持<code>runtime type identification</code> (<code>RTTI</code>)。</li>
</ul>


<p>如果将<code>C++</code>对象模型应用在<code>Point Class</code>上，结构图如下：<br/>
<img class="center" src="http://glgjing.github.io/images/2-1.png" width="400"></p>

<ul>
<li>优点：空间和存取效率高，所有<code>static data members</code>以及所有的<code>function members</code>被独立存储在所有<code>object</code>之外，可以减少每个<code>object</code>的大小，而<code>nonstatic data members</code>存储在每一个<code>object</code>中，又提升了存取效率。</li>
<li>缺点：如果应用程序的代码未曾更改，但所用到的<code>class</code>的<code>nonstatic data members</code>有所更改，那么那些代码仍然需要全部重新编译，而前面的表格驱动模型在这方面提供了较大的弹性，因为他多提供了一层间接性，当然是付出了时间和空间上的代价。</li>
</ul>


<h2>在加上继承情况下的对象模型</h2>

<p><code>C++</code>支持单继承、多继承、虚继承，下面来看下<code>base class</code>实体在<code>derived class</code>中是如何被构建的。</p>

<p><code>简单对象模型</code>中可以通过<code>derived class object</code>中的一个<code>slot</code>来存储<code>base class subobject</code>的地址，这样就可以通过该<code>slot</code>来访问<code>base class</code>的成员。这种实现方式的主要缺点是：因为间接性的存储而导致空间和存取时间上存在额外负担；优点是：<code>derived class</code>的结构不会因为<code>base class</code>的改变而改变。</p>

<p><code>表格驱动对象模型</code>中可以利用一个类似<code>base class table</code>的表格来存储所有基类的信息。该表格中存储一系列<code>slot</code>，每个<code>slot</code>存储一个<code>base class</code>的地址。这种实现方式的缺点是：因为间接性的存储而导致空间和存取时间上存在额外负担；优点是：一是所有继承的<code>class</code>都有一致的表现形式（包含一个<code>base table</code>指针，指向基类表）与基类的大小和数目没有关系，二是<code>base class table</code>增加了子类的扩展性，当基类发生改变时，可以通过扩展、缩小或者更改<code>base class table</code>来进行调整。 <br/>
以上两种实现方式都存在一个重要的问题，就是由于间接性而导致的空间和时间上的额外负担，并且该间接性的级数会随着继承的深度而增加。</p>

<p><code>C++</code>   最初采用的继承模型并不采用任何间接性，所有基类的数据直接存储在子类当中，这样在存储结构和访问效率上是最高效的。当然也有缺点：当<code>base class members</code>有任何改变，用到此<code>base class</code>或者<code>derived class</code>的对象必须重新编译。在<code>C++ 2.0</code>引入了<code>virtual base class</code>，需要一些间接性的方式来支持该特性，一般会导入一个<code>virtual base class table</code>或者扩展已有的<code>virtual table</code>，详细会在后面博文讨论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown 语法新手指南]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/04/markdownyu-fa-xin-shou-zhi-nan/"/>
    <updated>2015-02-04T11:18:16+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/04/markdownyu-fa-xin-shou-zhi-nan</id>
    <content type="html"><![CDATA[<h2>引言</h2>

<p>Markdown 的权威介绍<a href="http://daringfireball.net/projects/markdown/syntax">Markdown Syntax</a>，中文版<a href="http://wowubuntu.com/markdown/">Markdown 语法说明</a>，本文只是把常用的一些语法总结一下，适合新手快速入门。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a><!--more--></p>

<h2>标题</h2>

<p>Markdown 支持在行首插入 1 到 6 个 <code>#</code>来表示 1 到 6 级标题，例如：</p>

<pre><code>## 这是 H2
### 这是 H3
###### 这是 H6
</code></pre>

<p><strong>显示效果：</strong></p>

<h2>这是 H2</h2>

<h3>这是 H3</h3>

<h6>这是 H6</h6>

<p>你可以选择性地「闭合」样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上<code>#</code>，而行尾的<code>#</code> 数量也不用和开头一样。</p>

<h2>段落和换行</h2>

<p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行。Markdown 对换行的处理和其他大部分的 text-to-HTML 格式不太一样，其他的格式会把每个换行自动转换为<code>&lt;br/&gt;</code>标签，而 Markdown 对换行的处理原则是：在换行处需插入两个及以上的空格再回车。例如：</p>

<pre><code>其实我想换行（一个空格 + 回车）
但是没用成功
</code></pre>

<p><strong>显示效果：</strong><br/>
其实我想换行（一个空格 + 回车）
但是没用成功</p>

<pre><code>再试一次（两个空格 + 回车）
成功换行
</code></pre>

<p><strong>显示效果：</strong><br/>
再试一次（两个空格 + 回车）<br/>
成功换行</p>

<h2>列表</h2>

<p>Markdown 支持有序列表和无序列表。无序列表使用<code>*</code>、<code>+</code>或<code>-</code>作为列表标记，且标记后面要有一个空格，例如：</p>

<pre><code>* 星号Red
* 星号Green
* 星号Blue
+ 加号Red
+ 加号Green
+ 加号Blue
- 减号Red
- 减号Green
- 减号Blue
</code></pre>

<p><strong>显示效果：</strong></p>

<ul>
<li>星号Red</li>
<li>星号Green</li>
<li>星号Blue</li>
<li>加号Red</li>
<li>加号Green</li>
<li>加号Blue</li>
<li>减号Red</li>
<li>减号Green</li>
<li>减号Blue</li>
</ul>


<p>有序列表则使用数字接着一个英文句点，而且你在列表标记上使用的数字并不会影响输出的 HTML 结果，例如：</p>

<pre><code>2. Red
1. Green
3. Blue
</code></pre>

<p><strong>显示结果：</strong></p>

<ol>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ol>


<h2>引用</h2>

<p>Markdown 的引用是在行首插入<code>&gt;</code>，例如：</p>

<pre><code>&gt;锄禾日当午，汗滴禾下土。
&gt;谁知盘中餐，粒粒皆辛苦。
</code></pre>

<p><strong>显示结果：</strong></p>

<blockquote><p>锄禾日当午，汗滴禾下土。 <br/>
谁知盘中餐，粒粒皆辛苦。</p></blockquote>

<p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上<code>&gt;</code>，例如：</p>

<pre><code>&gt;锄禾日当午，汗滴禾下土。（换行处要留有 2 个及以上空格）
谁知盘中餐，粒粒皆辛苦。
</code></pre>

<p><strong>显示结果：</strong></p>

<blockquote><p>锄禾日当午，汗滴禾下土。<br/>
谁知盘中餐，粒粒皆辛苦。</p></blockquote>

<p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的<code>&gt;</code> :</p>

<pre><code>&gt; 一级引用内容
&gt;
&gt; &gt; 二级引用内容  
&gt; 
&gt; 一级引用内容
</code></pre>

<p><strong>显示结果：</strong></p>

<blockquote><p>一级引用内容</p>

<blockquote><p>二级引用内容</p></blockquote>

<p>一级引用内容</p></blockquote>

<p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>

<pre><code>&gt; ## 这是一个二级标题。
&gt; 
&gt; 1. 这是第一行列表项。
&gt; 2. 这是第二行列表项。
&gt; 
&gt; 下面是一个代码块：
&gt; 
&gt;     return "Hello Markdown！";
</code></pre>

<p><strong>显示结果：</strong></p>

<blockquote><h2>这是一个二级标题。</h2>

<ol>
<li>这是第一行列表项。</li>
<li>这是第二行列表项。</li>
</ol>


<p>下面是一个代码块：</p>

<pre><code>return "Hello Markdown！";
</code></pre></blockquote>

<h2>链接</h2>

<p>Markdown 的链接格式为：<code>[展现的内容](链接的地址)</code>。要建立一个链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>

<pre><code>我的博客地址 [GLGJing's Blog](http://glgjing.github.io "鼠标 hover 上去会显示该内容")
</code></pre>

<p><strong>显示结果：</strong><br/>
我的博客地址 <a href="http://glgjing.github.io" title="鼠标 hover 上去会显示该内容">GLGJing&rsquo;s Blog</a></p>

<p>如果想要链接到本机的资源，可以使用相对路径：</p>

<pre><code>博客的关于页 [about](/about/)
</code></pre>

<p><strong>显示结果：</strong><br/>
博客的关于页 <a href="http://glgjing.github.io/about/">about</a></p>

<p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>

<pre><code>网址：&lt;http://glgjing.github.io&gt;  
邮箱：&lt;GLGJing@gmail.com&gt;
</code></pre>

<p><strong>显示结果：</strong><br/>
 网址：<a href="http://glgjing.github.io">http://glgjing.github.io</a><br/>
 邮箱：<a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#71;&#76;&#x47;&#74;&#x69;&#110;&#x67;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;">&#x47;&#76;&#x47;&#x4a;&#x69;&#x6e;&#103;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;</a></p>

<h2>强调</h2>

<p>Markdown 使用星号<code>*</code>和底线<code>_</code>作为标记强调字词的符号，被一个<code>*</code>或<code>_</code>包围的字词会被转成用<code>&lt;em&gt;</code>标签包围，被两个<code>*</code>或<code>_</code>包起来的话，则会被转成<code>&lt;strong&gt;</code>，但是如果你的<code>*</code>或<code>_</code>两边都有空白的话，它们就只会被当成普通的符号，例如：</p>

<pre><code>*我要强调一下*
_我要再强调一下_
**我要重点强调一下**
__我要重点再强调一下__
* 此强调没用 * 
</code></pre>

<p><strong>显示结果：</strong><br/>
<em>我要强调一下</em><br/>
<em>我要再强调一下</em><br/>
<strong>我要重点强调一下</strong><br/>
<strong>我要重点再强调一下</strong><br/>
* 此强调没用 *</p>

<h2>代码块</h2>

<p>如果要标记一小段行内代码，你可以用反引号<code>`</code>把它包起来，例如：</p>

<pre><code>这里的`Func()`是一个函数
</code></pre>

<p><strong>显示结果：</strong><br/>
这里的<code>Func()</code>是一个函数</p>

<p>要在 Markdown 中建立代码区块也很简单，只要缩进 4 个空格或是 1 个制表符就可以，但要注意代码段和普通段落之间要留有一个及以上的空行，例如，下面的输入：</p>

<pre><code>这是一个普通段落：（注意此处留有 2 个以上空格和换行）

    这是一个代码区块。
</code></pre>

<p><strong>显示结果：</strong><br/>
这是一个普通段落：（注意此处留有 2 个以上空格和换行）</p>

<pre><code>这是一个代码区块。
</code></pre>

<h2>图片</h2>

<p>Markdown 使用一种和链接很相似的语法来标记图片，具体格式为<code>![]()</code>，其中一个惊叹号<code>!</code>接着一个方括号<code>[]</code>，里面放上图片的替代文字
接着一个普通括号<code>()</code>，里面放上图片的网址，最后还可以用引号包住并加上选择性的 &lsquo;title&rsquo; 文字，例如：</p>

<pre><code>![示例图片](/images/my_photo.png)
</code></pre>

<p><strong>显示结果：</strong><br/>
<img src="http://glgjing.github.io/images/my_photo.png" alt="示例图片" /><br/>
到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的<code>&lt;img&gt;</code>标签。</p>

<h2>反斜杠转义</h2>

<p>介绍完前面各种标记格式，相信有人心里会有疑问：如果我想在正文显示上面的标记该怎么办，例如我就想显示 *Hello Markdown* ,但被显示成 <em>Hello Markdown</em>，<code>*</code>被当成了重点标记。Markdown 是支持反斜杠转义的，可被转义的字符包括：</p>

<pre><code>\   反斜线
`   反引号
*   星号
_   底线
{}  花括号
[]  方括号
()  括弧
#   井字号
+   加号
-   减号
.   英文句点
!   惊叹号
</code></pre>

<p>所以上面那种情况，你就可以输入<code>\*Hello Markdown\*</code>，就会被显示为：*Hello Markdown*。</p>

<h2>Markdown 免费编辑器</h2>

<p><a href="http://wowubuntu.com/markdown/">Markdown 语法说明</a>里面有介绍各个平台的 Markdown 免费编辑器，这里就不再列出，我用的是<a href="http://25.io/mou/">Mou</a>，个人觉得还可以，比较简洁，只是偶尔会卡顿，免费的东西已经算很不错了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为 Git 添加多个公秘钥]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/02/gitru-he-tong-shi-shi-yong-duo-ge-gong-yao/"/>
    <updated>2015-02-02T16:46:55+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/02/gitru-he-tong-shi-shi-yong-duo-ge-gong-yao</id>
    <content type="html"><![CDATA[<h2>小引</h2>


<p>最近将博客从 github 上迁移到了国内的 gitcafe，主要原因是在国内的访问速度你懂的。迁移之后发现问题来了，每次连接时 SSH 客户端发送本地私钥到服务端验证，而这个私钥默认是 ~/.ssh/id_rsa 文件，如果只有一个账户，连接的服务器上保存的公钥和发送的私钥自然是配对的。但是我已经有了两个账户了，当然 username 和 email 是完全不同的，如果还是都读取默认的 ~/.ssh/id_rsa 文件，那么 gitcafe 账户的公钥和私钥显然是不匹配的。所以需要为 gitcafe 账户再添加一对公秘钥，并且可以根据账户自动寻找匹配的公秘钥。转载请注明出处<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code><!-- more --></p>

<h2>生成新的 rsa key</h2>


<p>在命令行输入如下命令，将命令中的 <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#89;&#79;&#85;&#82;&#x5f;&#69;&#x4d;&#65;&#x49;&#76;&#x40;&#89;&#x4f;&#85;&#82;&#x45;&#x4d;&#65;&#73;&#x4c;&#x2e;&#x43;&#x4f;&#77;">&#x59;&#79;&#85;&#82;&#x5f;&#69;&#77;&#65;&#x49;&#76;&#64;&#89;&#x4f;&#x55;&#82;&#69;&#x4d;&#x41;&#x49;&#76;&#46;&#x43;&#79;&#x4d;</a> 改为你的 Email 地址。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh-keygen -t rsa -C "YOUR_EMAIL@YOUREMAIL.COM" -f ~/.ssh/gitcafe_rsa</span></code></pre></td></tr></table></div></figure>


<p>生成过程中会出现以下信息，按屏幕提示操作输入 passphrase 口令，也可以直接回车设为空。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Generating public/private rsa key pair.
</span><span class='line'>Enter passphrase (empty for no passphrase):
</span><span class='line'>Enter same passphrase again:
</span><span class='line'>Your identification has been saved in /Users/username/.ssh/gitcafe_rsa.
</span><span class='line'>Your public key has been saved in /Users/username/.ssh/gitcafe_rsa.pub.
</span><span class='line'>The key fingerprint is:
</span><span class='line'>15:81:d2:7a:c6:6c:0f:ec:b0:b6:d4:18:b8:d1:41:48 YOUR_EMAIL@YOUREMAIL.COM</span></code></pre></td></tr></table></div></figure>


<p>此时在 ~/.ssh/ 目录下会生成 gitcafe_rsa 和 gitcafe_rsa.pub两个文件。</p>

<h2>配置新的 rsa key</h2>


<p>在 SSH 用户配置文件 ~/.ssh/config 中指定对应服务所使用的公秘钥名称，如果没有 config 文件的话就新建一个，并输入以下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Host gitcafe.com www.gitcafe.com
</span><span class='line'>  IdentityFile ~/.ssh/gitcafe</span></code></pre></td></tr></table></div></figure>


<p>然后将 gitcafe_rsa.pub 文件中的内容复制到 gitcafe 的 SSH 公钥中，具体参见<a href="https://gitcafe.com/GitCafe/Help/wiki/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AE%20Git">这里</a>，这样就完成了新的公秘钥配置。可以运行下面的命令进行测试</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Host gitcafe.com www.gitcafe.com
</span><span class='line'>ssh -T git@gitcafe.com</span></code></pre></td></tr></table></div></figure>


<p>如果连接成功的话，会出现以下信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Host gitcafe.com www.gitcafe.com
</span><span class='line'>Hi USERNAME! You've successfully authenticated, but GitCafe does not provide shell access.</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>


<p>这里以 gitcafe 为例讲述了如何为git添加多个公秘钥，其他的公秘钥添加方法基本类似。参考：<a href="https://gitcafe.com/GitCafe/Help/wiki/%E5%A6%82%E4%BD%95%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%85%AC%E7%A7%98%E9%92%A5">如何同时使用多个公秘钥</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Octopress和Github搭建个人博客（四）：自定义字体]]></title>
    <link href="http://glgjing.github.io/blog/2015/01/31/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(si-):zi-ding-yi-zi-ti/"/>
    <updated>2015-01-31T17:00:48+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/01/31/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(si-):zi-ding-yi-zi-ti</id>
    <content type="html"><![CDATA[<h2>修改博客字体</h2>


<p>Octopress字体的设置文件是：sass/custom/_fonts.scss，内容类似如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$sans: "Open Sans","Helvetica Neue", Arial, sans-serif !default;
</span><span class='line'>$serif: "PT Serif", Georgia, Times, "Times New Roman", serif !default;
</span><span class='line'>$mono: Menlo, Monaco, "Andale Mono", "lucida console", "Courier New", monospace !default;
</span><span class='line'>$heading-font-family: "Fjalla One", "Georgia", "Helvetica Neue", Arial, sans-serif !default;
</span><span class='line'>$header-title-font-family: $heading-font-family !default;
</span><span class='line'>$header-subtitle-font-family: $serif !default;</span></code></pre></td></tr></table></div></figure>


<ul>
    <li>$sans：定义的是无衬线正文的字体</li>
    <li>$serif：定义的是衬线正文的字体</li>
    <li>$mono：定义的是代码的字体</li>
    <li>$heading-font-family：定义的是文章标题的字体</li>
    <li>$header-title-font-family：定义的是博客标题的字体</li>
    <li>$header-subtitle-font-family：定义的是博客子标题的字体</li>
</ul>


<p>如果需要更改字体，在这里更改对应的值即可。需要注意的是在跨平台的情况下，一些字体在很多机上不一定会有，所以尽量定义一些常用字体作为备选方案。例如Adobe的开源字体Source Code Pro作为代码字体，个人感觉很不错，但很多机器上不一定有装，所以这里最好补上其他字体作为备选，Windows上比较适合的编程字体Consolas，Mac上比较适合的编程字体Monaco，以及Ubuntu上比较适合的编程字体Ubuntu Mono。浏览器在渲染字体的时候会依次进行寻找，如果本机装有Source Code Pro就用该字体进行渲染，如果没有则寻找下一个也就是Consolas，依此类推直到找到一个可用的字体进行渲染，上诉三款字体都是三个平台默认安装的，这样可以最大程度地保证代码阅读质量。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ 自增、自减操作符前缀与后缀的区别]]></title>
    <link href="http://glgjing.github.io/blog/2015/01/12/c-plus-plus-zi-zeng-(-plus-plus-)zi-jian-(-)cao-zuo-fu-qian-zhui-yu-hou-zhui-de-qu-bie/"/>
    <updated>2015-01-12T20:28:11+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/01/12/c-plus-plus-zi-zeng-(-plus-plus-)zi-jian-(-)cao-zuo-fu-qian-zhui-yu-hou-zhui-de-qu-bie</id>
    <content type="html"><![CDATA[<p>自减和自增操作符规则相同，这里就以自增为例进行说明。C++的自增<code>++</code>操作符分为前缀形式和后缀形式，在语法上前缀与后形式的主要区别在于：前缀形式有时叫做“增加然后取回”，后缀形式叫做“取回然后增加”。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="mi">0</span>
</span><span class='line'><span class="mi">1</span>
</span><span class='line'><span class="mi">1</span>
</span><span class='line'><span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>然而有一个句法上的问题，当对<code>operator ++</code>函数进行重载时，需要自增操作符的前缀和后缀形式有不同的参数。但是不论是自增或自减的前缀还是后缀都只有一个参数。为了解决这个语言问题，<code>C++</code>规定后缀形式有一个<code>int</code>类型参数,当函数被调用时,编译器传递一个<code>0</code>做为<code>int</code>参数的值给该函数，具体实现如下：<!-- more --></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">UPInt</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">UPInt</span><span class="p">()</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">UPInt</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">*</span><span class="k">this</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">const</span> <span class="n">UPInt</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UPInt</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>    <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">old</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">UPInt</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="kt">int</span> <span class="n">rValue</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">value</span> <span class="o">+=</span> <span class="n">rValue</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">int</span> <span class="n">getValue</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">protected</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">UPInt</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class='line'>  <span class="n">UPInt</span> <span class="n">a</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 调用 const UPInt operator++(int)</span>
</span><span class='line'>  <span class="n">UPInt</span> <span class="n">b</span> <span class="o">=</span> <span class="o">++</span><span class="n">tmp</span><span class="p">;</span> <span class="c1">// 调用 UPInt&amp; operator++()</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">getValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">getValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="mi">0</span>
</span><span class='line'><span class="mi">2</span>
</span></code></pre></td></tr></table></div></figure>


<p>在重载<code>++</code>和<code>&ndash;</code>操作符时最好是遵从<code>c++</code>规范，否则会写出让其他人很迷惑的代码。这里有几点需要注意的地方：</p>

<ol>
    <li>前缀形式返回值是引用很好理解，但为什么后缀返回值是<code>const</code>类型？</li>
    <li>看到后缀形式的<code>++</code>实现，是否有效率上的问题？</li>
    <li>为什么后缀形式的<code>++</code>内部没有直接实现自增功能，而是调用了前缀形式的<code>++</code>？</li>
</ol>


<h3>1 为什么后缀返回值是<code>const</code>类型？</h3>


<p>假设不是 const 对象,下面的代码就是正确的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">UPInt</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'><span class="n">i</span><span class="o">++++</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码相当于<code>i.operator++(0).operator++(0);</code>。很明显，第一个调用的 <code>operator++</code>函数返回的临时对象调用了第二个<code>operator++</code>函数。这样做的问题是：一是与内置类型行为不一致，当设计一
个类遇到问题时,一个好的准则是使该类的行为与int类型一致，而int类型不允许连续进行两次后缀自增；二是使用两次后缀<code>++</code>所产生的结果与调用者期望的不一致，第二次调用<code>operator++</code>改变的值是第一次调用返回对象的值，而不是原始对象的值。 因此如果<code>i++++;</code>是合法的，<code>i</code>将仅仅增加了一次。</p>

<h3>2 后缀形式的<code>++</code>实现，是否有效率上的问题?</h3>


<p>后缀形式的<code>++</code>函数必须建立一个临时对象以做为它的返回值，上述实现代码建立了一个临时对象(oldValue)，这个临时对象必须被构造并在最后被析构。所以如果仅为了提高代码效率，应该尽量使用前缀形式的<code>++</code>，因为它的效率较高。</p>

<h3>3 为什么后缀形式的<code>++</code>内部没有直接实现自增功能，而是调用了前缀形式的<code>++</code>？</h3>


<p>可以看出后缀与前缀形式的<code>++</code>操作符除了返回值不同外，所完成的功能是一样的。所以需要确保后缀和前缀的<code>++</code>的行为一致性，当不同的程序员去维护和升级代码时，有什么能保证它们不会产生差异？遵守上述代码里的原则，则仅仅需要维护前缀版本,因为后缀形式自动与前缀形式的行为一致。
转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 清除未跟踪文件]]></title>
    <link href="http://glgjing.github.io/blog/2015/01/09/git-qing-chu-wei-gen-zong-wen-jian/"/>
    <updated>2015-01-09T16:34:45+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/01/09/git-qing-chu-wei-gen-zong-wen-jian</id>
    <content type="html"><![CDATA[<p>在利用<code>git</code>工作时，工程目录下经常会出现一些未跟踪文件，虽然<code>git</code>支持通过<code>.gitingore</code>文件添加一些忽略文件类型和文件目录。但有时需要清理一些临时文件和自动生成的文件，手动删除显得太麻烦，这时你可以利用<code>git clean</code>命令来帮你完成这项操作。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<code>git clean</code>命令支持以下参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean [-d] [-f] [-i] [-n] [-q] [-e &lt;pattern>] [-x | -X] [--] &lt;path>...</span></code></pre></td></tr></table></div></figure>


<p>其中几个主要参数用法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-d   # 删除未跟踪目录以及目录下的文件，如果目录下包含其他git仓库文件，并不会删除（-dff可以删除）。
</span><span class='line'>-f   # 如果 git cofig 下的 clean.requireForce 为true，那么clean操作需要-f(--force)来强制执行。
</span><span class='line'>-i   # 进入交互模式
</span><span class='line'>-n   # 查看将要被删除的文件，并不实际删除文件</span></code></pre></td></tr></table></div></figure>


<p>通过以上几根参数组合，基本上可以满足删除未跟踪文件的需求了。例如在删除前先查看有哪些文件将被删除运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean -n</span></code></pre></td></tr></table></div></figure>


<p>想删除当前工作目录下的未跟踪文件，但不删除文件夹运行（如果<code>clean.requireForce</code>为<code>false</code>可以不加<code>-f</code>选项）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean -f</span></code></pre></td></tr></table></div></figure>


<p>想删除当前工作目录下的未跟踪文件以及文件夹运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean -df</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 修改提交历史]]></title>
    <link href="http://glgjing.github.io/blog/2015/01/06/git-xiu-gai-ti-jiao-li-shi/"/>
    <updated>2015-01-06T11:14:40+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/01/06/git-xiu-gai-ti-jiao-li-shi</id>
    <content type="html"><![CDATA[<h2>引言</h2>


<p>在使用git进行工作时，经常会碰到想要修改本地提交记录（还没有push到远程仓库）的情况。例如这样一个场景：你接到一个任务，这个任务可能需要一个星期的开发时间，于是你从<code>master</code>分之上运行<code>git checkout -b new_branch</code>命令，<code>checkout</code>到<code>new_branch</code>分之上进行该任务的开发，在开发的过程中向<code>new_branch</code>分之提交了多个<code>commit</code>，然后发现有些代码不是很合理，于是又更改代码提交新的<code>commit</code>，反反复复终于完成了该任务的开发，是时候提交review并合并到<code>master</code>分之上了，但是你发现提交记录非常混乱，并不利于同事review，而且你的同事也不关心你的具体修改过程，他们只想看到最终的实现，此时问题来了，如果你把所有的<code>commit</code>合并成一个大<code>commit</code>，虽然你的同事可以直接看到最终代码，但你的各个模块都混在一起提交，很难按模块单独进行review并发现问题；如果你直接提交review，你的同事就不得不把你的所有提交历史都review一遍，包括一些实际上已经在后面提交中被你修改掉的代码，脾气好的估计内心一万只草泥马奔过，脾气不好的保证不打死你！当然<code>git</code>是不可能考虑不到这种情况的，扯了这么多，下面就来看一下如何修改<code>git</code>的提交历史。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<!-- more --></p>

<h2>一 修改最近一次提交记录</h2>


<h3>1 只修改提交说明</h3>


<p>修改最近一次提交是非常常见的需求，如果只想更改最近一次的提交说明是非常方便的，只需输入如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git commit —amend</span></code></pre></td></tr></table></div></figure>


<p>然后你就会进入文本编辑器，输入你想要的内容，保存并退出即可。</p>

<h3>2 添加新的更改</h3>


<p>如果你完成提交后又想修改被提交的快照，增加或者修改其中的文件，过程基本和上面一样。先运<code>git add</code>命令，将修改的文件添加到缓存区,然后运行<code>git commit —amend</code>命令，该命令会获取你当前的暂存区的内容一并提交到最后一次<code>commit</code>。例如：新加了一个文件new_file.cpp，想要合并到最后一次提交，过程如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add new_file.cpp
</span><span class='line'>git commit —amend</span></code></pre></td></tr></table></div></figure>


<p>也可以直接运行下面的命令，不过要小心，不要提交了多余的文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git commit -a —amend</span></code></pre></td></tr></table></div></figure>


<h3>3 将文件从本次提交中移除</h3>


<p>如果想把已经<code>commit</code>的文件从这次<code>commit</code>移除的话，可以运行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git reset [—soft] HEAD~1 # —soft可加可不加，默认就是soft选项
</span><span class='line'>git checkout —filename # 要从本次提交移除的文件名
</span><span class='line'>git commit -m “new commit"</span></code></pre></td></tr></table></div></figure>


<h2>二 修改多个提交</h2>


<p>要修改历史中更早的提交，你必须采用更复杂的工具。<code>git</code>没有一个修改历史的工具，但是你可以使用<code>rebase</code>工具来衍合一系列的提交到它们原来所在的<code>HEAD</code>上。依靠这个交互式的<code>rebase</code>工具，你就可以停留在每一次提交后，如果你想修改或改变说明、增加文件或任何其他事情。你可以通过给<code>git rebase -i</code>命令以交互方式进行<code>rebase</code>。例如，你想修改最近三次的提交说明，或者其中任意一次，你必须给<code>git rebase -i</code>提供一个参数，指明你想要修改的提交的父提交。例如<code>HEAD~3</code>是指从<code>HEAD</code>指针到<code>HEAD+3</code>的位置，也就是最近第4次提交。所以想修改最近3次提交，你需要指明第3次提交的父提交（第4次提交）即<code>HEAD~3</code>。运行命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git rebase -i HEAD~3</span></code></pre></td></tr></table></div></figure>


<p>再次提醒这是一个衍合命令，也就是<code>HEAD~3</code>到<code>HEAD</code>范围内的每一次提交都会被重写，不管你是否修改提交说明<code>SHA-1</code>的值都会发生变化。<font color="red">所以千万不要涵盖你已经推送到中心服务器的提交。</font>这么做会使其他开发者产生混乱，因为你提供了同样变更的不同版本。运行该命令后进入交互界面，类似：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>
</span><span class='line'># Rebase f77f585..fecb551 onto f77f585
</span><span class='line'>#
</span><span class='line'># Commands:
</span><span class='line'>#  p, pick = use commit
</span><span class='line'>#  r, reword = use commit, but edit the commit message
</span><span class='line'>#  e, edit = use commit, but stop for amending
</span><span class='line'>#  s, squash = use commit, but meld into previous commit
</span><span class='line'>#  f, fixup = like "squash", but discard this commit's log message
</span><span class='line'>#  x, exec = run command (the rest of the line) using shell
</span><span class='line'>#
</span><span class='line'># These lines can be re-ordered; they are executed from top to bottom.
</span><span class='line'># If you remove a line here THAT COMMIT WILL BE LOST.
</span><span class='line'># However, if you remove everything, the rebase will be aborted.
</span><span class='line'># Note that empty commits are commented out</span></code></pre></td></tr></table></div></figure>


<p>根据命令提示，就可以进行历史更改了。很重要的一点是你得注意这些提交的顺序与你通常通过<code>log</code>命令看到的是相反的。如果你运行<code>log</code>，你会看到下面这样的结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick fecb551 Init the view model</span></code></pre></td></tr></table></div></figure>


<h3>1 修改指定提交</h3>


<p>例如：只修改最近第3次提交说明可以进行如下更改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reword fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>保存并退出编辑器，<code>rebase</code>命令在衍合到第3次提交时会进入提交说明编辑页面，在此进行编辑新的提交说明，保存并退出即可，<code>rebase</code>命令继续进行直至完成全部衍合操作。如果你不仅想要修改提交说明，还要更改提交，可以进行如下更改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>edit fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>保存并退出编辑器，<code>rebase</code>命令在衍合到第三次提交时会等待你提交新的更改，并提示你修改完成后运行<code>git commit &ndash;amend</code>命令，然后运行<code>git rebase &ndash;continue</code>继续进行<code>rebase</code>直至完成全部衍合。</p>

<h3>2 重排提交</h3>


<p>你也可以使用<code>git rebase -i</code>命令对提交历史彻底重排或删除提交。例如你想删除&#8221;Update the version&#8221;这个提交，并且修改其他两次提交的顺序，可以将</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>改为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>pick fecb551 Init the view model</span></code></pre></td></tr></table></div></figure>


<p>然后保存并退出编辑器，此时<code>rebase</code>命令会先应用bc5cd9d (Add new method)，然后应用 fecb551 (Init the view model)bb199a0 Update the version这次提交。
然后保存并退出编辑器，此时<code>rebase</code>命令会先应用bc5cd9d (Add new method)，然后应用 fecb551 (Init the view model)，接着停止。执行完上诉操作，你已经修改了这些提交的顺序，并且删除了bb199a0 (Update the version)这次提交。</p>

<h3>3 合并提交</h3>


<p><code>git rebase -i</code>命令还可以将一系列提交合并成一个提交。从上面的脚本提示中可以看到<code>s, squash = use commit, but meld into previous commit</code>提示。如果用<code>squash</code>修饰提交就可以进行提交之间的合并，例如可以将脚本修改成这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>squash bb199a0 Update the version
</span><span class='line'>squash bc5cd9d Add new method</span></code></pre></td></tr></table></div></figure>


<p>保存并退出编辑器，<code>rebase</code>命令会应用全部三次变更然后进入编辑器来归并三次提交说明。当你保存之后，你就拥有了一个包含前三次提交的全部变更的单一提交。</p>

<h3>4 拆分提交</h3>


<p>拆分提交实际上就是撤销一次提交，然后分多次进行重新提交。例如你想将三次提交中的中间一次拆分。将&#8221;Update the version&#8221;拆分成两次提交：&#8221;Update the version1&#8221;和&#8221;Update the version2&#8221;，可以进行如下修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>edit bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method</span></code></pre></td></tr></table></div></figure>


<p>当<code>rebase</code>到bb199a0时，会进入等待你提交新<code>commit</code>的状态，这时看可以运行<code>git reset HEAD^</code>对当前提交进行重置，然后分别运行<code>git add</code>命令添加想要提交的文件，分别进行<code>git commit</code>，最后运行<code>git rebase &ndash;continue</code>完成所有衍合。整体过程如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git reset HEAD^
</span><span class='line'>git add file1
</span><span class='line'>git commit -m 'Update the version1'
</span><span class='line'>git add file2
</span><span class='line'>git commit -m 'Update the version2'
</span><span class='line'>git rebase --continue</span></code></pre></td></tr></table></div></figure>


<p>执行完上诉操作，提交历史看起来就像这样了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1c002dd Add new method
</span><span class='line'>9b29157 Update the version2
</span><span class='line'>35cfb2b Update the version1
</span><span class='line'>f3cc40e Init the view model</span></code></pre></td></tr></table></div></figure>


<p><font color="red">再次提醒，这会修改你列表中的提交的<code>SHA</code>值，所以请确保这个列表里不包含你已经推送到共享仓库的提交。</font></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++虚函数浅析]]></title>
    <link href="http://glgjing.github.io/blog/2015/01/03/c-plus-plus-xu-han-shu-qian-xi/"/>
    <updated>2015-01-03T01:59:30+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/01/03/c-plus-plus-xu-han-shu-qian-xi</id>
    <content type="html"><![CDATA[<h2>一 引言</h2>


<p>C++面向对象语言的一大特性就是抽象，在程序设计上的体现就是鼓励面向接口编程，而不要面向具体实现编程。这里所说的抽象和接口与C++的多态性密切相关。C++的多态分为静态多态（编译时多态）和动态多态（运行时多态）两大类。静态多态通过重载、模板来实现；动态多态就是通过本文的主角虚函数来体现的。虚函数是C++语言一个非常重要的特性，不同编译器对此特性的实现机制也略有差别，虽然具体实现细节由编译器说的算，在大多情况下我们不需要关心，但虚函数在某些情况下对程序的占用内存大小和执行效率有比较明显的影响，这时候知道虚函数背后的实现原理，知其然、知其所以然是很有必要的。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<!-- more --></p>

<h2>二 虚函数实现原理</h2>


<p>虚函数的作用说白了就是：<font color="red">当调用一个虚函数时，被执行的代码必须和调用函数的对象的动态类型相一致。</font>编译器需要做的就是如何高效的实现提供这种特性。不同编译器实现细节也不相同。大多数编译器通过vtbl（virtual table）和vptr（virtual table pointer）来实现的。
当一个类声明了虚函数或者继承了虚函数，这个类就会有自己的vtbl。vtbl实际上就是一个函数指针数组，有的编译器用的是链表，不过方法都是差不多。vtbl数组中的每一个元素对应一个函数指针指向该类的一个虚函数，同时该类的每一个对象都会包含一个vptr，vptr指向该vtbl的地址。例如一个类的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func1</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Func2</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Func3</span><span class="p">();</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">Func4</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>A</code>类的对象的结构如下：
<img class="center" src="http://glgjing.github.io/images/1-5.png">
从图中可以看出<code>A</code>类对象中包含一个vptr，而vptr的值就是<code>A</code>类的vtbl的地址，vtbl中三个元素的值分别是虚函数<code>Func1</code>、<code>Func2</code>、<code>Func3</code>的地址，而非虚函数<code>Func4</code>并没有在vtbl中。</p>

<h3>1 单继承情况</h3>


<p>下面定义一个类<code>B</code>继承自类<code>A</code>，重写了(override)虚函数<code>Func1</code>，并且定义了自己的虚函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func1</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Func5</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>声明一个<code>A</code>类指针<code>A* a = new B;</code>。a的内容如下：
<img class="center" src="http://glgjing.github.io/images/1-6.png">
同样<code>a</code>的值包含一个vptr，vptr指向<code>B</code>类的vtbl，而<code>B</code>类的vtbl中元素的值相比<code>A</code>类的vtbl有一些变化，<code>B</code>类重写<code>A</code>类虚函数的地址<code>B::Func1</code>取代了<code>A::Func1</code>在vtbl的位置，<code>B</code>类新定义的虚函数<code>B::Func5</code>也被添加到vtbl中，且父类的虚函数在子类的虚函数前面。此时通过指针<code>a</code>调用<code>Func1</code>过程相当于：</p>

<ol>
  <li>通过指针<code>a</code>指向的地址，取出的具体值为类型<code>B</code>，找到里面的vptr，该vptr指向的是<code>B</code>类的vtbl</li>
  <li>通过vptr找到<code>B</code>类的vtbl地址</li>
  <li>然后通过<code>B</code>类的vtbl找到<code>Func1</code>的函数地址，调用执行，最终执行的就是<code>B::Func1</code></li>
</ol>


<p>以上过程就基本解释了C++虚函数是如何做到被执行的代码和调用函数的对象的动态类型相一致的特性了。</p>

<h3>2 多继承情况</h3>


<p>上面讨论的是单继承的情况，下面来看一下多继承情况。定义三个类<code>Base1</code><code>Base2</code><code>Base3</code>，和一个子类<code>SubClass</code>如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Base1</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">FuncB1</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Base2</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">FuncB2</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Base3</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">FuncB3</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">SubClass</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base1</span><span class="p">,</span> <span class="k">public</span> <span class="n">Base2</span><span class="p">,</span> <span class="k">public</span> <span class="n">Base3</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">FuncSub</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>SubClass</code>对象的结构如下：
<img class="center" src="http://glgjing.github.io/images/1-7.png">
可以看到<code>SubClass</code>对象包含三个vptr分别指向三个vtbl，每个vtbl对应一个父类的vtbl。当子类覆盖父类的虚函数时，对应的vtbl变化与单继承情况相同，就是子类的虚函数替换父类相应虚函数在vtbl的位置。子类新定义的虚函数，会放在第一个父类的vtbl的后面，这里的第一个是指继承类的顺序（<font color="red">其实这个并不是一定的，不同编译器有自由去选择不同的实现方式</font>）。之所以这样设计就是为了解决不同的父类类型指针在指向同一个子类实例，能够调用到各自实际的虚函数。具体的调用过程同单继承的情况相同。</p>

<h3>结论：</h3>


<ul>
  <li>每个声明了虚函数或者继承了虚函数的类，都会有一个自己的vtbl</li>
  <li>同时该类的每个对象都会包含一个vptr去指向该vtbl</li>
  <li>虚函数按照其声明顺序放于vtbl表中, vtbl数组中的每一个元素对应一个函数指针指向该类的虚函数</li>
  <li>如果子类覆盖了父类的虚函数，将被放到了虚表中原来父类虚函数的位置</li>
  <li>在多继承的情况下，每个父类都有自己的虚表。子类的成员函数被放到了第一个父类的表中</li>
</ul>


<h2>三 虚函数所需的代价</h2>


<p>上面介绍了虚函数的基本实现原理，虚函数的优点不用多说，实现了运行时多态的特性。下面来分析下虚函数所需的代价，程序运行时代价无非主要体现在时间和空间上。</p>

<h3>调用性能方面</h3>


<p>从前面虚函数的调用过程可知。当调用虚函数时过程如下（引自More Effective C++）:</p>

<ol>
  <li>通过对象的 vptr 找到类的 vtbl。这是一个简单的操作,因为编译器知道在对象内 哪里能找到 vptr(毕竟是由编译器放置的它们)。因此这个代价只是一个偏移调整(以得到 vptr)和一个指针的间接寻址(以得到 vtbl)。</li>
  <li>找到对应 vtbl 内的指向被调用函数的指针。这也是很简单的, 因为编译器为每个虚函数在 vtbl 内分配了一个唯一的索引。这步的代价只是在 vtbl 数组内 的一个偏移。</li>
  <li>调用第二步找到的的指针所指向的函数。</li>
</ol>


<p>在单继承的情况下，调用虚函数所需的代价基本上和非虚函数效率一样，在大多数计算机上它多执行了很少的一些指令，所以有很多人一概而论说虚函数性能不行是不太科学的。在多继承的情况下，由于会根据多个父类生成多个vptr，在对象里为寻找 vptr 而进行的偏移量计算会变得复杂一些，但这些并不是虚函数的性能瓶颈。
<font color="red">虚函数运行时所需的代价主要是虚函数不能是内联函。</font>这也是非常好理解的，是因为内联函数是指在编译期间用被调用的函数体本身来代替函数调用的指令，但是虚函数的“虚”是指“直到运行时才能知道要调用的是哪一个函数。”但虚函数的运行时多态特性就是要在运行时才知道具体调用哪个虚函数，所以没法在编译时进行内联函数展开。当然如果通过对象直接调用虚函数它是可以被内联，但是大多数虚函数是通过对象的指针或引用被调用的，这种调用不能被内联。 因为这种调用是标准的调用方式，所以虚函数实际上不能被内联。</p>

<h3>占用空间方面</h3>


<p>在上面的虚函数实现原理部分，可以看到为了实现运行时多态机制，编译器会给每一个包含虚函数或继承了虚函数的类自动建立一个虚函数表，<font color="red">所以虚函数的一个代价就是会增加类的体积。</font>在虚函数接口较少的类中这个代价并不明显，虚函数表vtbl的体积相当于几个函数指针的体积，如果你有大量的类或者在每个类中有大量的虚函数,你会发现 vtbl 会占用大量的地址空间。但这并不是最主要的代价，主要的代价是发生在类的继承过程中，在上面的分析中，可以看到，当子类继承父类的虚函数时，子类会有自己的vtbl，如果子类只覆盖父类的一两个虚函数接口，子类vtbl的其余部分内容会与父类重复。这在如果存在大量的子类继承，且重写父类的虚函数接口只占总数的一小部分的情况下，会造成大量地址空间浪费。在一些GUI库上这种大量子类继承自同一父类且只覆盖其中一两个虚函数的情况是经常有的，这样就导致UI库的占用内存明显变大。
<font color="red">由于虚函数指针vptr的存在，虚函数也会增加该类的每个对象的体积。</font>在单继承或没有继承的情况下，类的每个对象会多一个vptr指针的体积，也就是4个字节；在多继承的情况下，类的每个对象会多N个（N＝包含虚函数的父类个数）vptr的体积，也就是4N个字节。当一个类的对象体积较大时，这个代价不是很明显，但当一个类的对象很轻量的时候，如成员变量只有4个字节，那么再加上4（或4N）个字节的vptr，对象的体积相当于翻了1（或N）倍，这个代价是非常大的。</p>

<h2>四 总结</h2>


<p>本文主要介绍了虚函数的实现机制，以及实现该机制所付出的代价，这里没有进一步讨论继承的利与弊，但经过上面的一些讨论，也可以从侧面反映出一些问题。理解虚函数的代价是有必要的，一方面是有利于高效恰当的使用它，一方面也该意识到如果你需要这些功能, 不管采取什么样的方法你都得为此付出代价，在多数情况下,你的人工模拟可能比编译器生成的代码效率更低,稳定性更差。例如使用嵌套的<code>switch</code>语句或层叠的<code>if-then-else</code>语句模拟虚函数的调用,其产生的代码比虚函数的调用还要多,而且代码运行速度也更慢。再有你必须自己人工跟踪对象类型,这意味着对象会携带它们自己的类型标签(type tag)，因此你不会得到更小的对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++重载、重写、重定义区别]]></title>
    <link href="http://glgjing.github.io/blog/2014/12/27/c-plus-plus-zhong-zai-,-zhong-xie-,-zhong-ding-yi-qu-bie/"/>
    <updated>2014-12-27T15:32:17+08:00</updated>
    <id>http://glgjing.github.io/blog/2014/12/27/c-plus-plus-zhong-zai-,-zhong-xie-,-zhong-ding-yi-qu-bie</id>
    <content type="html"><![CDATA[<h2>一 重载（overload）</h2>


<h4>概念：</h4>


<p>函数有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数之间，互相称之为重载函数。</p>

<h4>基本条件：</h4>


<ul>
    <li>函数名必须相同；</li>
    <li>函数参数必须不相同，可以是参数类型或者参数个数不同；</li>
    <li>函数返回值可以相同，也可以不相同；</li>
</ul>


<blockquote><p><!-- more --></p></blockquote>

<h4>注意：</h4>


<ul>
    <li>只能通过不同的参数样式进行重载，例如：不同的参数类型，不同的参数个数，不同的参数顺序；</li>
    <li>不能通过访问权限、返回类型、抛出的异常进行重载；</li>
    <li>重载的函数应该在相同的作用域下；</li>
</ul>


<h4>验证程序：</h4>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;func 1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// OK: 通过参数类型不同重载 Func1()</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">double</span> <span class="n">arg1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;func 2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// OK: 通过参数个数不同重载 Func1()</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;func 3&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// OK: 重载函数返回值可以不同</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">arg2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;func 4&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// ERROR: 不能只通过返回值来进行重载</span>
</span><span class='line'>  <span class="cm">/*bool Func1(int arg1) {</span>
</span><span class='line'><span class="cm">    return true;</span>
</span><span class='line'><span class="cm">  } */</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>  <span class="n">a</span><span class="p">.</span><span class="n">Func1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="n">a</span><span class="p">.</span><span class="n">Func1</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">a</span><span class="p">.</span><span class="n">Func1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>  <span class="n">a</span><span class="p">.</span><span class="n">Func1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func 1
</span><span class='line'>func 2
</span><span class='line'>func 3
</span><span class='line'>func 4</span></code></pre></td></tr></table></div></figure>


<h2>二 重写（override）</h2>


<h4>概念：</h4>


<p>也称为覆盖，子类重新定义父类中有相同名称和参数的虚函数，主要在继承关系中出现。</p>

<h4>基本条件：</h4>


<ul>
    <li>重写的函数和被重写的函数必须为virtual函数，分别位于基类和派生类中；</li>
    <li>重写的函数和被重写的函数函数名和函数参数必须一致；</li>
    <li>重写的函数和被重写的函数返回值相同，或者都返回指针或引用，并且派生类虚函数所返回的指针或引用的类型是基类中被替换的虚函数所返回的</li>
    <li>指针或引用的类型的子类型。</li>
</ul>


<h4>注意：</h4>


<ul>
    <li>重写的函数所抛出的异常必须和被重写的函数所抛出的异常一致，或者是其子类；</li>
    <li>重写的函数的访问修饰符可以不同于被重写的函数，如基类的virtual函数的修饰符为private，派生类改为public或protected也是可以的。</li>
    <li>静态方法不能被重写，也就是static和virtual不能同时使用。</li>
    <li>重写的函数可以带virtual关键字，也可以不带。</li>
</ul>


<h4>验证程序：</h4>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func1</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class C: func 1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">virtual</span> <span class="n">A</span><span class="o">*</span> <span class="n">Func2</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class C: func 2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="n">A</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// ERROR:静态函数不能被声明为virtual，也就没办法被重写。</span>
</span><span class='line'>  <span class="c1">// static virtual void FuncStatic() {}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//由于Func3被声明为private，所以需要通过public函数来调用</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">ShowFunc3</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Func3</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func4</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class C: func 4&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'> <span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func3</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class C: func 3&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">C</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="c1">// OK: 重写C类Func1，可以不带virtual关键字</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class D: func 1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// OK: 当返回值为指针或者引用时，返回值可以是父类返回值类型的子类</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="n">B</span><span class="o">*</span> <span class="n">Func2</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class D: func 2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="n">B</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// ERROR: 除上面的情况，返回值类型要和父类一直</span>
</span><span class='line'>  <span class="cm">/*virtual bool Func2() {</span>
</span><span class='line'><span class="cm">  }*/</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// OK: 重写的函数的访问修饰符可以不同于被重写的函数</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func3</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class D: func 3&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'> <span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="c1">// OK: 重写的函数的访问修饰符可以不同于被重写的函数</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func4</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class D: func 4&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">C</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">D</span><span class="p">;</span>
</span><span class='line'>  <span class="n">c</span><span class="o">-&gt;</span><span class="n">Func1</span><span class="p">();</span>
</span><span class='line'>  <span class="n">c</span><span class="o">-&gt;</span><span class="n">Func2</span><span class="p">();</span>
</span><span class='line'>  <span class="n">c</span><span class="o">-&gt;</span><span class="n">ShowFunc3</span><span class="p">();</span>
</span><span class='line'>  <span class="n">c</span><span class="o">-&gt;</span><span class="n">Func4</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class D: func 1
</span><span class='line'>class D: func 2
</span><span class='line'>class D: func 3
</span><span class='line'>class D: func 4</span></code></pre></td></tr></table></div></figure>


<h2>三 重定义（redefining）</h2>


<h4>概念：</h4>


<p>也叫隐藏，子类重新定义父类中的非虚函数，屏蔽了父类的同名函数</p>

<h4>基本条件：</h4>


<ul>
    <li>被隐藏的函数之间作用域不相同</li>
</ul>


<h4>注意：</h4>


<ul>
    <li>子类和父类的函数名称相同，但参数不同，此时不管父类函数是不是virtual函数，都将被隐藏。</li>
    <li>子类和父类的函数名称相同，参数也相同，但是父类函数不是virtual函数，父类的函数将被隐藏。</li>
</ul>


<h4>验证程序：</h4>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class A: Func1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class A: Func2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="c1">// 将会重定义父类的方法</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class B: Func1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 将会重写(override)父类方法</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class B: Func2-1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 将会重定义父类的方法</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class B: Func2-2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">B</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="p">;</span>
</span><span class='line'>  <span class="n">b</span><span class="o">-&gt;</span><span class="n">Func1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="n">b</span><span class="o">-&gt;</span><span class="n">Func2</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="n">b</span><span class="o">-&gt;</span><span class="n">Func2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class B: Func1
</span><span class='line'>class B: Func2-1
</span><span class='line'>class B: Func2-2</span></code></pre></td></tr></table></div></figure>


<h2>四 总结</h2>


<p>重载、重写、重定义书面上的区别，以及各自的规则没有太大意义，而且这些名词本身都是翻译过来的，不同的地方翻译也不尽相同，如果初学C++，弄清每个概念的实际意义，以及为什么这么设计才是最重要的。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。</p>
]]></content>
  </entry>
  
</feed>
