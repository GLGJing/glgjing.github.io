<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[GLGJing's Blog]]></title>
  <link href="http://glgjing.github.io/atom.xml" rel="self"/>
  <link href="http://glgjing.github.io/"/>
  <updated>2015-01-09T17:27:56+08:00</updated>
  <id>http://glgjing.github.io/</id>
  <author>
    <name><![CDATA[GLGJing]]></name>
    <email><![CDATA[GLGJing@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Git 清除未跟踪文件]]></title>
    <link href="http://glgjing.github.io/blog/2015/01/09/git-qing-chu-wei-gen-zong-wen-jian/"/>
    <updated>2015-01-09T16:34:45+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/01/09/git-qing-chu-wei-gen-zong-wen-jian</id>
    <content type="html"><![CDATA[<p>在利用<code>git</code>工作时，工程目录下经常会出现一些未跟踪文件，虽然<code>git</code>支持通过<code>.gitingore</code>文件添加一些忽略文件类型和文件目录。但有时需要清理一些临时文件和自动生成的文件，手动删除显得太麻烦，这时你可以利用<code>git clean</code>命令来帮你完成这项操作。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<code>git clean</code>命令支持以下参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean [-d] [-f] [-i] [-n] [-q] [-e &lt;pattern>] [-x | -X] [--] &lt;path>...</span></code></pre></td></tr></table></div></figure>


<p>其中几个主要参数用法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-d   # 删除未跟踪目录以及目录下的文件，如果目录下包含其他git仓库文件，并不会删除（-dff可以删除）。
</span><span class='line'>-f   # 如果 git cofig 下的 clean.requireForce 为true，那么clean操作需要-f(--force)来强制执行。
</span><span class='line'>-i   # 进入交互模式
</span><span class='line'>-n   # 查看将要被删除的文件，并不实际删除文件</span></code></pre></td></tr></table></div></figure>


<p>通过以上几根参数组合，基本上可以满足删除未跟踪文件的需求了。例如在删除前先查看有哪些文件将被删除运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean -n</span></code></pre></td></tr></table></div></figure>


<p>想删除当前工作目录下的未跟踪文件，但不删除文件夹运行（如果<code>clean.requireForce</code>为<code>false</code>可以不加<code>-f</code>选项）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean -f</span></code></pre></td></tr></table></div></figure>


<p>想删除当前工作目录下的未跟踪文件以及文件夹运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean -df</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 修改提交历史]]></title>
    <link href="http://glgjing.github.io/blog/2015/01/06/git-xiu-gai-ti-jiao-li-shi/"/>
    <updated>2015-01-06T11:14:40+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/01/06/git-xiu-gai-ti-jiao-li-shi</id>
    <content type="html"><![CDATA[<h2>引言</h2>


<p>在使用git进行工作时，经常会碰到想要修改本地提交记录（还没有push到远程仓库）的情况。例如这样一个场景：你接到一个任务，这个任务可能需要一个星期的开发时间，于是你从<code>master</code>分之上运行<code>git checkout -b new_branch</code>命令，<code>checkout</code>到<code>new_branch</code>分之上进行该任务的开发，在开发的过程中向<code>new_branch</code>分之提交了多个<code>commit</code>，然后发现有些代码不是很合理，于是又更改代码提交新的<code>commit</code>，反反复复终于完成了该任务的开发，是时候提交review并合并到<code>master</code>分之上了，但是你发现提交记录非常混乱，并不利于同事review，而且你的同事也不关心你的具体修改过程，他们只想看到最终的实现，此时问题来了，如果你把所有的<code>commit</code>合并成一个大<code>commit</code>，虽然你的同事可以直接看到最终代码，但你的各个模块都混在一起提交，很难按模块单独进行review并发现问题；如果你直接提交review，你的同事就不得不把你的所有提交历史都review一遍，包括一些实际上已经在后面提交中被你修改掉的代码，脾气好的估计内心一万只草泥马奔过，脾气不好的保证不打死你！当然<code>git</code>是不可能考虑不到这种情况的，扯了这么多，下面就来看一下如何修改<code>git</code>的提交历史。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<!-- more --></p>

<h2>一 修改最近一次提交记录</h2>


<h3>1 只修改提交说明</h3>


<p>修改最近一次提交是非常常见的需求，如果只想更改最近一次的提交说明是非常方便的，只需输入如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git commit —amend</span></code></pre></td></tr></table></div></figure>


<p>然后你就会进入文本编辑器，输入你想要的内容，保存并退出即可。</p>

<h3>2 添加新的更改</h3>


<p>如果你完成提交后又想修改被提交的快照，增加或者修改其中的文件，过程基本和上面一样。先运<code>git add</code>命令，将修改的文件添加到缓存区,然后运行<code>git commit —amend</code>命令，该命令会获取你当前的暂存区的内容一并提交到最后一次<code>commit</code>。例如：新加了一个文件new_file.cpp，想要合并到最后一次提交，过程如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add new_file.cpp
</span><span class='line'>git commit —amend</span></code></pre></td></tr></table></div></figure>


<p>也可以直接运行下面的命令，不过要小心，不要提交了多余的文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git commit -a —amend</span></code></pre></td></tr></table></div></figure>


<h3>3 将文件从本次提交中移除</h3>


<p>如果想把已经<code>commit</code>的文件从这次<code>commit</code>移除的话，可以运行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git reset [—soft] HEAD~1 # —soft可加可不加，默认就是soft选项
</span><span class='line'>git checkout —filename # 要从本次提交移除的文件名
</span><span class='line'>git commit -m “new commit"</span></code></pre></td></tr></table></div></figure>


<h2>二 修改多个提交</h2>


<p>要修改历史中更早的提交，你必须采用更复杂的工具。<code>git</code>没有一个修改历史的工具，但是你可以使用<code>rebase</code>工具来衍合一系列的提交到它们原来所在的<code>HEAD</code>上。依靠这个交互式的<code>rebase</code>工具，你就可以停留在每一次提交后，如果你想修改或改变说明、增加文件或任何其他事情。你可以通过给<code>git rebase -i</code>命令以交互方式进行<code>rebase</code>。例如，你想修改最近三次的提交说明，或者其中任意一次，你必须给<code>git rebase -i</code>提供一个参数，指明你想要修改的提交的父提交。例如<code>HEAD~3</code>是指从<code>HEAD</code>指针到<code>HEAD+3</code>的位置，也就是最近第4次提交。所以想修改最近3次提交，你需要指明第3次提交的父提交（第4次提交）即<code>HEAD~3</code>。运行命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git rebase -i HEAD~3</span></code></pre></td></tr></table></div></figure>


<p>再次提醒这是一个衍合命令，也就是<code>HEAD~3</code>到<code>HEAD</code>范围内的每一次提交都会被重写，不管你是否修改提交说明<code>SHA-1</code>的值都会发生变化。<font color="red">所以千万不要涵盖你已经推送到中心服务器的提交。</font>这么做会使其他开发者产生混乱，因为你提供了同样变更的不同版本。运行该命令后进入交互界面，类似：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>
</span><span class='line'># Rebase f77f585..fecb551 onto f77f585
</span><span class='line'>#
</span><span class='line'># Commands:
</span><span class='line'>#  p, pick = use commit
</span><span class='line'>#  r, reword = use commit, but edit the commit message
</span><span class='line'>#  e, edit = use commit, but stop for amending
</span><span class='line'>#  s, squash = use commit, but meld into previous commit
</span><span class='line'>#  f, fixup = like "squash", but discard this commit's log message
</span><span class='line'>#  x, exec = run command (the rest of the line) using shell
</span><span class='line'>#
</span><span class='line'># These lines can be re-ordered; they are executed from top to bottom.
</span><span class='line'># If you remove a line here THAT COMMIT WILL BE LOST.
</span><span class='line'># However, if you remove everything, the rebase will be aborted.
</span><span class='line'># Note that empty commits are commented out</span></code></pre></td></tr></table></div></figure>


<p>根据命令提示，就可以进行历史更改了。很重要的一点是你得注意这些提交的顺序与你通常通过<code>log</code>命令看到的是相反的。如果你运行<code>log</code>，你会看到下面这样的结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick fecb551 Init the view model</span></code></pre></td></tr></table></div></figure>


<h3>1 修改指定提交</h3>


<p>例如：只修改最近第3次提交说明可以进行如下更改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reword fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>保存并退出编辑器，<code>rebase</code>命令在衍合到第3次提交时会进入提交说明编辑页面，在此进行编辑新的提交说明，保存并退出即可，<code>rebase</code>命令继续进行直至完成全部衍合操作。如果你不仅想要修改提交说明，还要更改提交，可以进行如下更改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>edit fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>保存并退出编辑器，<code>rebase</code>命令在衍合到第三次提交时会等待你提交新的更改，并提示你修改完成后运行<code>git commit &ndash;amend</code>命令，然后运行<code>git rebase &ndash;continue</code>继续进行<code>rebase</code>直至完成全部衍合。</p>

<h3>2 重排提交</h3>


<p>你也可以使用<code>git rebase -i</code>命令对提交历史彻底重排或删除提交。例如你想删除&#8221;Update the version&#8221;这个提交，并且修改其他两次提交的顺序，可以将</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>改为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>pick fecb551 Init the view model</span></code></pre></td></tr></table></div></figure>


<p>然后保存并退出编辑器，此时<code>rebase</code>命令会先应用bc5cd9d (Add new method)，然后应用 fecb551 (Init the view model)bb199a0 Update the version这次提交。
然后保存并退出编辑器，此时<code>rebase</code>命令会先应用bc5cd9d (Add new method)，然后应用 fecb551 (Init the view model)，接着停止。执行完上诉操作，你已经修改了这些提交的顺序，并且删除了bb199a0 (Update the version)这次提交。</p>

<h3>3 合并提交</h3>


<p><code>git rebase -i</code>命令还可以将一系列提交合并成一个提交。从上面的脚本提示中可以看到<code>s, squash = use commit, but meld into previous commit</code>提示。如果用<code>squash</code>修饰提交就可以进行提交之间的合并，例如可以将脚本修改成这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>squash bb199a0 Update the version
</span><span class='line'>squash bc5cd9d Add new method</span></code></pre></td></tr></table></div></figure>


<p>保存并退出编辑器，<code>rebase</code>命令会应用全部三次变更然后进入编辑器来归并三次提交说明。当你保存之后，你就拥有了一个包含前三次提交的全部变更的单一提交。</p>

<h3>4 拆分提交</h3>


<p>拆分提交实际上就是撤销一次提交，然后分多次进行重新提交。例如你想将三次提交中的中间一次拆分。将&#8221;Update the version&#8221;拆分成两次提交：&#8221;Update the version1&#8221;和&#8221;Update the version2&#8221;，可以进行如下修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>edit bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method</span></code></pre></td></tr></table></div></figure>


<p>当<code>rebase</code>到bb199a0时，会进入等待你提交新<code>commit</code>的状态，这时看可以运行<code>git reset HEAD^</code>对当前提交进行重置，然后分别运行<code>git add</code>命令添加想要提交的文件，分别进行<code>git commit</code>，最后运行<code>git rebase &ndash;continue</code>完成所有衍合。整体过程如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git reset HEAD^
</span><span class='line'>git add file1
</span><span class='line'>git commit -m 'Update the version1'
</span><span class='line'>git add file2
</span><span class='line'>git commit -m 'Update the version2'
</span><span class='line'>git rebase --continue</span></code></pre></td></tr></table></div></figure>


<p>执行完上诉操作，提交历史看起来就像这样了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1c002dd Add new method
</span><span class='line'>9b29157 Update the version2
</span><span class='line'>35cfb2b Update the version1
</span><span class='line'>f3cc40e Init the view model</span></code></pre></td></tr></table></div></figure>


<p><font color="red">再次提醒，这会修改你列表中的提交的<code>SHA</code>值，所以请确保这个列表里不包含你已经推送到共享仓库的提交。</font></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++虚函数浅析]]></title>
    <link href="http://glgjing.github.io/blog/2015/01/03/c-plus-plus-xu-han-shu-qian-xi/"/>
    <updated>2015-01-03T01:59:30+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/01/03/c-plus-plus-xu-han-shu-qian-xi</id>
    <content type="html"><![CDATA[<h2>一 引言</h2>


<p>C++面向对象语言的一大特性就是抽象，在程序设计上的体现就是鼓励面向接口编程，而不要面向具体实现编程。这里所说的抽象和接口与C++的多态性密切相关。C++的多态分为静态多态（编译时多态）和动态多态（运行时多态）两大类。静态多态通过重载、模板来实现；动态多态就是通过本文的主角虚函数来体现的。虚函数是C++语言一个非常重要的特性，不同编译器对此特性的实现机制也略有差别，虽然具体实现细节由编译器说的算，在大多情况下我们不需要关心，但虚函数在某些情况下对程序的占用内存大小和执行效率有比较明显的影响，这时候知道虚函数背后的实现原理，知其然、知其所以然是很有必要的。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<!-- more --></p>

<h2>二 虚函数实现原理</h2>


<p>虚函数的作用说白了就是：<font color="red">当调用一个虚函数时，被执行的代码必须和调用函数的对象的动态类型相一致。</font>编译器需要做的就是如何高效的实现提供这种特性。不同编译器实现细节也不相同。大多数编译器通过vtbl（virtual table）和vptr（virtual table pointer）来实现的。
当一个类声明了虚函数或者继承了虚函数，这个类就会有自己的vtbl。vtbl实际上就是一个函数指针数组，有的编译器用的是链表，不过方法都是差不多。vtbl数组中的每一个元素对应一个函数指针指向该类的一个虚函数，同时该类的每一个对象都会包含一个vptr，vptr指向该vtbl的地址。例如一个类的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func1</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Func2</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Func3</span><span class="p">();</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">Func4</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>A</code>类的对象的结构如下：
<img class="center" src="http://glgjing.github.io/images/1-5.png">
从图中可以看出<code>A</code>类对象中包含一个vptr，而vptr的值就是<code>A</code>类的vtbl的地址，vtbl中三个元素的值分别是虚函数<code>Func1</code>、<code>Func2</code>、<code>Func3</code>的地址，而非虚函数<code>Func4</code>并没有在vtbl中。</p>

<h3>1 单继承情况</h3>


<p>下面定义一个类<code>B</code>继承自类<code>A</code>，重写了(override)虚函数<code>Func1</code>，并且定义了自己的虚函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func1</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Func5</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>声明一个<code>A</code>类指针<code>A* a = new B;</code>。a的内容如下：
<img class="center" src="http://glgjing.github.io/images/1-6.png">
同样<code>a</code>的值包含一个vptr，vptr指向<code>B</code>类的vtbl，而<code>B</code>类的vtbl中元素的值相比<code>A</code>类的vtbl有一些变化，<code>B</code>类重写<code>A</code>类虚函数的地址<code>B::Func1</code>取代了<code>A::Func1</code>在vtbl的位置，<code>B</code>类新定义的虚函数<code>B::Func5</code>也被添加到vtbl中，且父类的虚函数在子类的虚函数前面。此时通过指针<code>a</code>调用<code>Func1</code>过程相当于：</p>

<ol>
  <li>通过指针<code>a</code>指向的地址，取出的具体值为类型<code>B</code>，找到里面的vptr，该vptr指向的是<code>B</code>类的vtbl</li>
  <li>通过vptr找到<code>B</code>类的vtbl地址</li>
  <li>然后通过<code>B</code>类的vtbl找到<code>Func1</code>的函数地址，调用执行，最终执行的就是<code>B::Func1</code></li>
</ol>


<p>以上过程就基本解释了C++虚函数是如何做到被执行的代码和调用函数的对象的动态类型相一致的特性了。</p>

<h3>2 多继承情况</h3>


<p>上面讨论的是单继承的情况，下面来看一下多继承情况。定义三个类<code>Base1</code><code>Base2</code><code>Base3</code>，和一个子类<code>SubClass</code>如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Base1</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">FuncB1</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Base2</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">FuncB2</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Base3</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">FuncB3</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">SubClass</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base1</span><span class="p">,</span> <span class="k">public</span> <span class="n">Base2</span><span class="p">,</span> <span class="k">public</span> <span class="n">Base3</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">FuncSub</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>SubClass</code>对象的结构如下：
<img class="center" src="http://glgjing.github.io/images/1-7.png">
可以看到<code>SubClass</code>对象包含三个vptr分别指向三个vtbl，每个vtbl对应一个父类的vtbl。当子类覆盖父类的虚函数时，对应的vtbl变化与单继承情况相同，就是子类的虚函数替换父类相应虚函数在vtbl的位置。子类新定义的虚函数，会放在第一个父类的vtbl的后面，这里的第一个是指继承类的顺序（<font color="red">其实这个并不是一定的，不同编译器有自由去选择不同的实现方式</font>）。之所以这样设计就是为了解决不同的父类类型指针在指向同一个子类实例，能够调用到各自实际的虚函数。具体的调用过程同单继承的情况相同。</p>

<h3>结论：</h3>


<ul>
  <li>每个声明了虚函数或者继承了虚函数的类，都会有一个自己的vtbl</li>
  <li>同时该类的每个对象都会包含一个vptr去指向该vtbl</li>
  <li>虚函数按照其声明顺序放于vtbl表中, vtbl数组中的每一个元素对应一个函数指针指向该类的虚函数</li>
  <li>如果子类覆盖了父类的虚函数，将被放到了虚表中原来父类虚函数的位置</li>
  <li>在多继承的情况下，每个父类都有自己的虚表。子类的成员函数被放到了第一个父类的表中</li>
</ul>


<h2>三 虚函数所需的代价</h2>


<p>上面介绍了虚函数的基本实现原理，虚函数的优点不用多说，实现了运行时多态的特性。下面来分析下虚函数所需的代价，程序运行时代价无非主要体现在时间和空间上。</p>

<h3>调用性能方面</h3>


<p>从前面虚函数的调用过程可知。当调用虚函数时过程如下（引自More Effective C++）:</p>

<ol>
  <li>通过对象的 vptr 找到类的 vtbl。这是一个简单的操作,因为编译器知道在对象内 哪里能找到 vptr(毕竟是由编译器放置的它们)。因此这个代价只是一个偏移调整(以得到 vptr)和一个指针的间接寻址(以得到 vtbl)。</li>
  <li>找到对应 vtbl 内的指向被调用函数的指针。这也是很简单的, 因为编译器为每个虚函数在 vtbl 内分配了一个唯一的索引。这步的代价只是在 vtbl 数组内 的一个偏移。</li>
  <li>调用第二步找到的的指针所指向的函数。</li>
</ol>


<p>在单继承的情况下，调用虚函数所需的代价基本上和非虚函数效率一样，在大多数计算机上它多执行了很少的一些指令，所以有很多人一概而论说虚函数性能不行是不太科学的。在多继承的情况下，由于会根据多个父类生成多个vptr，在对象里为寻找 vptr 而进行的偏移量计算会变得复杂一些，但这些并不是虚函数的性能瓶颈。
<font color="red">虚函数运行时所需的代价主要是虚函数不能是内联函。</font>这也是非常好理解的，是因为内联函数是指在编译期间用被调用的函数体本身来代替函数调用的指令，但是虚函数的“虚”是指“直到运行时才能知道要调用的是哪一个函数。”但虚函数的运行时多态特性就是要在运行时才知道具体调用哪个虚函数，所以没法在编译时进行内联函数展开。当然如果通过对象直接调用虚函数它是可以被内联，但是大多数虚函数是通过对象的指针或引用被调用的，这种调用不能被内联。 因为这种调用是标准的调用方式，所以虚函数实际上不能被内联。</p>

<h3>占用空间方面</h3>


<p>在上面的虚函数实现原理部分，可以看到为了实现运行时多态机制，编译器会给每一个包含虚函数或继承了虚函数的类自动建立一个虚函数表，<font color="red">所以虚函数的一个代价就是会增加类的体积。</font>在虚函数接口较少的类中这个代价并不明显，虚函数表vtbl的体积相当于几个函数指针的体积，如果你有大量的类或者在每个类中有大量的虚函数,你会发现 vtbl 会占用大量的地址空间。但这并不是最主要的代价，主要的代价是发生在类的继承过程中，在上面的分析中，可以看到，当子类继承父类的虚函数时，子类会有自己的vtbl，如果子类只覆盖父类的一两个虚函数接口，子类vtbl的其余部分内容会与父类重复。这在如果存在大量的子类继承，且重写父类的虚函数接口只占总数的一小部分的情况下，会造成大量地址空间浪费。在一些GUI库上这种大量子类继承自同一父类且只覆盖其中一两个虚函数的情况是经常有的，这样就导致UI库的占用内存明显变大。
<font color="red">由于虚函数指针vptr的存在，虚函数也会增加该类的每个对象的体积。</font>在单继承或没有继承的情况下，类的每个对象会多一个vptr指针的体积，也就是4个字节；在多继承的情况下，类的每个对象会多N个（N＝包含虚函数的父类个数）vptr的体积，也就是4N个字节。当一个类的对象体积较大时，这个代价不是很明显，但当一个类的对象很轻量的时候，如成员变量只有4个字节，那么再加上4（或4N）个字节的vptr，对象的体积相当于翻了1（或N）倍，这个代价是非常大的。</p>

<h2>四 总结</h2>


<p>本文主要介绍了虚函数的实现机制，以及实现该机制所付出的代价，这里没有进一步讨论继承的利与弊，但经过上面的一些讨论，也可以从侧面反映出一些问题。理解虚函数的代价是有必要的，一方面是有利于高效恰当的使用它，一方面也该意识到如果你需要这些功能, 不管采取什么样的方法你都得为此付出代价，在多数情况下,你的人工模拟可能比编译器生成的代码效率更低,稳定性更差。例如使用嵌套的<code>switch</code>语句或层叠的<code>if-then-else</code>语句模拟虚函数的调用,其产生的代码比虚函数的调用还要多,而且代码运行速度也更慢。再有你必须自己人工跟踪对象类型,这意味着对象会携带它们自己的类型标签(type tag)，因此你不会得到更小的对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++重载、重写、重定义区别]]></title>
    <link href="http://glgjing.github.io/blog/2014/12/27/c-plus-plus-zhong-zai-,-zhong-xie-,-zhong-ding-yi-qu-bie/"/>
    <updated>2014-12-27T15:32:17+08:00</updated>
    <id>http://glgjing.github.io/blog/2014/12/27/c-plus-plus-zhong-zai-,-zhong-xie-,-zhong-ding-yi-qu-bie</id>
    <content type="html"><![CDATA[<h2>一 重载（overload）</h2>


<h4>概念：</h4>


<p>函数有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数之间，互相称之为重载函数。</p>

<h4>基本条件：</h4>


<ul>
    <li>函数名必须相同；</li>
    <li>函数参数必须不相同，可以是参数类型或者参数个数不同；</li>
    <li>函数返回值可以相同，也可以不相同；</li>
</ul>


<blockquote><p><!-- more --></p></blockquote>

<h4>注意：</h4>


<ul>
    <li>只能通过不同的参数样式进行重载，例如：不同的参数类型，不同的参数个数，不同的参数顺序；</li>
    <li>不能通过访问权限、返回类型、抛出的异常进行重载；</li>
    <li>重载的函数应该在相同的作用域下；</li>
</ul>


<h4>验证程序：</h4>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;func 1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// OK: 通过参数类型不同重载 Func1()</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">double</span> <span class="n">arg1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;func 2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// OK: 通过参数个数不同重载 Func1()</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;func 3&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// OK: 重载函数返回值可以不同</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">arg2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;func 4&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// ERROR: 不能只通过返回值来进行重载</span>
</span><span class='line'>  <span class="cm">/*bool Func1(int arg1) {</span>
</span><span class='line'><span class="cm">    return true;</span>
</span><span class='line'><span class="cm">  } */</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>  <span class="n">a</span><span class="p">.</span><span class="n">Func1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="n">a</span><span class="p">.</span><span class="n">Func1</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">a</span><span class="p">.</span><span class="n">Func1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>  <span class="n">a</span><span class="p">.</span><span class="n">Func1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func 1
</span><span class='line'>func 2
</span><span class='line'>func 3
</span><span class='line'>func 4</span></code></pre></td></tr></table></div></figure>


<h2>二 重写（override）</h2>


<h4>概念：</h4>


<p>也称为覆盖，子类重新定义父类中有相同名称和参数的虚函数，主要在继承关系中出现。</p>

<h4>基本条件：</h4>


<ul>
    <li>重写的函数和被重写的函数必须为virtual函数，分别位于基类和派生类中；</li>
    <li>重写的函数和被重写的函数函数名和函数参数必须一致；</li>
    <li>重写的函数和被重写的函数返回值相同，或者都返回指针或引用，并且派生类虚函数所返回的指针或引用的类型是基类中被替换的虚函数所返回的</li>
    <li>指针或引用的类型的子类型。</li>
</ul>


<h4>注意：</h4>


<ul>
    <li>重写的函数所抛出的异常必须和被重写的函数所抛出的异常一致，或者是其子类；</li>
    <li>重写的函数的访问修饰符可以不同于被重写的函数，如基类的virtual函数的修饰符为private，派生类改为public或protected也是可以的。</li>
    <li>静态方法不能被重写，也就是static和virtual不能同时使用。</li>
    <li>重写的函数可以带virtual关键字，也可以不带。</li>
</ul>


<h4>验证程序：</h4>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func1</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class C: func 1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">virtual</span> <span class="n">A</span><span class="o">*</span> <span class="n">Func2</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class C: func 2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="n">A</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// ERROR:静态函数不能被声明为virtual，也就没办法被重写。</span>
</span><span class='line'>  <span class="c1">// static virtual void FuncStatic() {}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//由于Func3被声明为private，所以需要通过public函数来调用</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">ShowFunc3</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Func3</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func4</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class C: func 4&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'> <span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func3</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class C: func 3&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">C</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="c1">// OK: 重写C类Func1，可以不带virtual关键字</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class D: func 1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// OK: 当返回值为指针或者引用时，返回值可以是父类返回值类型的子类</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="n">B</span><span class="o">*</span> <span class="n">Func2</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class D: func 2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="n">B</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// ERROR: 除上面的情况，返回值类型要和父类一直</span>
</span><span class='line'>  <span class="cm">/*virtual bool Func2() {</span>
</span><span class='line'><span class="cm">  }*/</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// OK: 重写的函数的访问修饰符可以不同于被重写的函数</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func3</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class D: func 3&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'> <span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="c1">// OK: 重写的函数的访问修饰符可以不同于被重写的函数</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func4</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class D: func 4&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">C</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">D</span><span class="p">;</span>
</span><span class='line'>  <span class="n">c</span><span class="o">-&gt;</span><span class="n">Func1</span><span class="p">();</span>
</span><span class='line'>  <span class="n">c</span><span class="o">-&gt;</span><span class="n">Func2</span><span class="p">();</span>
</span><span class='line'>  <span class="n">c</span><span class="o">-&gt;</span><span class="n">ShowFunc3</span><span class="p">();</span>
</span><span class='line'>  <span class="n">c</span><span class="o">-&gt;</span><span class="n">Func4</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class D: func 1
</span><span class='line'>class D: func 2
</span><span class='line'>class D: func 3
</span><span class='line'>class D: func 4</span></code></pre></td></tr></table></div></figure>


<h2>三 重定义（redefining）</h2>


<h4>概念：</h4>


<p>也叫隐藏，子类重新定义父类中的非虚函数，屏蔽了父类的同名函数</p>

<h4>基本条件：</h4>


<ul>
    <li>被隐藏的函数之间作用域不相同</li>
</ul>


<h4>注意：</h4>


<ul>
    <li>子类和父类的函数名称相同，但参数不同，此时不管父类函数是不是virtual函数，都将被隐藏。</li>
    <li>子类和父类的函数名称相同，参数也相同，但是父类函数不是virtual函数，父类的函数将被隐藏。</li>
</ul>


<h4>验证程序：</h4>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class A: Func1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class A: Func2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="c1">// 将会重定义父类的方法</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class B: Func1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 将会重写(override)父类方法</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class B: Func2-1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 将会重定义父类的方法</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">Func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class B: Func2-2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">B</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="p">;</span>
</span><span class='line'>  <span class="n">b</span><span class="o">-&gt;</span><span class="n">Func1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="n">b</span><span class="o">-&gt;</span><span class="n">Func2</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="n">b</span><span class="o">-&gt;</span><span class="n">Func2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class B: Func1
</span><span class='line'>class B: Func2-1
</span><span class='line'>class B: Func2-2</span></code></pre></td></tr></table></div></figure>


<h2>四 总结</h2>


<p>重载、重写、重定义书面上的区别，以及各自的规则没有太大意义，而且这些名词本身都是翻译过来的，不同的地方翻译也不尽相同，如果初学C++，弄清每个概念的实际意义，以及为什么这么设计才是最重要的。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Octopress和Github搭建个人博客（三）：添加统计信息]]></title>
    <link href="http://glgjing.github.io/blog/2014/12/22/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(san-):tian-jia-tong-ji-xin-xi/"/>
    <updated>2014-12-22T16:46:14+08:00</updated>
    <id>http://glgjing.github.io/blog/2014/12/22/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(san-):tian-jia-tong-ji-xin-xi</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://glgjing.github.io/images/1-4.png"></p>

<h2>引言</h2>


<p>搭建好基本环境（如果没有请戳<a href="http://glgjing.github.io/blog/2014/12/06/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(%5B%3F%5D-):ji-chu-huan-jing-da-jian/">这里</a>），折腾完主题（如果想折腾请戳<a href="http://glgjing.github.io/blog/2014/12/12/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(er-):zi-ding-yi-zhu-ti/">这里</a>），就可以安安静静的写博客了。但博客毕竟不是日记，还是需要和其他人分享交流的，尤其是技术博客。那么首先你需要别人能够通过搜索引擎找到你的博客，其次你需要别人能够更方便准确的找到你的博客，这就需要为你的博客录入搜索引擎，添加统计信息，以便进行SEO。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<!-- more --></p>

<h2>目录</h2>


<ul>
    <li>一 录入搜索引擎</li>
    <li>二 添加统计信息</li>
    <li>三 总结</li>
</ul>


<h2>一 录入搜索引擎</h2>


<p>在自建博客网站上写的博客，一开始并不会在搜索引擎中搜得到，不像博客平台一样，因为你还没有向搜索引擎提交你的网站URL，让它去抓取你博客网站的内容。所以赶紧提交吧，提交地址：<code><a href="http://www.gongju.com/addurl/">http://www.gongju.com/addurl/</a></code>，也可以自行google：搜索引擎提交入口。提交完成之后，就可以在相应的搜索引擎中找到你的博客了。现在你还需要为你的网站和博文添加描述信息以及关键字，让其他人可以在搜索引擎中更方便准确的找到你的博客。为每篇博文添加关键字和描述的方法是，打开<code>source/_posts/</code>目录下对应的博文文件，在文件头部添加类似如下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>---
</span><span class='line'>layout: post
</span><span class='line'>title: "利用Octopress和Github搭建个人博客（三）：添加统计信息"
</span><span class='line'>date: 2014-12-22 16:46:14 +0800
</span><span class='line'>comments: true
</span><span class='line'>categories: Octopress
</span><span class='line'>keywords: Octopress github 搭建博客 添加统计 SEO 录入搜索引擎
</span><span class='line'>description: 为Octopress博客录入搜索引擎，并添加流量统计信息，进行SEO。
</span><span class='line'>---</span></code></pre></td></tr></table></div></figure>


<p>如果没有为博文添加描述信息，Octopress会自动以文章的前150字作为博文的描述信息。为网站首页添加关键字和描述的方法是，打开<code>source/index.html</code>文件，在文件头部添加类似如下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>---
</span><span class='line'>layout: default
</span><span class='line'>tags: [windows c++ octopress Github DirectUI GDI]
</span><span class='line'>keywords: windows c++ octopress Github
</span><span class='line'>description: 博客网站的描述信息在这里
</span><span class='line'>---</span></code></pre></td></tr></table></div></figure>


<p>通过以上操作，搜索引擎就可以根据用户输入的关键字对你的博文进行更准确的索引。如果想让自己的博客出现在搜索结果中靠前的位置，就需要网站流量统计工具进行进一步的SEO了。</p>

<h2>二 添加统计信息</h2>


<p>常用的网站统计工具有：Google Analytics，Yahoo网站流量统计，百度统计，CNZZ，51.la等等。Octopress自带Google Analytics工具，所以添加Google统计比较方便：</p>

<ol>
    <li>注册<a href="http://www.google.com/analytics/">Google Analytics</a>账号</li>
    <li>获得一个google_analytics_tracking_id，添加到_config.yml中google_analytics_tracking_id:后面</li>
    <li>按照Google Analytics提示，对博客网站进行验证</li>
</ol>


<p>完成以上步骤，就可以利用Google Analytics进行流量统计了，你还可以注册<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">Google站长工具</a>，进行更详细的分析和SEO。
除了自带的Google Analytics你还可以添加其他统计工具，具体步骤都比较类似，这里以CNZZ为例：</p>

<ol>
    <li>注册<a href="http://zhanzhang.cnzz.com/">CNZZ账号</a></li>
    <li>按照提示获取统计代码</li>
    <li>将统计代码添加到需要统计的页面，一般可以添加到<code>source/_includes/custom/footer.html</code>中</li>
</ol>


<p>添加到<code>source/_includes/custom/footer.html</code>中的统计代码类似如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;p&gt;</span>
</span><span class='line'>  Copyright <span class="ni">&amp;copy;</span> 2015 - GLGJing
</span><span class='line'>  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span><span class="nt">&gt;</span><span class="kd">var</span> <span class="nx">cnzz_protocol</span> <span class="o">=</span> <span class="p">((</span><span class="s2">&quot;https:&quot;</span> <span class="o">==</span> <span class="nb">document</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">protocol</span><span class="p">)</span> <span class="o">?</span> <span class="s2">&quot; https://&quot;</span> <span class="o">:</span> <span class="s2">&quot; http://&quot;</span><span class="p">);</span><span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">unescape</span><span class="p">(</span><span class="s2">&quot;%3Cspan id=&#39;cnzz_stat_icon_1253899728&#39;%3E%3C/span%3E%3Cscript src=&#39;&quot;</span> <span class="o">+</span> <span class="nx">cnzz_protocol</span> <span class="o">+</span> <span class="s2">&quot;s4.cnzz.com/z_stat.php%3Fid%3D1253899728&#39; type=&#39;text/javascript&#39;%3E%3C/script%3E&quot;</span><span class="p">));</span><span class="nt">&lt;/script&gt;</span>
</span><span class='line'><span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>三 总结</h2>


<p>这里主要介绍了如何将博客网站添加到搜索引擎，并添加网站流量统计工具，各种流量统计工具的优劣可以自行google，后面需要做的就是SEO了，而SEO是一件长期持续的工作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Octopress和Github搭建个人博客（二）：自定义主题]]></title>
    <link href="http://glgjing.github.io/blog/2014/12/12/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(er-):zi-ding-yi-zhu-ti/"/>
    <updated>2014-12-12T16:19:09+08:00</updated>
    <id>http://glgjing.github.io/blog/2014/12/12/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(er-):zi-ding-yi-zhu-ti</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://glgjing.github.io/images/1-2.png"></p>

<h2>引言</h2>


<p>在为Octopress博客自定义主题之前，你应该已经搭建好了基础环境。如果还没开始搭建可以参考<a href="http://glgjing.github.io/blog/2014/12/06/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(%5B%3F%5D-):ji-chu-huan-jing-da-jian/">利用Octopress和Github搭建个人博客（一）：基础环境搭建</a>。在搭建好基础环境之后，如果单纯的写写博文，默认主题也是可以满足需求的。但既然选择了用Octopress和Github Pages来管理自己的博客，不折腾折腾都对不起自己。不要求效果有多炫，但要方便浏览查找。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<!-- more --></p>

<h2>目录</h2>


<ul>
    <li>一 Octopress目录结构介绍</li>
    <li>二 安装第三方主题</li>
    <li>三 主题样式修改</li>
    <li>四 总结</li>
</ul>


<h2>一 Octopress目录结构介绍</h2>


<p>在更改主题之前有必要了解一下Octopress目录下的文件结构，后续所有的修改都在这个目录下进行的。Octopress的目录文件如下：
<img class="center" src="http://glgjing.github.io/images/1-3.png">
初始的Octopress目录下是没有source、sass、public、_deploy这几个文件夹的，运行<code>rake install[&lsquo;theme_name&rsquo;]</code>命令后会生成这几个文件夹。</p>

<ul>
    <li>_config.yml: 站点的配置文件，也是后续需要修改最多的文件。</li>
    <li>source: 该目录是执行<code>rake install['theme_name']</code>后从.themes\theme_name目录中的source拷贝而来(theme_name是你选择的主题名)，并且添加了一个_posts目录了，当执行了rake new_post[&#8221;title&#8221;]后会在_post生成博文的markdown文件。包括后面的很多设置页是在该目录中进行；</li>
    <li>sass：也是在执行<code>rake install['theme_name']</code>后从.themes\theme_name目录中的sass拷贝而来。关于sass可以参考<a href="http://sass-lang.com/guide">这里</a></li>
    <li>public: 当执行了<code>rake generate</code>命令后会编译source目录下的内容然后将编译后的内容复制到public目录中。</li>
  <li>_deploy: 在执行<code>rake deploy</code>命令后，会将public的内容拷贝到_deploy目录下然后提交到Github的master分支上，我们最终看到的网站内容就是master分支下的内容。所以public和_deploy中的内容都是自动生成的，不要手动修改，否则在运行<code>rake generate</code>和<code>rake deploy</code>命令后所有的更改都会被覆盖掉。</li>
</ul>


<h2>二 安装第三方主题</h2>


<p>在做任何主题相关的修改之前，最好选定一款自己喜欢的主题，否则后续再更换主题，会覆盖之前的修改。Github上有很多第三方的主题，可以到<a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes">这里</a>下载。运行类似如下命令进行主题安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd octopress
</span><span class='line'>git clone git://github.com/macjasp/cleanpress.git .themes/cleanpress
</span><span class='line'>rake install['cleanpress']
</span><span class='line'>rake generate</span></code></pre></td></tr></table></div></figure>


<h2>三 主题样式修改</h2>


<h3>1 基本配置修改</h3>


<p>在选定好主题之后就可以进行自定义修改了。首先更改基本配置，Octopress的基本配置存在_config.yml文件里，具体内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>url: http://glgjing.github.io  # 网站的url
</span><span class='line'>title: GLGJing's Blog          # 网站的标题
</span><span class='line'>author: GLGJing                # 网站作者，会显示在底部等位置
</span><span class='line'>simple_search: https://www.google.com/search #搜索引擎
</span><span class='line'>description:                   # 网站描述</span></code></pre></td></tr></table></div></figure>


<p>此处列出了主要的博客配置信息，有些配置项大概看名字就知道功能了，例如网站title，email等；有些配置项比较复杂，后面单独介绍，如添加评论插件、侧边栏等。</p>

<h3>2 设置标题栏: Header</h3>


<p>Octopress的很多自定义配置是存储在/source/_includes/custom/目录下的，如果想要更改标题栏，可以修改该文件夹下的header.html文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;hgroup&gt;</span>
</span><span class='line'>  <span class="nt">&lt;h1&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;/&quot;</span><span class="nt">&gt;</span>GLGJing&#39;s Blog<span class="nt">&lt;/a&gt;&lt;/h1&gt;</span>
</span><span class='line'>  {% if site.subtitle %}
</span><span class='line'>    <span class="nt">&lt;h2&gt;</span>{{ site.subtitle }}<span class="nt">&lt;/h2&gt;</span>
</span><span class='line'>  {% endif %}
</span><span class='line'><span class="nt">&lt;/hgroup&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中的title和subtitle可以直接在_config.yml中修改。</p>

<h3>3 设置导航栏: Navigation</h3>


<p>Navigation的配置方法和Header类似，直接修改/source/_includes/custom/navigation.html文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;main-navigation&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;/&quot;</span><span class="nt">&gt;</span>主页<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>
</span><span class='line'>  <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;/blog/archives&quot;</span><span class="nt">&gt;</span>文章<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>
</span><span class='line'>  <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;/about&quot;</span><span class="nt">&gt;</span>关于<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果想添加新的页面，可以运行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_page['page_name']</span></code></pre></td></tr></table></div></figure>


<p>该命令会建立source/page_name/index.html文件，然后编辑此文件，添加自己想要展示的内容即可，再在navigation.html里添加正确的路径即可,如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;/page_name&quot;</span><span class="nt">&gt;</span>新标签页<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4 设置尾栏: Footer</h3>


<p>修改/source/_includes/custom/footer.html文件来设置尾栏。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;p&gt;</span>
</span><span class='line'>  Copyright <span class="ni">&amp;copy;</span> 2015 - GLGJing -
</span><span class='line'>  <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&quot;credit&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    Powered by<span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://octopress.org&quot;</span><span class="nt">&gt;</span>Octopress<span class="nt">&lt;/a&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/span&gt;</span>
</span><span class='line'><span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以将不需要的信息去掉，添加自己想要的信息如：流量统计工具，个人声明等。</p>

<h3>5 设置背景图和LOGO</h3>


<p>想要更改背景图片，可以在sass/custom/_styles.scss中添加如下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>html {
</span><span class='line'>  background: #555555 url(&quot;/images/bg3.jpg&quot;);
</span><span class='line'>}
</span><span class='line'>body &gt; div {
</span><span class='line'>  background-image: none;
</span><span class='line'>}
</span><span class='line'>body &gt; div &gt; div {
</span><span class='line'>  background-image: none;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>更改LOGO图片可以直接替换/source目录下的favicon.png, 或者将LOGO图片放入source/images中，然后修改source/_includes/head.html，找到favicon.png，修改其路径指向你的图片即可。</p>

<h2>四 总结</h2>


<p>这里介绍了Octopress主题配置的几个主要部分，其他更细节配置如：字体的配置优化、侧边栏的定制、评论插件的配置等，会在后续的博文中更新。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Octopress和Github搭建个人博客（一）：基础环境搭建]]></title>
    <link href="http://glgjing.github.io/blog/2014/12/06/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(%5B%3F%5D-):ji-chu-huan-jing-da-jian/"/>
    <updated>2014-12-06T15:30:04+08:00</updated>
    <id>http://glgjing.github.io/blog/2014/12/06/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-([?]-):ji-chu-huan-jing-da-jian</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://glgjing.github.io/images/1-1.png"></p>

<h2>引言</h2>


<p>如果你只想安安静静的写博客而不被各种博客网站的条条框框限制，如果你想自建博客网站而又不想买域名租服务器等繁琐流程，如果你恰好懂些shell command和git，那么Octopress + Gitbub搭建个人博客是个不错的选择。<a href="http://octopress.org/">Octopress</a>是一个基于<a href="https://github.com/jekyll/jekyll"><code>Jekyll</code></a>博客引擎开发的博客框架，可以很方便的生成静态页面用于在<a href="https://pages.github.com/">Github Pages</a>上展现。官方说法：<code>A blogging framework for hackers</code>。
本文主要介绍在mac下如何利用Octopress和Github搭建个人博客的基础环境。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<!-- more --></p>

<h2>目录</h2>


<ul>
  <li>一 安装基本环境</li>
  <li>二 通过Octopress将博客部署到Github</li>
  <li>三 发布个人博客</li>
  <li>四 其他配置</li>
</ul>


<h2>一 安装基本环境</h2>


<h3>1 安装Ruby</h3>


<p>Octopress运行需要Ruby环境，所以首先需要安装Ruby（<a href=“https://ruby-china.org/wiki/install_ruby_guide”>详细教程</a>）。
首先安装RVM，RVM是用来安装和管理Ruby环境的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -L https://get.rvm.io | bash -s stable</span></code></pre></td></tr></table></div></figure>


<p>然后，载入 RVM 环境，如果新开 Terminal 就不用这么做了，会自动重新载入的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source ~/.rvm/scripts/rvm</span></code></pre></td></tr></table></div></figure>


<p>检查一下是否安装正确</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rvm -v
</span><span class='line'>rvm 1.22.17 (stable) by Wayne E. Seguin &lt;wayneeseguin@gmail.com>, Michal Papis &lt;mpapis@gmail.com> [https://rvm.io/]</span></code></pre></td></tr></table></div></figure>


<p>通过RVM安装Ruby，后面参数为版本号，可以根据版本进行调整。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rvm install 2.0.0</span></code></pre></td></tr></table></div></figure>


<p>完成以后，Ruby就安装好了。RVM 装好以后，需要执行下面的命令将指定版本的 Ruby 设置为系统默认版本。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rvm 2.0.0 --default</span></code></pre></td></tr></table></div></figure>


<p>测试是否设置正确</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ruby -v
</span><span class='line'>ruby 2.0.0p247 (2013-06-27 revision 41674) [x86_64-darwin13.0.0]</span></code></pre></td></tr></table></div></figure>




<h3>2 安装Octopress</h3>


<p>安装Octopress，需要git。所以先确保你的电脑里已经安装了git，在终端输入<code>git —version</code>，如果看到版本号类似<code>git version x.x.x.x&hellip;</code>，证明git环境已经OK，否则请先<a href="http://git-scm.com/">安装git</a>。
git安装完成之后，就可以把Octopress从Github上clone到本地。切换到你想存储Octopress的目录运行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git://github.com/imathis/octopress.git octopress</span></code></pre></td></tr></table></div></figure>


<p>接下来安装依赖项：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd octopuses
</span><span class='line'>gem install bundler
</span><span class='line'>rbenv rehash # If you use rbenv, rehash to be able to run the bundle command
</span><span class='line'>bundle install</span></code></pre></td></tr></table></div></figure>


<p>然后安装默认主题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>




<h2>二 通过Octopress将博客部署到Github</h2>


<p>首先需要在Github上建立一个仓库，Github号称是程序员的Facebook，如果还没有Github账号那就赶紧注册一个吧，仓库名称格式为：<code>username.github.io</code>。该名称就是博客以后的访问地址：<code><a href="http://username.github.io">http://username.github.io</a></code>。仓库创建完成后，需要运行下面命令来将该仓库和Octopress关联起来：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages</span></code></pre></td></tr></table></div></figure>


<p>运行该命令期间会要求你输入仓库url，按照提示格式进行输入即可。该命令的具体功能详细参考<a href="http://octopress.org/docs/deploying/github/"><code>Deploying to Github Pages</code></a>。主要就是设置Github仓库的URL，在本地创建_deploy，该目录存储的就是后续要部署到Github Pages的文件。详细内容会在后面的Octopress目录结构介绍博文中说明。
接下来就可以将博客相关文件部署到Github Pages上了，运行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate
</span><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<p>上述命令主要是根据<code>source</code>目录下的文件，生成博客文件到<code>public</code>目录下，然后将<code>public</code>目录下的文件拷贝到<code>deploy</code>目录，并将<code>deploy</code>目录下的文件commit和push到Github上的<code>username.github.io</code>仓库里的<code>master</code>分支，执行完上述操作就可以访问<code><a href="http://username.github.io">http://username.github.io</a></code>了。有时会需要过几分钟才能打开，是正常现象。
到此为止我们就完成了，博客的基本部署，但一般习惯性的我们会把生成博客文件的原始文件提交到另外一个<code>source</code>分之上，执行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m 'Initial source commit'
</span><span class='line'>git push origin source</span></code></pre></td></tr></table></div></figure>




<h2>三 发布个人博客</h2>


<p>想要新建一个博文，运行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post[“title"]</span></code></pre></td></tr></table></div></figure>


<p>其中title为博客名，该命令会在<code>source/_posts/</code>目录下创建一个名称类似<code>2014-12-5-title.markdown</code>的文件，当然你也可以不用上述命令，手动在该目录下添加该文件，命名需要遵守<code>year-month-day-title.markdown</code>的规则。这个文件就是后续我们写博客的地方，通过<code>rake new_post</code>命令生成的文件会默认带如下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>---
</span><span class='line'>layout: post
</span><span class='line'>title: “title"
</span><span class='line'>date: 2013-08-03 16:36
</span><span class='line'>comments: true
</span><span class='line'>categories:
</span><span class='line'>---</span></code></pre></td></tr></table></div></figure>


<p>到目前为止我们就可以在这里写自己的博客了。博客完成之后，通过如下步骤部署到Github上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate
</span><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<p>在部署到Github之前可以运行如下命令，在浏览器中输入<code><a href="http://localhost:4000/">http://localhost:4000/</a></code> 进行本地预览：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake preview</span></code></pre></td></tr></table></div></figure>


<p>总结一下发布博文的完成流程：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post[’title’]     # 新建博文文件
</span><span class='line'>rake generate              # 将编辑好的博文生成网页
</span><span class='line'>rake preview               # 提交前可以进行本地预览
</span><span class='line'>rake deploy                # 将博文部署到Github上
</span><span class='line'>git commit -a              # 提交本地更改的文件
</span><span class='line'>git push origin source     # 将源文件push到Github的source分支</span></code></pre></td></tr></table></div></figure>


<h2>四 其他配置</h2>


<p>更多的<code>Octopress</code>配置如：侧边栏定制，添加评论插件，字体高亮等等，会在后续博文中<code>持续更新</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows 文件关联浅析]]></title>
    <link href="http://glgjing.github.io/blog/2014/11/29/windows-wen-jian-guan-lian-qian-xi/"/>
    <updated>2014-11-29T23:43:14+08:00</updated>
    <id>http://glgjing.github.io/blog/2014/11/29/windows-wen-jian-guan-lian-qian-xi</id>
    <content type="html"><![CDATA[<h2>引言</h2>


<p>所谓的文件关联就是指系统把指定扩展名的文件自动关联到相应的应用程序，例如.doc默认打开方式是Microsoft Word，当用户双击时就会启动Word打开该文件。windows平台下的文件默认打开方式一直是各大互联网公司的必争之地，如：各种播放器抢媒体文件的默认打开方式，说白了就是为了争入口你抢我的我抢你的，写这篇文章并不是想比谁更流氓，只是简单的总结下windows下的文件关联方式。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<!-- more --></p>

<h2>一 文件关联相关的注册表</h2>


<p>Windows用注册表来保存当前系统的所有文件关联设置，如果想更改文件关联设置，就要在注册表上做文章。首先简单介绍下注册表的各个目录(<a href="http://msdn.microsoft.com/zh-cn/library/cc776231%28v=ws.10%29.aspx">引用自msdn</a>)。</p>

<ul>
    <li><code>HKEY_LOCAL_MACHINE</code>：包含关于本地计算机系统的信息，包括硬件和操作系统数据，如总线类型、系统内存、设备驱动程序和启动控制数据。</li>
    <li><code>HKEY_CURRENT_USER</code>：包含当前以交互方式（与远程方式相反）登录的用户的用户配置文件，包括环境变量、桌面设置、网络连接、打印机和程序首选项。该子树是 HKEY_USERS 子树的别名，它指向 HKEY_USERS\当前用户的安全 ID。</li>
    <li><code>HKEY_CLASSES_ROOT</code>：包含用于各种 OLE 技术和文件类关联数据的信息。如果HKEY_LOCAL_MACHINE\SOFTWARE\Classes 或HKEY_CURRENT_USER\SOFTWARE\Classes 中存在相应的项或值，则在 HKEY_CLASSES_ROOT中会存在某个特定的项或值。如果两处均存在项或值，则 HKEY_CURRENT_USER 版本将是出现在HKEY_CLASSES_ROOT 中的那一个。</li>
    <li><code>HKEY_USERS</code>：包含关于动态加载的用户配置文件和默认配置文件的信息。它包含同时出现在 HKEY_CURRENT_USER中的信息。正在远程访问服务器的用户在服务器上的该项下没有配置文件；他们的配置文件将加载到自己计算机的注册表中。</li>
    <li><code>HKEY_CURRENT_CONFIG</code>：包含在启动时由本地计算机系统使用的硬件配置文件的相关信息。该信息用于配置一些设置，如要加载的设备驱动程序、显示时要使用的分辨率。该子树属于 HKEY_LOCAL_MACHINE 子树，它指向HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Hardware Profiles\Current。</li>
</ul>


<p>与文件关联相关的注册表项主要有以下几项：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HKEY_CURRENT_USER\Software\Classe
</span><span class='line'>HKEY_LOCAL_MACHINE\Software\Classe
</span><span class='line'>HKEY_CLASS_ROOT
</span><span class='line'>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\</span></code></pre></td></tr></table></div></figure>


<p>以下<code>HKEY_LOCAL_MACHINE</code>简称为<code>HKLM</code>，<code>HKEY_CURRENT_USER</code>简称为<code>HKCU</code>，<code>HKEY_CLASSES_ROOT</code>简称为<code>HKCR</code>。
其中<code>HKCU</code>保存了当前用户的文件关联设置，<code>HKLM</code>保存了本机上所有用户的设置，<code>HKCR</code>是上面两个位置下的键值合并，是为了访问方便而建立的视图，<code>&hellip;\FileExts\</code>保存了右键选择“打开方式”改变默认的关联程序。</p>

<h2>二 各项注册表的关联优先级及权限</h2>


<h3>1 关联优先级</h3>


<p><code>&hellip;\FileExts\</code>高于<code>HKCU</code>高于<code>HKLM</code>。（由于<code>HKCR</code>只是为了访问方便而建立的视图，最好只用于读取，若要更改则可以更改<code>HKCU</code>和<code>HKLM</code>下对应的内容即可）</p>

<h3>2 修改权限</h3>


<p>vista以上的windows版本在开启UAC的情况下，更改<code>HKLM</code>本机设置需要管理员权限（提权），更改<code>HKCU</code>当前用户设置不需要提权。</p>

<h3>3 用户双击文件时查找顺序</h3>


<p>首先检查<code>&hellip;\FileExts\</code>，找不到时查找<code>HKCU</code>，最后才是<code>HKLM</code>。因此检查一个文件是否与某个程序关联可以按照这个顺序检查。</p>

<h2>三 如何关联文件</h2>


<p>以apk文件为例，需要在上面所说几个位置下有 .apk 注册表项，该项的默认值对应ProgId，例如命名为ApkFile）。在.apk的相同层级下写入ApkFile注册表项，包含subkey：DefaultIcon和shell\open\command。其中DefaultIcon子项的值为显示的图标，shell\open\command的值为关联的程序。整体结构如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HKEY_CURRENT_USER\Software\Classes
</span><span class='line'>  .apk
</span><span class='line'>      (Default) = ApkFile
</span><span class='line'>  ApkFile
</span><span class='line'>      DefaultIcon
</span><span class='line'>          (Default) = xxx
</span><span class='line'>  shell
</span><span class='line'>      open
</span><span class='line'>          command
</span><span class='line'>              (Default) = xxx.exe %1</span></code></pre></td></tr></table></div></figure>


<p>在更改了文件关联以后，需要调用<code>SHChangeNotify</code>参数为<code>SHCNE_ASSOCCHANGED</code>通知Windows文件关联设置已经改变，否则要下次登录才能看到变化。</p>

<h2>总结</h2>


<p>文件关联实际上就是更改相应的注册表项，更改<code>HKLM</code>下的注册表项对计算机上所有用户都会有影响，但在开启UAC的计算机上需要提权，而且优先级不如<code>HKCU</code>只对当前用户起作用，且不需要提权，而且优先级高于<code>HKLM</code>，所以一般的桌面软件建议更改这一项，至于以什么方式更改（常驻进程定时查询，暴力抢占等等）就看产品了。<code>&hellip;\FileExts\</code>下的UserChoice是用户选择的默认关联方式，由用户指定，不建议更改。</p>
]]></content>
  </entry>
  
</feed>
