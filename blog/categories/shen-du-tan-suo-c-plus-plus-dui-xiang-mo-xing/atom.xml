<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 深度探索c++对象模型 | GLGJing's Blog]]></title>
  <link href="http://glgjing.github.io/blog/categories/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing/atom.xml" rel="self"/>
  <link href="http://glgjing.github.io/"/>
  <updated>2015-11-14T17:53:06+08:00</updated>
  <id>http://glgjing.github.io/</id>
  <author>
    <name><![CDATA[GLGJing]]></name>
    <email><![CDATA[GLGJing@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：类的大小]]></title>
    <link href="http://glgjing.github.io/blog/2015/03/23/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:lei-de-da-xiao/"/>
    <updated>2015-03-23T19:21:06+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/03/23/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:lei-de-da-xiao</id>
    <content type="html"><![CDATA[<p>现在有这样一段代码：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">class</span> <span class="nc">Y</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">X</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">class</span> <span class="nc">Z</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">X</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">class</span> <span class="nc">A</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Y</span><span class="p">,</span> <span class="k">public</span> <span class="n">Z</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>
对 <code>class X、Y、Z、A</code> 进行 <code>sizeof</code> 运算结果是什么呢？如果你心里已经有了答案，不妨看完下面的分析再说。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a></p>

<p><code>C++</code> 初学者常有一个错误的认识，认为一个 <code>class</code> 的大小就是该 <code>class</code> 内所有 <code>non static members</code> 的大小总和。既然是错误的认识，那么实际上就不是或者不单纯是该 <code>class</code> 内所有 <code>non static members</code> 的大小总和。在 <code>c++</code> 对象模型里，一个 <code>class</code> 的大小主要受下面三个方面影响：<!--more--></p>

<h3>1 语言本身特性造成的额外负担</h3>

<p>这里的额外负担主要是受 <code>virtual</code> 特性影响，包括 <code>virtual base class</code> 和 <code>virtual function</code>。在 <code>derived class</code> 中这种额外负担反映在某种形式的指针上，可以是虚函数指针，或者指向虚基类的 <code>subject class</code> 偏移地址等。详细内容可以参考<a href="http://glgjing.github.io/blog/2015/01/03/c-plus-plus-xu-han-shu-qian-xi/">C++ 虚函数浅析</a>。</p>

<h3>2 编译器对特殊情况的优化处理</h3>

<p>例如对于 <code>empty virtual base class</code> 的特殊支持，在 <code>C++</code> 对象模型中一个空的 <code>class</code> 大小为 <code>1 byte</code>，因为编译器为了使每个 <code>object</code> 在内存中能有独一无二的地址，为空 <code>class</code> 安插了一个 <code>char</code>。如果一个空的 <code>class</code> 大小为 <code>0 byte</code>，那么像该 <code>class</code> 的数组 <code>X x[10];</code>，编译器将无法区分每个元素的地址。但是如果 <code>derived class</code> 的大小不为 <code>0</code>，就不需要 <code>base class</code> 的 <code>1 byte</code> 进行内存地址区分，那么如果编译器对这种情况进行了优化的话，就会将该 <code>1 byte</code> 去掉，如果没有还是会继续保留这个额外的 <code>1 byte</code> 空间。</p>

<p>说到编译器对特殊情况的优化，下面这段话比较恰当表述了编译器演化与<code>C++</code>对象模型的关系：</p>

<blockquote><p>编译器之间的潜在差异正说明了 <code>C++</code> 对象模型的演化。这个模型为一般情况提供了解决之道，当特殊情况渐渐被挖掘出来时，种种启发法于是被引入，提供优化的处理。如果成功，启发法于是就提升为普遍的策略，并跨越各种编译器而合并。他被视为标准（虽然他并不被规范为标准），久而久之也就成了语言的一部分。</p></blockquote>

<h3>3 边界调整（Alignment）的影响</h3>

<p>为了数据能够更有效率的在内存中存取，编译器会 <code>class</code> 的内存边界进行调整，在<code>32</code>位机器上通常 <code>alignment</code> 为 <code>4 bytes</code>，以使总线的运输效率最高。</p>

<p>经过上面的分析后，可以看出具体结果要视编译器而定。首先讨论在编译器没有对 <code>empty virtual base class</code> 进行优化的情况，那么：</p>

<ol>
<li><code>class X</code>  的大小应该是 <code>1 byte</code>，该 <code>1 byte</code> 由编译器插入。</li>
<li><code>class Y</code> 和 <code>class Z</code> 的大小相同为 <code>8</code>，包括 <code>4 byte</code> 的 虚基类指针再加上 <code>1 byte</code> 的基类 X的大小，考虑到内存对齐需要补齐 <code>3 byte</code>，所以最终结果为 <code>8 byte</code>。</li>
<li><code>class A</code> 的大小为<code>12 byte</code>，包括 <code>class Y</code> 和 <code>class Z</code> 内的两个 <code>4 byte</code> 虚基类指针共 <code>8 byte</code>，此外由于 <code>X</code> 为虚基类，所以在 <code>A</code> 内只有一个实体，所以应该再加上 <code>X</code> 的 <code>1 byte</code> 和内存对齐额外补齐的 <code>3 byte</code>，共 <code>12 byte</code>。</li>
</ol>


<p>所以最终结果为：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">byte</span>
</span><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">=</span> <span class="mi">8</span> <span class="n">byte</span>
</span><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="mi">12</span> <span class="n">byte</span><span class="err">。</span>
</span></code></pre></td></tr></table></div></figure>
如果编译器对 <code>empty virtual base class</code> 进行了优化，那么 <code>class X</code> 的 <code>1 byte</code> 空间在派生类中将被拿掉，相应的由于内存对齐而引起的 <code>3 byte</code> 也被去掉了，所以最终结果应该是：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">byte</span>
</span><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">=</span> <span class="mi">4</span> <span class="n">byte</span>
</span><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="mi">8</span> <span class="n">byte</span><span class="err">。</span>
</span></code></pre></td></tr></table></div></figure></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：成员变量的初始化列表]]></title>
    <link href="http://glgjing.github.io/blog/2015/03/10/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:cheng-yuan-bian-liang-de-chu-shi-hua-lie-biao/"/>
    <updated>2015-03-10T20:21:00+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/03/10/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:cheng-yuan-bian-liang-de-chu-shi-hua-lie-biao</id>
    <content type="html"><![CDATA[<p>对<code>class members</code>的初始化操作可以放在<code>member initialization list</code>或者<code>construct</code>中进行，但两者之间是有一些区别的，无论是在效率上还是在语法上。</p>

<h2>何时应该使用 initialization list ？</h2>

<p>在语法方面来说，为了程序可以通过编译，下面几种情况必须使用 <code>initialization list</code>：</p>

<ol>
<li>当初始化一个<code>reference member</code>时</li>
<li>当初始化一个<code>const member</code>时</li>
<li>当调用一个<code>base class</code>的<code>constructor</code>，并且它拥有一组参数时</li>
<li>当调用一个<code>member object</code>的<code>constructor</code>，并且它拥有一组参数时</li>
</ol>


<p>至于为什么编译器会有如此要求，看了后面的编译器扩展内容应该就会明白了。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a><!--more--></p>

<p>下面来看一下在效率方面什么时候应该用<code>initialization list</code>。首先看下面一段代码：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Word</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Word</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="k">protected</span><span class="o">:</span>
</span><span class='line'>  <span class="n">String</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">name</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">cnt</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
上面这段代码没有语法错误，程序可以正确的编译执行，但是效率上却不尽人意。首先我们来看编译都干了什么，下面是经过编译器扩展后的<code>constructor</code>伪码：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// C++ 伪码</span>
</span><span class='line'><span class="n">Word</span><span class="o">::</span><span class="n">Word</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 调用 &lt;em&gt;name 的默认构造函数</span>
</span><span class='line'>  <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">name</span><span class="p">.</span><span class="n">String</span><span class="o">::</span><span class="n">String</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">// 生成临时对象</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// 将临时对象 memberwise 拷贝给 &lt;em&gt;name</span>
</span><span class='line'>  <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">name</span><span class="p">.</span><span class="n">String</span><span class="o">::</span><span class="n">Operator</span><span class="o">=</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// 销毁临时对象</span>
</span><span class='line'>  <span class="n">temp</span><span class="p">.</span><span class="n">String</span><span class="o">::~</span><span class="n">String</span><span class="p">();</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
通过编译器扩展后的代码我们可以看到，这种方式的<code>_name</code>初始化效率很差，需要产生一个临时对象，多了一次构造、一次拷贝、一次析构的额外操作。不过通过这种初始化方式对<code>_cnt</code>并没有什么影响。所以改进后的代码应该是这样的：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Word</span><span class="o">::</span><span class="n">Word</span><span class="p">()</span> <span class="o">:</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">name</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
经过编译器扩展后的伪码类似这样：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Word</span><span class="o">::</span><span class="n">Word</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">name</span><span class="p">.</span><span class="n">String</span><span class="o">::</span><span class="n">String</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>member initialization list 到底都做了什么？</h2>

<p>通过上面的分析，可以大概看出<code>initialization list</code>的作用，具体细节是：</p>

<blockquote><p>编译器会一一操作<code>initialization list</code>，以适当的次序在<code>constructor</code>之内安插初始化操作，并且在任何<code>explicit user code</code>之前。</p></blockquote>

<h2>member initialization list 存在的一些风险</h2>

<p>上面所说的<strong>适当次序</strong>是指<code>members</code>在<code>class</code>里的声明次序，而不是在<code>initialization list</code>的排列次序，所以例如下面这段代码就会问题：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Class</span> <span class="n">X</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="o">:</span> <span class="n">j</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">i</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
上面代码的本意是先用<code>val</code>初始化<code>j</code>在用<code>j</code>初始化<code>i</code>，但实际上<code>initialization list</code>的初始化次序是按照<code>members</code>在<code>class</code>里的声明次序，所以会先初始化<code>i</code>，然后才是<code>j</code>，而<code>j</code>一开始并未进行初始化，导致<code>i(j)</code>的结果也无法预料。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：拷贝构造函数]]></title>
    <link href="http://glgjing.github.io/blog/2015/03/06/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:kao-bei-gou-zao-han-shu/"/>
    <updated>2015-03-06T20:47:13+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/03/06/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:kao-bei-gou-zao-han-shu</id>
    <content type="html"><![CDATA[<h2>对象之间的拷贝操作</h2>

<p>发生对象之间拷贝操作的三种情况：</p>

<ol>
<li>用一个 object 对另一个 object 进行初始化操作</li>
<li>当 object 被用作函数参数时</li>
<li>当一个函数返回值为一个 object 时</li>
</ol>


<p>如果一个<code>class</code>明确定义了<code>copy constructor</code>，那么在上述几种情况中会调用该<code>copy constructor</code>，但如果一个<code>class</code>没有定义<code>copy constructor</code>呢？转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a>。<!--more--></p>

<h2>memberwise Initialization</h2>

<p><code>memberwise Initialization</code>的规则是：把每一个内建活继承来的<code>data member</code>从一个<code>object</code>拷贝到另一个<code>object</code>，但并不会拷贝<code>member class object</code>，而是以递归的方式对<code>member class object</code>施行<code>memberwise Initialization</code>。这样的操作是如何完成的呢？</p>

<blockquote><p>从概念上而言，对于一个<code>class X</code>，这个操作是被一个<code>copy constructor</code>实现出来&hellip;</p></blockquote>

<p>之所以是“从概念上”，也就是实际上并不是完全由<code>copy constructor</code>实现的。</p>

<blockquote><p>一个良好的编译器可以为大部分<code>class object</code>产生<code>bitwise copies</code>，因为他们有<code>bitewise copy semantics</code>&hellip;</p></blockquote>

<h2>bitewise copy semantics（位逐次拷贝）</h2>

<p><code>bitewise copy semantics</code>（位逐次拷贝）顾名思义就是把一个<code>object</code>的内容按位拷贝给另一个<code>object</code>。如果在<code>bitewise copy semantics</code>完全可以满足一个<code>class</code>的拷贝操作的情况下，编译器是不会合成<code>copy constructor</code>。但在有些情况下单纯的<code>bitewise copy semantics</code>不能满足拷贝操作，也就是说编译器在一个<code>class</code>不会表现出<code>bitewise copy semantics</code>时，需要合成<code>copy constructor</code>来完成拷贝操作。一个<code>class</code>不会表现出<code>bitewise copy semantics</code>的四种情况：</p>

<ol>
<li>当<code>class</code>内含有<code>member object</code>，而且后者的<code>class</code>声明里有一个<code>copy constructor</code>，不管是<code>class</code>的设计者明确声明的，还是被编译器合成的。</li>
<li>当<code>class</code>继承一个<code>base class</code>，而后者含有一个<code>copy constructor</code>(不管是明确声明的还是编译器合成的)。</li>
<li>当<code>class</code>还有<code>virtual functions</code>时。</li>
<li>当<code>class</code>派生链中有<code>virtual base classes</code>时。</li>
</ol>


<h2>编译器合成 copy constructor 做什么？</h2>

<ol>
<li>调用<code>member object</code>以及<code>base class</code>的<code>copy constructor</code>。</li>
<li>重新设定<code>virtual table</code>的指针。</li>
<li>处理<code>virtual base class subobject</code></li>
</ol>


<h2>总结</h2>

<blockquote><p><code>Default constructor</code> 和 <code>copy constructor</code> 在必要的时候才由编译器产生出来。</p></blockquote>

<p><code>copy constructor</code>的合成原则基本上和<code>default constructor</code>的合成原则一致，具体可以参考：<a href="http://glgjing.github.io/blog/2015/03/03/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:mo-ren-gou-zao-han-shu/">
深度探索C++对象模型：默认构造函数 </a>。主要原则就是：编译器只合成他需要的<code>copy constructor</code>并且只做他需要的操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：默认构造函数]]></title>
    <link href="http://glgjing.github.io/blog/2015/03/03/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:mo-ren-gou-zao-han-shu/"/>
    <updated>2015-03-03T19:36:08+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/03/03/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:mo-ren-gou-zao-han-shu</id>
    <content type="html"><![CDATA[<blockquote><p>默认构造函数在被需要的时候被编译器产生出来。</p></blockquote>

<p>这句话的关键部分是：</p>

<ol>
<li>被谁需要？</li>
<li>什么时候被需要？</li>
<li>做什么事情？</li>
</ol>


<h3>被谁需要？</h3>

<p>编译器为程序构建默认构造函数是因为编译器需要它，而不是因为程序需要它。程序需要什么应该是程序员的责任，应该由程序员提供。举个例子，例如下面这段代码：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Foo</span><span class="o">*</span> <span class="n">pnext</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">foo_bar</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Foo</span> <span class="n">bar</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// 程序需要 bar&amp;rsquo;s members 都被初始化为 0</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">bar</span><span class="p">.</span><span class="n">val</span> <span class="o">||</span> <span class="n">bar</span><span class="p">.</span><span class="n">pnext</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// do something</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>  <br/>
该段程序的正确语意是希望<code>Foo</code>的默认构造函数将<code>val</code>和<code>pnext</code>初始化为 0，但此处编译器并不会为<code>Foo</code>生成默认构造函数，因为这里不满足“需要的时候“这个条件，程序需要不代表编译器需要。后面我们会了解到就算此处编译器为<code>Foo</code>生成了默认构造函数，该默认构造函数也不会对<code>val</code>和<code>pnext</code>进行初始化，具体原因请看“做什么事情？”部分。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a> <!--more--></p>

<h3>什么时候需要？</h3>

<p>上面解释了默认构造函数是被编译器需要的，那么编译器什么时候需要它呢？在下列四种情况下编译器会生成默认构造函数：</p>

<ol>
<li><code>class</code>内包含有<code>default constructor</code>的<code>member object</code>，合成<code>default constructor</code>为了调用<code>member object</code>的<code>default constructor</code>。</li>
<li><code>class</code>继承自含有<code>default constructor</code>的基类，合成<code>default constructor</code>为了调用基类的<code>default constructor</code>。</li>
<li>带有虚函数的<code>class</code>，合成<code>default constructor</code>主要为了初始化vptr（虚函数表指针）。</li>
<li><code>class</code> 有一个及以上的虚基类，合成<code>default constructor</code>主要为了初始化虚基类指针。</li>
</ol>


<p>当满足上面的条件时，编译器会对<code>constructor</code>进行扩展，扩展的规则如下：</p>

<ol>
<li>当<code>class</code>没有定义<code>constructor</code>，编译器会合成<code>default constructor</code>，并加入编译器需要的操作，可能包括调用<code>member object</code>的<code>default constructor</code>，调用基类的<code>default constructor</code>，初始化虚函数表指针及虚基类指针。</li>
<li>当<code>class</code>已经定义了一个或多个<code>constructor</code>时，编译器不会再去合成<code>constructor</code>，但会扩展所有<code>constructor</code>加入编译器需要的操作。</li>
</ol>


<h3>做什么事情？</h3>

<p>从上面的分析中可以看出，默认构造函数所做的事情用一句话可以概括：只执行编译器所需要的行为。所以说即使编译器为<code>Foo</code>生成了默认构造函数，该默认构造函数也不会对<code>val</code>和<code>pnext</code>进行初始化，因为编译器并不需要该行为，这是程序员应该做的事情。</p>

<h3>总结：</h3>

<p>编译器只合成他需要的<code>default constructor</code>并且只做他需要的操作。C++ 新手常见的两个<font color="ff0000">误解</font>：</p>

<blockquote><ol>
<li>任何<code>class</code>如果没有定义<code>default constructor</code>，就会被合成出一个来。</li>
<li>编译器合成出来的<code>default constructor</code>会明确设定<code>class</code> 内每一个<code>data member</code>的默认值。</li>
</ol>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：指针的类型]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/26/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:zhi-zhen-de-lei-xing/"/>
    <updated>2015-02-26T11:27:18+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/26/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:zhi-zhen-de-lei-xing</id>
    <content type="html"><![CDATA[<p>指针对于<code>c++</code>来说是一个非常强大和灵活的特性，他可以支持多态，可以在不同类型之间进行转换，那么指向不同类型的指针在本质上有什么区别呢？转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a>。例如一个类的定义如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">ZooAnimal</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">ZooAnimal</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="o">~</span><span class="n">ZooAnimal</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="p">();</span>
</span><span class='line'><span class="k">protected</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">loc</span><span class="p">;</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>
那么下面几个指针有什么不同：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">ZooAnimal</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">px</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">pi</span><span class="p">;</span>
</span><span class='line'><span class="n">Array</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;*</span> <span class="n">pta</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>
单纯从内存需求上来看，没有什么不同，在 32 位机器上都是 4 个字节，也就是一个机器地址大小。从存储的内容来看，也没什么不同，都是存储一个地址。真正不同的是寻址出来的内容类型不同，也就是说：</p>

<blockquote><p>&ldquo;指针类型&#8221;会教导编译器如何解释某个特定地址中的内存内容及其大小。</p></blockquote>

<p>所以说虽然一个<code>void*</code>指针可以指向一个地址，但是我们无法通过<code>void*</code>来操作该地址所存储的内容，因为编译器无法知道应该用什么方式来解释和操作该内容，这时需要进行类型转换（<code>cast</code>）来告诉编译器如何进行操作。</p>

<blockquote><p>所以，转型(<code>cast</code>)其实是一种编译器指令。大部分情况下它并不改变一个指针所含的真正地址，它只影响“被指出之内存的大小和其内容”的解释方式。</p></blockquote>
]]></content>
  </entry>
  
</feed>
