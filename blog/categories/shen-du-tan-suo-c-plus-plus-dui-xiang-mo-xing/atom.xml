<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 深度探索c++对象模型 | GLGJing's Blog]]></title>
  <link href="http://glgjing.github.io/blog/categories/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing/atom.xml" rel="self"/>
  <link href="http://glgjing.github.io/"/>
  <updated>2015-03-07T18:02:49+08:00</updated>
  <id>http://glgjing.github.io/</id>
  <author>
    <name><![CDATA[GLGJing]]></name>
    <email><![CDATA[GLGJing@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：默认构造函数]]></title>
    <link href="http://glgjing.github.io/blog/2015/03/03/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:mo-ren-gou-zao-han-shu/"/>
    <updated>2015-03-03T19:36:08+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/03/03/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:mo-ren-gou-zao-han-shu</id>
    <content type="html"><![CDATA[<blockquote><p>默认构造函数在被需要的时候被编译器产生出来。</p></blockquote>

<p>这句话的关键部分是：</p>

<ol>
<li>被谁需要？</li>
<li>什么时候被需要？</li>
<li>做什么事情？</li>
</ol>


<h3>被谁需要？</h3>

<p>编译器为程序构建默认构造函数是因为编译器需要它，而不是因为程序需要它。程序需要什么应该是程序员的责任，应该由程序员提供。举个例子，例如下面这段代码：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Foo</span><span class="o">*</span> <span class="n">pnext</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">foo_bar</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Foo</span> <span class="n">bar</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// 程序需要 bar&amp;rsquo;s members 都被初始化为 0</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">bar</span><span class="p">.</span><span class="n">val</span> <span class="o">||</span> <span class="n">bar</span><span class="p">.</span><span class="n">pnext</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// do something</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>  <br/>
该段程序的正确语意是希望<code>Foo</code>的默认构造函数将<code>val</code>和<code>pnext</code>初始化为 0，但此处编译器并不会为<code>Foo</code>生成默认构造函数，因为这里不满足“需要的时候“这个条件，程序需要不代表编译器需要。后面我们会了解到就算此处编译器为<code>Foo</code>生成了默认构造函数，该默认构造函数也不会对<code>val</code>和<code>pnext</code>进行初始化，具体原因请看“做什么事情？”部分。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a> <!--more--></p>

<h3>什么时候需要？</h3>

<p>上面解释了默认构造函数是被编译器需要的，那么编译器什么时候需要它呢？在下列四种情况下编译器会生成默认构造函数：</p>

<ol>
<li><code>class</code>内包含有<code>default constructor</code>的<code>member object</code>，合成<code>default constructor</code>为了调用<code>member object</code>的<code>default constructor</code>。</li>
<li><code>class</code>继承自含有<code>default constructor</code>的基类，合成<code>default constructor</code>为了调用基类的<code>default constructor</code>。</li>
<li>带有虚函数的<code>class</code>，合成<code>default constructor</code>主要为了初始化vptr（虚函数表指针）。</li>
<li><code>class</code> 有一个及以上的虚基类，合成<code>default constructor</code>主要为了初始化虚基类指针。</li>
</ol>


<p>当满足上面的条件时，编译器会对<code>constructor</code>进行扩展，扩展的规则如下：</p>

<ol>
<li>当<code>class</code>没有定义<code>constructor</code>，编译器会合成<code>default constructor</code>，并加入编译器需要的操作，可能包括调用<code>member object</code>的<code>default constructor</code>，调用基类的<code>default constructor</code>，初始化虚函数表指针及虚基类指针。</li>
<li>当<code>class</code>已经定义了一个或多个<code>constructor</code>时，编译器不会再去合成<code>constructor</code>，但会扩展所有<code>constructor</code>加入编译器需要的操作。</li>
</ol>


<h3>做什么事情？</h3>

<p>从上面的分析中可以看出，默认构造函数所做的事情用一句话可以概括：只执行编译器所需要的行为。所以说即使编译器为<code>Foo</code>生成了默认构造函数，该默认构造函数也不会对<code>val</code>和<code>pnext</code>进行初始化，因为编译器并不需要该行为，这是程序员应该做的事情。</p>

<h3>总结：</h3>

<p>编译器只合成他需要的<code>default constructor</code>并且只做他需要的操作。C++ 新手常见的两个<font color="ff0000">误解</font>：</p>

<blockquote><ol>
<li>任何<code>class</code>如果没有定义<code>default constructor</code>，就会被合成出一个来。</li>
<li>编译器合成出来的<code>default constructor</code>会明确设定<code>class</code> 内每一个<code>data member</code>的默认值。</li>
</ol>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：指针的类型]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/26/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:zhi-zhen-de-lei-xing/"/>
    <updated>2015-02-26T11:27:18+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/26/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:zhi-zhen-de-lei-xing</id>
    <content type="html"><![CDATA[<p>指针对于<code>c++</code>来说是一个非常强大和灵活的特性，他可以支持多态，可以在不同类型之间进行转换，那么指向不同类型的指针在本质上有什么区别呢？转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a>。例如一个类的定义如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">ZooAnimal</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">ZooAnimal</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="o">~</span><span class="n">ZooAnimal</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="p">();</span>
</span><span class='line'><span class="k">protected</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">loc</span><span class="p">;</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>
那么下面几个指针有什么不同：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">ZooAnimal</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">px</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">pi</span><span class="p">;</span>
</span><span class='line'><span class="n">Array</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;*</span> <span class="n">pta</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>
单纯从内存需求上来看，没有什么不同，在 32 位机器上都是 4 个字节，也就是一个机器地址大小。从存储的内容来看，也没什么不同，都是存储一个地址。真正不同的是寻址出来的内容类型不同，也就是说：</p>

<blockquote><p>&ldquo;指针类型&#8221;会教导编译器如何解释某个特定地址中的内存内容及其大小。</p></blockquote>

<p>所以说虽然一个<code>void*</code>指针可以指向一个地址，但是我们无法通过<code>void*</code>来操作该地址所存储的内容，因为编译器无法知道应该用什么方式来解释和操作该内容，这时需要进行类型转换（<code>cast</code>）来告诉编译器如何进行操作。</p>

<blockquote><p>所以，转型(<code>cast</code>)其实是一种编译器指令。大部分情况下它并不改变一个指针所含的真正地址，它只影响“被指出之内存的大小和其内容”的解释方式。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：class 与 Struct 的区别]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/18/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:claass-yu-struct-de-qu-bie/"/>
    <updated>2015-02-18T01:32:20+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/18/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:claass-yu-struct-de-qu-bie</id>
    <content type="html"><![CDATA[<p><code>class</code>和<code>struct</code>的区别到底是什么，什么时候应该用<code>struct</code>取代<code>class</code>呢？我想大多数从<code>C</code>转到<code>C++</code>的程序员都会有过这样的困惑。看了<code>Lippman</code>的《深度探索C++对象模型》对该问题的回答之后，我只想说一句：尼玛，只要跟哲学沾边的问题就注定不会有一个简单明了的答案！</p>

<p>首先引用<code>Lippman</code>的一句话：</p>

<blockquote><p>嘿，你知道吗，struct 那个关键字其实没什么用。。。“什么时候应该用 struct 取代 class ？” 答案之一是：当他让一个感觉比较好的时候。</p></blockquote>

<p>大部分<code>C++</code>程序员都知道，如果单纯从语法角度来区分<code>struct</code>和<code>class</code>的话，其实除了以下几点没有什么不同：</p>

<ol>
<li>默认继承权限不同。<code>class</code>的默认继承权限为<code>private</code>，而<code>struct</code>的默认继承权限为<code>public</code>；</li>
<li>成员的默认访问权限不同。<code>class</code>的成员默认是<code>private</code>权限，<code>struct</code>默认是<code>public</code>权限。</li>
<li><code>struct</code>不能作为模板参数，而<code>class</code>可以。</li>
</ol>


<p>那&#8217;Lippman&#8217;为什么不直说呢？偏得之乎者也的提升到精神层次，搞的读者一头雾水。<!--more-->个人觉得主要是语法上的区别只是结果，而为什么这么设计才是<code>Lippman</code>想传达的主要内容。在<code>C</code>所支持的<code>struct</code>和<code>C++</code>所支持的<code>class</code>之间有一个观念上的重要差异，而关键词本身并不提供这种差异。你可能会问如果说为了兼容<code>C</code>而提供了<code>struct</code>关键字，那干嘛还创建<code>class</code>这个关键字，都用<code>struct</code>不行吗？当然行，但是<code>Lippman</code>觉得<code>class</code>更能令人满意（其实就是他自己看着更爽），更能表达出封装和继承的哲学。</p>

<p>所以如果你还在电脑前纠结，请释怀吧！谁让人家是<code>C++</code>形象代言人呢，就是这么任性，就像当面对<code>struct</code>用在<code>template</code>参数时无法被语意分析器<code>parser</code>处理时，你只能迷茫的问为什么，而<code>Lippman</code>可以默默的把<code>parser</code>改掉。最后你可以说<code>struct</code>的保留是为了兼容<code>C</code>；也可以说<code>class</code>的引入更具哲学意义；还可以说他们的共存是为了更多程序员从<code>C</code>迁移到<code>C++</code>部落。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：三种对象模型]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/11/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-san-chong-dui-xiang-mo-xing/"/>
    <updated>2015-02-11T15:57:03+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/11/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-san-chong-dui-xiang-mo-xing</id>
    <content type="html"><![CDATA[<p>现在有一个<code>Point</code>类，声明如下：<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Point</span><span class="p">(</span><span class="kt">float</span> <span class="n">xval</span><span class="p">);</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="o">~</span><span class="n">Point</span><span class="p">();</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kt">float</span> <span class="n">x</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="nf">PointCount</span><span class="p">();</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span> <span class="k">protected</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="n">ostream</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kt">float</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">point_count</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>  <br/>
这个类在机器上是通过什么模型来表示的呢？下面就介绍三种不同的实现方式。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a><!-- more --></p>

<h2>1. 简单对象模型</h2>

<p>简单对象模型名副其实，十分简单。在简单对象模型中，一个 <code>object</code>是由一系列<code>slots</code>组成，每个<code>slot</code>相当于一个指针，指向一个<code>member</code>，<code>memebers</code>按照声明的顺序与<code>slots</code>一一对应，这里的<code>members</code>包括<code>data members</code>和<code>function members</code>。如果将简单对象模型应用在<code>Point Class</code>上，结构图如下： <br/>
<img class="center" src="/images/1-8.png" width="400"></p>

<ul>
<li><p>优点：十分简单，降低了编译器设计的复杂度。</p></li>
<li><p>缺点：空间和时间上的效率降低。由于所有<code>member</code>都对应一个<code>slot</code>指针，所以每个<code>object</code>在空间上额外多出：<code>member's number 乘以指针大小</code>的空间。同时由于访问<code>object</code>的每个<code>member</code>都需要一次<code>slot</code>的额外索引，所以在时间的效率也会降低。</p></li>
</ul>


<h2>2. 表格驱动对象模型</h2>

<p>表格驱动对象模型将<code>member data</code>和<code>member function</code>分别映射成两个表格<code>member data table</code>和<code>function member table</code>，而<code>object</code>本身只存储指向这两个表格的指针。  其中<code>function member table</code>是由一系列的<code>slot</code>组成，每个<code>slot</code>指向一个<code>member function</code>; <code>member data table</code>则直接存储的<code>member data</code>本身。如果将表格驱动对象模型应用在<code>Point Class</code>上，结构图如下：       <br/>
<img class="center" src="/images/1-9.png" width="400"></p>

<ul>
<li>优点：采用两层索引机制，对<code>object</code>变化提供比较好的弹性，在<code>object</code>的<code>nonstatic data member</code>有所改变时，而应用程序代码没有改变，这时是不需要重新编译的。</li>
<li>缺点：空间和时间上的效率降低，具体原因可以参考简单对象模型的缺点分析。</li>
</ul>


<h2>3. C++ 对象模型</h2>

<p>Stroustrup 早期设计的<code>C++</code>对象模型是从简单对象模型改进而来的，并对内存空间和存取时间进行了优化。主要是将<code>nonstatic data members</code>存储在每一个<code>object</code>中，而<code>static data members</code>以及所有的<code>function members</code>被独立存储在所有<code>object</code>之外。对虚函数的支持主要通过以下几点完成的：</p>

<ul>
<li>所有包含虚函数或者继承自有虚函数基类的<code>class</code>都会有一个<code>virtual table</code>，该虚函数表存储着一堆指向该类所包含的虚函数的指针。</li>
<li>每个<code>class</code>所关联的<code>type_info object</code>也是由<code>virtual table</code>存储的，一般会存在该表格的首个<code>slot</code>，<code>type_info</code>用于支持<code>runtime type identification</code> (<code>RTTI</code>)。</li>
</ul>


<p>如果将<code>C++</code>对象模型应用在<code>Point Class</code>上，结构图如下：<br/>
<img class="center" src="/images/2-1.png" width="400"></p>

<ul>
<li>优点：空间和存取效率高，所有<code>static data members</code>以及所有的<code>function members</code>被独立存储在所有<code>object</code>之外，可以减少每个<code>object</code>的大小，而<code>nonstatic data members</code>存储在每一个<code>object</code>中，又提升了存取效率。</li>
<li>缺点：如果应用程序的代码未曾更改，但所用到的<code>class</code>的<code>nonstatic data members</code>有所更改，那么那些代码仍然需要全部重新编译，而前面的表格驱动模型在这方面提供了较大的弹性，因为他多提供了一层间接性，当然是付出了时间和空间上的代价。</li>
</ul>


<h2>在加上继承情况下的对象模型</h2>

<p><code>C++</code>支持单继承、多继承、虚继承，下面来看下<code>base class</code>实体在<code>derived class</code>中是如何被构建的。</p>

<p><code>简单对象模型</code>中可以通过<code>derived class object</code>中的一个<code>slot</code>来存储<code>base class subobject</code>的地址，这样就可以通过该<code>slot</code>来访问<code>base class</code>的成员。这种实现方式的主要缺点是：因为间接性的存储而导致空间和存取时间上存在额外负担；优点是：<code>derived class</code>的结构不会因为<code>base class</code>的改变而改变。</p>

<p><code>表格驱动对象模型</code>中可以利用一个类似<code>base class table</code>的表格来存储所有基类的信息。该表格中存储一系列<code>slot</code>，每个<code>slot</code>存储一个<code>base class</code>的地址。这种实现方式的缺点是：因为间接性的存储而导致空间和存取时间上存在额外负担；优点是：一是所有继承的<code>class</code>都有一致的表现形式（包含一个<code>base table</code>指针，指向基类表）与基类的大小和数目没有关系，二是<code>base class table</code>增加了子类的扩展性，当基类发生改变时，可以通过扩展、缩小或者更改<code>base class table</code>来进行调整。 <br/>
以上两种实现方式都存在一个重要的问题，就是由于间接性而导致的空间和时间上的额外负担，并且该间接性的级数会随着继承的深度而增加。</p>

<p><code>C++</code>   最初采用的继承模型并不采用任何间接性，所有基类的数据直接存储在子类当中，这样在存储结构和访问效率上是最高效的。当然也有缺点：当<code>base class members</code>有任何改变，用到此<code>base class</code>或者<code>derived class</code>的对象必须重新编译。在<code>C++ 2.0</code>引入了<code>virtual base class</code>，需要一些间接性的方式来支持该特性，一般会导入一个<code>virtual base class table</code>或者扩展已有的<code>virtual table</code>，详细会在后面博文讨论。</p>
]]></content>
  </entry>
  
</feed>
