<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 深度探索c++对象模型 | GLGJing's Blog]]></title>
  <link href="http://glgjing.github.io/blog/categories/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing/atom.xml" rel="self"/>
  <link href="http://glgjing.github.io/"/>
  <updated>2015-02-15T18:05:29+08:00</updated>
  <id>http://glgjing.github.io/</id>
  <author>
    <name><![CDATA[GLGJing]]></name>
    <email><![CDATA[GLGJing@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深度探索C++对象模型：三种对象模型]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/11/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-san-chong-dui-xiang-mo-xing/"/>
    <updated>2015-02-11T15:57:03+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/11/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-san-chong-dui-xiang-mo-xing</id>
    <content type="html"><![CDATA[<p>现在有一个<code>Point</code>类，声明如下：<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Point</span><span class="p">(</span><span class="kt">float</span> <span class="n">xval</span><span class="p">);</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="o">~</span><span class="n">Point</span><span class="p">();</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kt">float</span> <span class="n">x</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="nf">PointCount</span><span class="p">();</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span> <span class="k">protected</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="n">ostream</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kt">float</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">point_count</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>  <br/>
这个类在机器上是通过什么模型来表示的呢？下面就介绍三种不同的实现方式。转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a><!-- more --></p>

<h2>1. 简单对象模型</h2>

<p>简单对象模型名副其实，十分简单。在简单对象模型中，一个 <code>object</code>是由一系列<code>slots</code>组成，每个<code>slot</code>相当于一个指针，指向一个<code>member</code>，<code>memebers</code>按照声明的顺序与<code>slots</code>一一对应，这里的<code>members</code>包括<code>data members</code>和<code>function members</code>。如果将简单对象模型应用在<code>Point Class</code>上，结构图如下： <br/>
<img class="center" src="/images/1-8.png" width="400"></p>

<ul>
<li><p>优点：十分简单，降低了编译器设计的复杂度。</p></li>
<li><p>缺点：空间和时间上的效率降低。由于所有<code>member</code>都对应一个<code>slot</code>指针，所以每个<code>object</code>在空间上额外多出：<code>member's number 乘以指针大小</code>的空间。同时由于访问<code>object</code>的每个<code>member</code>都需要一次<code>slot</code>的额外索引，所以在时间的效率也会降低。</p></li>
</ul>


<h2>2. 表格驱动对象模型</h2>

<p>表格驱动对象模型将<code>member data</code>和<code>member function</code>分别映射成两个表格<code>member data table</code>和<code>function member table</code>，而<code>object</code>本身只存储指向这两个表格的指针。  其中<code>function member table</code>是由一系列的<code>slot</code>组成，每个<code>slot</code>指向一个<code>member function</code>; <code>member data table</code>则直接存储的<code>member data</code>本身。如果将表格驱动对象模型应用在<code>Point Class</code>上，结构图如下：       <br/>
<img class="center" src="/images/1-9.png" width="400"></p>

<ul>
<li>优点：采用两层索引机制，对<code>object</code>变化提供比较好的弹性，在<code>object</code>的<code>nonstatic data member</code>有所改变时，而应用程序代码没有改变，这时是不需要重新编译的。</li>
<li>缺点：空间和时间上的效率降低，具体原因可以参考简单对象模型的缺点分析。</li>
</ul>


<h2>3. C++ 对象模型</h2>

<p>Stroustrup 早期设计的<code>C++</code>对象模型是从简单对象模型改进而来的，并对内存空间和存取时间进行了优化。主要是将<code>nonstatic data members</code>存储在每一个<code>object</code>中，而<code>static data members</code>以及所有的<code>function members</code>被独立存储在所有<code>object</code>之外。对虚函数的支持主要通过以下几点完成的：</p>

<ul>
<li>所有包含虚函数或者继承自有虚函数基类的<code>class</code>都会有一个<code>virtual table</code>，该虚函数表存储着一堆指向该类所包含的虚函数的指针。</li>
<li>每个<code>class</code>所关联的<code>type_info object</code>也是由<code>virtual table</code>存储的，一般会存在该表格的首个<code>slot</code>，<code>type_info</code>用于支持<code>runtime type identification</code> (<code>RTTI</code>)。</li>
</ul>


<p>如果将<code>C++</code>对象模型应用在<code>Point Class</code>上，结构图如下：<br/>
<img class="center" src="/images/2-1.png" width="400"></p>

<ul>
<li>优点：空间和存取效率高，所有<code>static data members</code>以及所有的<code>function members</code>被独立存储在所有<code>object</code>之外，可以减少每个<code>object</code>的大小，而<code>nonstatic data members</code>存储在每一个<code>object</code>中，又提升了存取效率。</li>
<li>缺点：如果应用程序的代码未曾更改，但所用到的<code>class</code>的<code>nonstatic data members</code>有所更改，那么那些代码仍然需要全部重新编译，而前面的表格驱动模型在这方面提供了较大的弹性，因为他多提供了一层间接性，当然是付出了时间和空间上的代价。</li>
</ul>


<h2>在加上继承情况下的对象模型</h2>

<p><code>C++</code>支持单继承、多继承、虚继承，下面来看下<code>base class</code>实体在<code>derived class</code>中是如何被构建的。</p>

<p><code>简单对象模型</code>中可以通过<code>derived class object</code>中的一个<code>slot</code>来存储<code>base class subobject</code>的地址，这样就可以通过该<code>slot</code>来访问<code>base class</code>的成员。这种实现方式的主要缺点是：因为间接性的存储而导致空间和存取时间上存在额外负担；优点是：<code>derived class</code>的结构不会因为<code>base class</code>的改变而改变。</p>

<p><code>表格驱动对象模型</code>中可以利用一个类似<code>base class table</code>的表格来存储所有基类的信息。该表格中存储一系列<code>slot</code>，每个<code>slot</code>存储一个<code>base class</code>的地址。这种实现方式的缺点是：因为间接性的存储而导致空间和存取时间上存在额外负担；优点是：一是所有继承的<code>class</code>都有一致的表现形式（包含一个<code>base table</code>指针，指向基类表）与基类的大小和数目没有关系，二是<code>base class table</code>增加了子类的扩展性，当基类发生改变时，可以通过扩展、缩小或者更改<code>base class table</code>来进行调整。 <br/>
以上两种实现方式都存在一个重要的问题，就是由于间接性而导致的空间和时间上的额外负担，并且该间接性的级数会随着继承的深度而增加。</p>

<p><code>C++</code>   最初采用的继承模型并不采用任何间接性，所有基类的数据直接存储在子类当中，这样在存储结构和访问效率上是最高效的。当然也有缺点：当<code>base class members</code>有任何改变，用到此<code>base class</code>或者<code>derived class</code>的对象必须重新编译。在<code>C++ 2.0</code>引入了<code>virtual base class</code>，需要一些间接性的方式来支持该特性，一般会导入一个<code>virtual base class table</code>或者扩展已有的<code>virtual table</code>，详细会在后面博文讨论。</p>
]]></content>
  </entry>
  
</feed>
