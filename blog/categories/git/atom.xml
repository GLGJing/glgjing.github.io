<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Git | GLGJing's Blog]]></title>
  <link href="http://glgjing.github.io/blog/categories/git/atom.xml" rel="self"/>
  <link href="http://glgjing.github.io/"/>
  <updated>2015-03-23T19:36:24+08:00</updated>
  <id>http://glgjing.github.io/</id>
  <author>
    <name><![CDATA[GLGJing]]></name>
    <email><![CDATA[GLGJing@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[为 Git 添加多个公秘钥]]></title>
    <link href="http://glgjing.github.io/blog/2015/02/02/gitru-he-tong-shi-shi-yong-duo-ge-gong-yao/"/>
    <updated>2015-02-02T16:46:55+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/02/02/gitru-he-tong-shi-shi-yong-duo-ge-gong-yao</id>
    <content type="html"><![CDATA[<h2>小引</h2>


<p>最近将博客从 github 上迁移到了国内的 gitcafe，主要原因是在国内的访问速度你懂的。迁移之后发现问题来了，每次连接时 SSH 客户端发送本地私钥到服务端验证，而这个私钥默认是 ~/.ssh/id_rsa 文件，如果只有一个账户，连接的服务器上保存的公钥和发送的私钥自然是配对的。但是我已经有了两个账户了，当然 username 和 email 是完全不同的，如果还是都读取默认的 ~/.ssh/id_rsa 文件，那么 gitcafe 账户的公钥和私钥显然是不匹配的。所以需要为 gitcafe 账户再添加一对公秘钥，并且可以根据账户自动寻找匹配的公秘钥。转载请注明出处<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code><!-- more --></p>

<h2>生成新的 rsa key</h2>


<p>在命令行输入如下命令，将命令中的 <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#89;&#79;&#85;&#82;&#x5f;&#69;&#77;&#x41;&#73;&#76;&#64;&#x59;&#79;&#85;&#82;&#69;&#x4d;&#x41;&#x49;&#76;&#46;&#x43;&#79;&#x4d;">&#x59;&#x4f;&#85;&#x52;&#95;&#x45;&#x4d;&#65;&#x49;&#x4c;&#64;&#89;&#x4f;&#x55;&#x52;&#69;&#x4d;&#x41;&#x49;&#76;&#x2e;&#x43;&#79;&#77;</a> 改为你的 Email 地址。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh-keygen -t rsa -C &ldquo;&lt;a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#89;&#x4f;&#x55;&#x52;&#x5f;&#69;&#77;&#65;&#x49;&#x4c;&#64;&#x59;&#79;&#x55;&#82;&#69;&#x4d;&#x41;&#x49;&#x4c;&#46;&#x43;&#x4f;&#77;">&#89;&#79;&#85;&#x52;&#x5f;&#x45;&#77;&#x41;&#73;&#x4c;&#64;&#89;&#x4f;&#85;&#82;&#69;&#x4d;&#65;&#x49;&#x4c;&#46;&#x43;&#79;&#x4d;&lt;/a>&rdquo; -f ~/.ssh/gitcafe_rsa</span></code></pre></td></tr></table></div></figure>
生成过程中会出现以下信息，按屏幕提示操作输入 passphrase 口令，也可以直接回车设为空。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Generating public/private rsa key pair.
</span><span class='line'>Enter passphrase (empty for no passphrase):
</span><span class='line'>Enter same passphrase again:
</span><span class='line'>Your identification has been saved in /Users/username/.ssh/gitcafe_rsa.
</span><span class='line'>Your public key has been saved in /Users/username/.ssh/gitcafe_rsa.pub.
</span><span class='line'>The key fingerprint is:
</span><span class='line'>15:81:d2:7a:c6:6c:0f:ec:b0:b6:d4:18:b8:d1:41:48 &lt;a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#89;&#x4f;&#85;&#82;&#95;&#x45;&#77;&#x41;&#73;&#x4c;&#x40;&#89;&#79;&#x55;&#82;&#69;&#77;&#65;&#x49;&#76;&#46;&#67;&#79;&#x4d;">&#89;&#x4f;&#x55;&#82;&#95;&#69;&#77;&#65;&#73;&#76;&#64;&#89;&#79;&#85;&#82;&#69;&#x4d;&#x41;&#73;&#x4c;&#x2e;&#67;&#x4f;&#x4d;&lt;/a></span></code></pre></td></tr></table></div></figure>
此时在 ~/.ssh/ 目录下会生成 gitcafe_rsa 和 gitcafe_rsa.pub两个文件。</p>

<h2>配置新的 rsa key</h2>


<p>在 SSH 用户配置文件 ~/.ssh/config 中指定对应服务所使用的公秘钥名称，如果没有 config 文件的话就新建一个，并输入以下内容：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Host gitcafe.com www.gitcafe.com
</span><span class='line'>  IdentityFile ~/.ssh/gitcafe</span></code></pre></td></tr></table></div></figure>
然后将 gitcafe_rsa.pub 文件中的内容复制到 gitcafe 的 SSH 公钥中，具体参见<a href="https://gitcafe.com/GitCafe/Help/wiki/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AE%20Git">这里</a>，这样就完成了新的公秘钥配置。可以运行下面的命令进行测试
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Host gitcafe.com www.gitcafe.com
</span><span class='line'>ssh -T &lt;a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#103;&#x69;&#116;&#64;&#x67;&#105;&#116;&#x63;&#97;&#x66;&#101;&#x2e;&#x63;&#111;&#x6d;">&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#x63;&#x61;&#x66;&#x65;&#46;&#99;&#111;&#109;&lt;/a></span></code></pre></td></tr></table></div></figure>
如果连接成功的话，会出现以下信息。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Host gitcafe.com www.gitcafe.com
</span><span class='line'>Hi USERNAME! You&rsquo;ve successfully authenticated, but GitCafe does not provide shell access.</span></code></pre></td></tr></table></div></figure></p>

<h2>总结</h2>


<p>这里以 gitcafe 为例讲述了如何为git添加多个公秘钥，其他的公秘钥添加方法基本类似。参考：<a href="https://gitcafe.com/GitCafe/Help/wiki/%E5%A6%82%E4%BD%95%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%85%AC%E7%A7%98%E9%92%A5">如何同时使用多个公秘钥</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 清除未跟踪文件]]></title>
    <link href="http://glgjing.github.io/blog/2015/01/09/git-qing-chu-wei-gen-zong-wen-jian/"/>
    <updated>2015-01-09T16:34:45+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/01/09/git-qing-chu-wei-gen-zong-wen-jian</id>
    <content type="html"><![CDATA[<p>在利用<code>git</code>工作时，工程目录下经常会出现一些未跟踪文件，虽然<code>git</code>支持通过<code>.gitingore</code>文件添加一些忽略文件类型和文件目录。但有时需要清理一些临时文件和自动生成的文件，手动删除显得太麻烦，这时你可以利用<code>git clean</code>命令来帮你完成这项操作。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<code>git clean</code>命令支持以下参数：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean [-d] [-f] [-i] [-n] [-q] [-e &lt;pattern>] [-x | -X] [&ndash;] &lt;path>&hellip;</span></code></pre></td></tr></table></div></figure>
其中几个主要参数用法如下：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-d   # 删除未跟踪目录以及目录下的文件，如果目录下包含其他git仓库文件，并不会删除（-dff可以删除）。
</span><span class='line'>-f   # 如果 git cofig 下的 clean.requireForce 为true，那么clean操作需要-f(&ndash;force)来强制执行。
</span><span class='line'>-i   # 进入交互模式
</span><span class='line'>-n   # 查看将要被删除的文件，并不实际删除文件</span></code></pre></td></tr></table></div></figure>
通过以上几根参数组合，基本上可以满足删除未跟踪文件的需求了。例如在删除前先查看有哪些文件将被删除运行：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean -n</span></code></pre></td></tr></table></div></figure>
想删除当前工作目录下的未跟踪文件，但不删除文件夹运行（如果<code>clean.requireForce</code>为<code>false</code>可以不加<code>-f</code>选项）：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean -f</span></code></pre></td></tr></table></div></figure>
想删除当前工作目录下的未跟踪文件以及文件夹运行：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean -df</span></code></pre></td></tr></table></div></figure></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 修改提交历史]]></title>
    <link href="http://glgjing.github.io/blog/2015/01/06/git-xiu-gai-ti-jiao-li-shi/"/>
    <updated>2015-01-06T11:14:40+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/01/06/git-xiu-gai-ti-jiao-li-shi</id>
    <content type="html"><![CDATA[<h2>引言</h2>


<p>在使用git进行工作时，经常会碰到想要修改本地提交记录（还没有push到远程仓库）的情况。例如这样一个场景：你接到一个任务，这个任务可能需要一个星期的开发时间，于是你从<code>master</code>分之上运行<code>git checkout -b new_branch</code>命令，<code>checkout</code>到<code>new_branch</code>分之上进行该任务的开发，在开发的过程中向<code>new_branch</code>分之提交了多个<code>commit</code>，然后发现有些代码不是很合理，于是又更改代码提交新的<code>commit</code>，反反复复终于完成了该任务的开发，是时候提交review并合并到<code>master</code>分之上了，但是你发现提交记录非常混乱，并不利于同事review，而且你的同事也不关心你的具体修改过程，他们只想看到最终的实现，此时问题来了，如果你把所有的<code>commit</code>合并成一个大<code>commit</code>，虽然你的同事可以直接看到最终代码，但你的各个模块都混在一起提交，很难按模块单独进行review并发现问题；如果你直接提交review，你的同事就不得不把你的所有提交历史都review一遍，包括一些实际上已经在后面提交中被你修改掉的代码，脾气好的估计内心一万只草泥马奔过，脾气不好的保证不打死你！当然<code>git</code>是不可能考虑不到这种情况的，扯了这么多，下面就来看一下如何修改<code>git</code>的提交历史。转载请注明出处：<code><a href="http://glgjing.github.io/">http://glgjing.github.io/</a></code>。<!-- more --></p>

<h2>一 修改最近一次提交记录</h2>


<h3>1 只修改提交说明</h3>


<p>修改最近一次提交是非常常见的需求，如果只想更改最近一次的提交说明是非常方便的，只需输入如下命令：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git commit —amend</span></code></pre></td></tr></table></div></figure>
然后你就会进入文本编辑器，输入你想要的内容，保存并退出即可。</p>

<h3>2 添加新的更改</h3>


<p>如果你完成提交后又想修改被提交的快照，增加或者修改其中的文件，过程基本和上面一样。先运<code>git add</code>命令，将修改的文件添加到缓存区,然后运行<code>git commit —amend</code>命令，该命令会获取你当前的暂存区的内容一并提交到最后一次<code>commit</code>。例如：新加了一个文件new_file.cpp，想要合并到最后一次提交，过程如下：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add new_file.cpp
</span><span class='line'>git commit —amend</span></code></pre></td></tr></table></div></figure>
也可以直接运行下面的命令，不过要小心，不要提交了多余的文件。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git commit -a —amend</span></code></pre></td></tr></table></div></figure></p>

<h3>3 将文件从本次提交中移除</h3>


<p>如果想把已经<code>commit</code>的文件从这次<code>commit</code>移除的话，可以运行如下命令：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git reset [—soft] HEAD~1 # —soft可加可不加，默认就是soft选项
</span><span class='line'>git checkout —filename # 要从本次提交移除的文件名
</span><span class='line'>git commit -m “new commit"</span></code></pre></td></tr></table></div></figure></p>

<h2>二 修改多个提交</h2>


<p>要修改历史中更早的提交，你必须采用更复杂的工具。<code>git</code>没有一个修改历史的工具，但是你可以使用<code>rebase</code>工具来衍合一系列的提交到它们原来所在的<code>HEAD</code>上。依靠这个交互式的<code>rebase</code>工具，你就可以停留在每一次提交后，如果你想修改或改变说明、增加文件或任何其他事情。你可以通过给<code>git rebase -i</code>命令以交互方式进行<code>rebase</code>。例如，你想修改最近三次的提交说明，或者其中任意一次，你必须给<code>git rebase -i</code>提供一个参数，指明你想要修改的提交的父提交。例如<code>HEAD~3</code>是指从<code>HEAD</code>指针到<code>HEAD+3</code>的位置，也就是最近第4次提交。所以想修改最近3次提交，你需要指明第3次提交的父提交（第4次提交）即<code>HEAD~3</code>。运行命令
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git rebase -i HEAD~3</span></code></pre></td></tr></table></div></figure>
再次提醒这是一个衍合命令，也就是<code>HEAD~3</code>到<code>HEAD</code>范围内的每一次提交都会被重写，不管你是否修改提交说明<code>SHA-1</code>的值都会发生变化。<font color="red">所以千万不要涵盖你已经推送到中心服务器的提交。</font>这么做会使其他开发者产生混乱，因为你提供了同样变更的不同版本。运行该命令后进入交互界面，类似：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>Rebase f77f585..fecb551 onto f77f585&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>#&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>Commands:&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>p, pick = use commit&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>r, reword = use commit, but edit the commit message&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>e, edit = use commit, but stop for amending&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>s, squash = use commit, but meld into previous commit&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>f, fixup = like &ldquo;squash&rdquo;, but discard this commit&rsquo;s log message&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>x, exec = run command (the rest of the line) using shell&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>#&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>These lines can be re-ordered; they are executed from top to bottom.&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>If you remove a line here THAT COMMIT WILL BE LOST.&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>However, if you remove everything, the rebase will be aborted.&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>Note that empty commits are commented out&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure>
根据命令提示，就可以进行历史更改了。很重要的一点是你得注意这些提交的顺序与你通常通过<code>log</code>命令看到的是相反的。如果你运行<code>log</code>，你会看到下面这样的结果：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick fecb551 Init the view model</span></code></pre></td></tr></table></div></figure></p>

<h3>1 修改指定提交</h3>


<p>例如：只修改最近第3次提交说明可以进行如下更改：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reword fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>&hellip;</span></code></pre></td></tr></table></div></figure>
保存并退出编辑器，<code>rebase</code>命令在衍合到第3次提交时会进入提交说明编辑页面，在此进行编辑新的提交说明，保存并退出即可，<code>rebase</code>命令继续进行直至完成全部衍合操作。如果你不仅想要修改提交说明，还要更改提交，可以进行如下更改：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>edit fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>&hellip;</span></code></pre></td></tr></table></div></figure>
保存并退出编辑器，<code>rebase</code>命令在衍合到第三次提交时会等待你提交新的更改，并提示你修改完成后运行<code>git commit &ndash;amend</code>命令，然后运行<code>git rebase &ndash;continue</code>继续进行<code>rebase</code>直至完成全部衍合。</p>

<h3>2 重排提交</h3>


<p>你也可以使用<code>git rebase -i</code>命令对提交历史彻底重排或删除提交。例如你想删除&#8221;Update the version&#8221;这个提交，并且修改其他两次提交的顺序，可以将
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>pick bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>&hellip;</span></code></pre></td></tr></table></div></figure>
改为：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick bc5cd9d Add new method
</span><span class='line'>pick fecb551 Init the view model</span></code></pre></td></tr></table></div></figure>
然后保存并退出编辑器，此时<code>rebase</code>命令会先应用bc5cd9d (Add new method)，然后应用 fecb551 (Init the view model)bb199a0 Update the version这次提交。
然后保存并退出编辑器，此时<code>rebase</code>命令会先应用bc5cd9d (Add new method)，然后应用 fecb551 (Init the view model)，接着停止。执行完上诉操作，你已经修改了这些提交的顺序，并且删除了bb199a0 (Update the version)这次提交。</p>

<h3>3 合并提交</h3>


<p><code>git rebase -i</code>命令还可以将一系列提交合并成一个提交。从上面的脚本提示中可以看到<code>s, squash = use commit, but meld into previous commit</code>提示。如果用<code>squash</code>修饰提交就可以进行提交之间的合并，例如可以将脚本修改成这样：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>squash bb199a0 Update the version
</span><span class='line'>squash bc5cd9d Add new method</span></code></pre></td></tr></table></div></figure>
保存并退出编辑器，<code>rebase</code>命令会应用全部三次变更然后进入编辑器来归并三次提交说明。当你保存之后，你就拥有了一个包含前三次提交的全部变更的单一提交。</p>

<h3>4 拆分提交</h3>


<p>拆分提交实际上就是撤销一次提交，然后分多次进行重新提交。例如你想将三次提交中的中间一次拆分。将&#8221;Update the version&#8221;拆分成两次提交：&#8221;Update the version1&#8221;和&#8221;Update the version2&#8221;，可以进行如下修改：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick fecb551 Init the view model
</span><span class='line'>edit bb199a0 Update the version
</span><span class='line'>pick bc5cd9d Add new method</span></code></pre></td></tr></table></div></figure>
当<code>rebase</code>到bb199a0时，会进入等待你提交新<code>commit</code>的状态，这时看可以运行<code>git reset HEAD^</code>对当前提交进行重置，然后分别运行<code>git add</code>命令添加想要提交的文件，分别进行<code>git commit</code>，最后运行<code>git rebase &ndash;continue</code>完成所有衍合。整体过程如下：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git reset HEAD^
</span><span class='line'>git add file1
</span><span class='line'>git commit -m &lsquo;Update the version1&rsquo;
</span><span class='line'>git add file2
</span><span class='line'>git commit -m &lsquo;Update the version2&rsquo;
</span><span class='line'>git rebase &ndash;continue</span></code></pre></td></tr></table></div></figure>
执行完上诉操作，提交历史看起来就像这样了：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1c002dd Add new method
</span><span class='line'>9b29157 Update the version2
</span><span class='line'>35cfb2b Update the version1
</span><span class='line'>f3cc40e Init the view model</span></code></pre></td></tr></table></div></figure>
<font color="red">再次提醒，这会修改你列表中的提交的<code>SHA</code>值，所以请确保这个列表里不包含你已经推送到共享仓库的提交。</font></p>
]]></content>
  </entry>
  
</feed>
