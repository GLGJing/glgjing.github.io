<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Widget | GLGJing's Blog]]></title>
  <link href="http://glgjing.github.io/blog/categories/widget/atom.xml" rel="self"/>
  <link href="http://glgjing.github.io/"/>
  <updated>2015-11-12T16:22:02+08:00</updated>
  <id>http://glgjing.github.io/</id>
  <author>
    <name><![CDATA[GLGJing]]></name>
    <email><![CDATA[GLGJing@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android 开发之实时更新 App Widget]]></title>
    <link href="http://glgjing.github.io/blog/2015/11/12/android-kai-fa-zhi-shi-shi-geng-xin-app-widget/"/>
    <updated>2015-11-12T16:14:50+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/11/12/android-kai-fa-zhi-shi-shi-geng-xin-app-widget</id>
    <content type="html"><![CDATA[<p><a href="http://glgjing.github.io/blog/2015/11/05/android-kai-fa-zhi-app-widget-xiang-jie/">Android 开发之 App Widget 详解</a>中说到 updatePeriodMills 定义了 Widget 的刷新频率，但是出于节约用户电量的考虑，Android 系统默认最小更新周期是 30 分钟，也就是说：如果您的程序需要实时更新数据，设置这个更新周期是 2 秒，那么您的程序是不会每隔 2 秒就收到更新通知的，而是要等到 30 分钟以上才可以，要想实时的更新 Widget，一般可以采用 Service 和 AlarmManager 对 Widget 进行更新。</p>

<h3>利用 Service 更新 Widget</h3>

<p>在 onUpdate() 方法中启动 Service：</p>

<pre><code class="java">public class MyWidgetProvider extends AppWidgetProvider {

  @Override
  public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
    context.startService(new Intent(context, WidgetService.class));
  }
}
</code></pre>

<p>在 Service 中对 Widget 进行更新，这里 Service 利用 AlarmManager 每隔一段时间进行自启，防止 Service 被系统 Kill 掉后无法对 Widget 进行更新，转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a>。</p>

<!-- more -->


<pre><code class="java">public class WidgetService extends Service {
  private static final int ALARM_DURATION  = 5 * 60 * 1000; // service 自启间隔
  private static final int UPDATE_DURATION = 10 * 1000;     // Widget 更新间隔
  private static final int UPDATE_MESSAGE  = 1000;

  private UpdateHandler updateHandler; // 更新 Widget 的 Handler

  @Override
  public IBinder onBind(Intent intent) {
    return null;
  }

  @Override
  public int onStartCommand(Intent intent, int flags, int startId) {
    // 每个 ALARM_DURATION 自启一次
    AlarmManager manager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
    Intent alarmIntent = new Intent(getBaseContext(), WidgetService.class);
    PendingIntent pendingIntent = PendingIntent.getService(getBaseContext(), 0,
      alarmIntent, PendingIntent.FLAG_UPDATE_CURRENT);

    manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,
      SystemClock.elapsedRealtime() + ALARM_DURATION, pendingIntent);

    return START_STICKY;
  }

  @Override
  public void onCreate() {
    super.onCreate();

    Message message = updateHandler.obtainMessage();
    message.what = UPDATE_MESSAGE;
    updateHandler = new UpdateHandler();
    updateHandler.sendMessageDelayed(message, UPDATE_DURATION);
  }

  private void updateWidget() {
    // 更新 Widget
    RemoteViews remoteViews = new RemoteViews(getApplicationContext().getPackageName(), R.layout.widget);
    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
    appWidgetManager.updateAppWidget(new ComponentName(context, MyWidgetProvider.class), remoteViews);

    // 发送下次更新的消息
    Message message = updateHandler.obtainMessage();
    message.what = UPDATE_MESSAGE;
    updateHandler.sendMessageDelayed(message, UPDATE_DURATION);
  }

  protected final class UpdateHandler extends Handler {

    @Override
    public void handleMessage(Message msg) {
      switch (msg.what) {
        case UPDATE_MESSAGE:
          updateWidget();
          break;
        default:
          break;
      }
    }
  }
}
</code></pre>

<h3>Service + AlarmManager 更新 Widget</h3>

<p>上面是利用 Service 的内部消息循环更新 Widget，也可以利用 AlarmManager 来定时触发更新。在 onUpdate() 中启动 Alarm，通过 AlarmManager 来循环启动 Service，剩下的原理基本就是一样的了。记得在 onDisabled() 取消掉 Alarm。</p>

<pre><code class="java">public class MyWidgetProvider extends AppWidgetProvider {
  private static final int UPDATE_DURATION = 10 * 1000; // Widget 更新间隔

  private PendingIntent pendingIntent = null; 

  @Override
  public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
    AlarmManager manager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
    Intent alarmIntent = new Intent(getBaseContext(), WidgetService.class);
    if (pendingIntent == null) {
      pendingIntent = PendingIntent.getService(getBaseContext(), 0,
        alarmIntent, PendingIntent.FLAG_UPDATE_CURRENT);
    }

    manager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,
      SystemClock.elapsedRealtime(), UPDATE_DURATION, pendingIntent);
  }

  @Override  
  public void onDisabled(Context context) {
    AlarmManager manager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);  
    manager.cancel(pendingIntent);
  }
}
</code></pre>

<p>MyService 源码：</p>

<pre><code class="java">public class MyService extends Service  
{
  @Override  
  public int onStartCommand(Intent intent, int flags, int startId) {  
    buildUpdate();  
    return super.onStartCommand(intent, flags, startId);  
  }  

  private void buildUpdate() {  
    RemoteViews view = new RemoteViews(getPackageName(), R.layout.widget);  

    RemoteViews remoteViews = new RemoteViews(getApplicationContext().getPackageName(), R.layout.widget);
    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
    appWidgetManager.updateAppWidget(new ComponentName(context, MyWidgetProvider.class), remoteViews); 
  }
}
</code></pre>

<h3>添加自定义 View</h3>

<p>更新 Widget 是通过 RemoteViews 实现的，而 RemoteViews 支持的 View 有限，详细参考<a href="http://developer.android.com/intl/zh-cn/guide/topics/appwidgets/index.html#CreatingLayout">这里</a>，如果想要在 Widget 中使用自定义 View，可以通过一下方式实现：</p>

<pre><code class="java">RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.widget);

MyCustomView customView = new MyCustomView(context);
customView.measure(width, height);
customView.layout(0, 0, width, height);
Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
customView.draw(new Canvas(bitmap));
remoteViews.setImageViewBitmap(R.id.bitmap, bitmap);
</code></pre>

<p>实际上就是将自定义 View 在 Bitmap 上绘制，然后通过 ImageView 进行展现。</p>

<h3>处理点击事件</h3>

<p>RemoteViews 可以设置 setOnClickPendingIntent，通过 PendingIntent 来处理点击事件：</p>

<pre><code class="java">// 设置 button 事件为启动一个 Activity
Intent intent1 = new Intent("open_widget_activity");
PendingIntent pendingIntent1 = PendingIntent.getActivity(context, 0, intent1, 0);
remoteViews.setOnClickPendingIntent(R.id.button1, pendingIntent1);

// 设置 button 事件为发送一个广播
Intent intent2 = new Intent("send_broadcast");
PendingIntent pendingIntent2 = PendingIntent.getBroadcast(context, 0, intent2, 0);
remoteViews.setOnClickPendingIntent(R.id.button2, pendingIntent2);
</code></pre>

<p>然后需要处理事件的 Activity 或者 Receiver 接受对应的 Intent 即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 开发之 App Widget 详解]]></title>
    <link href="http://glgjing.github.io/blog/2015/11/05/android-kai-fa-zhi-app-widget-xiang-jie/"/>
    <updated>2015-11-05T13:08:53+08:00</updated>
    <id>http://glgjing.github.io/blog/2015/11/05/android-kai-fa-zhi-app-widget-xiang-jie</id>
    <content type="html"><![CDATA[<h3>简介</h3>

<p>App Widget：应用程序窗口小部件，微型的应用程序视图，它可以被嵌入到其它应用程序中，比如桌面，并接收周期性的更新。你可以通过一个 App Widget Provider 来发布一个 Widget。可以容纳 Widget 的应用叫做 App Widget Host，详细参考<a href="http://developer.android.com/intl/zh-cn/guide/topics/appwidgets/index.html">App Widgets| Android Developers</a>，转载请注明出处：<a href="http://glgjing.github.io/">http://glgjing.github.io/</a>。</p>

<h3>创建一个 App Widget 的主要步骤</h3>

<ol>
<li>在 AndroidManifest 中声明 App Widget</li>
<li>在 xml 目录定义 App Widget 的初始化 xml 文件</li>
<li>实现 Widget 具体布局的 Layout xml。</li>
<li>继承 AppWidgetProvider 类，实现具体的 Widget 业务逻辑。</li>
</ol>


<h3>在 AndroidManifest 中声明 App Widget</h3>

<pre><code class="xml">&lt;receiver android:name=".sample.MyWidgetProvider" &gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE" /&gt;
    &lt;/intent-filter&gt;
    &lt;meta-data android:name="android.appwidget.provider"
               android:resource="@xml/appwidget_provider"/&gt;
&lt;/receiver&gt;
</code></pre>

<!-- more -->


<p><code>&lt;receiver&gt;</code>的 android:name 属性声明的就是 Widget 所用的 AppWidgetProvider 类，并且<code>&lt;intent-filter&gt;</code>中必须要包含 APPWIDGET_UPDATE 这个 <code>&lt;action&gt;</code>，所有 Widget 的 broadcast 都是通过这个 filter 来接收的。</p>

<p><code>&lt;meta-data&gt;</code> 声明了 Widget 的 AppWidgetProviderInfo 对应的资源 xml 的位置，用的是 xml 目录下的 appwidget_provider.xml。这里需要简单介绍下 AppWidgetProviderInfo 类，该类是用来描述 Widget 的 meta 信息，包括 Widget 的 xml 布局文件、刷新频率、最小宽高等等，而这些信息正是通过上述 xml 的<code>&lt;appwidget-provider&gt;</code> 标签来描述的。</p>

<h3>在 xml 目录定义 App Widget 的初始化 xml 文件</h3>

<p>前面所说的用来描述 AppWidgetProviderInfo 的 xml 定义如下：</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;appwidget-provider 
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:minWidth="200dp"
    android:minHeight="50dp"
    android:updatePeriodMillis="86400000"
    android:previewImage="@drawable/app_icon"
    android:initialLayout="@layout/widget"
    android:configure="com.example.android.ExampleAppWidgetConfigure"
    android:resizeMode="horizontal|vertical"
    android:widgetCategory="home_screen|keyguard"/&gt;
</code></pre>

<p><strong>minWidth</strong> &amp; <strong>minHeight</strong>：定义了 Widget 的最小宽高，当 minWidth 和 minHeight 不是桌面 cell 的整数倍时，Widget 的宽高会被阔至与其最接近的 cells 大小。Google 官方给出了一个大致估算 minWidth &amp; minHeight 的公式，根据 Widget 所占的 cell 数量来计算宽高：<code>70 × n − 30</code>，n 是所占的 cell 数量。  <br/>
<strong>updatePeriodMillis</strong>：定义了 Widget 的刷新频率，也就是 App Widget Framework 多久请求一次 AppWidgetProvider 的 onUpdate() 回调函数。该时间间隔并不保证精确，出于节约用户电量的考虑，Android 系统默认最小更新周期是 30 分钟，也就是说：如果您的程序需要实时更新数据，设置这个更新周期是 2 秒，那么您的程序是不会每隔 2 秒就收到更新通知的，而是要等到 30 分钟以上才可以，要想实时的更新 Widget，一般可以采用 Service 和 AlarmManager 对 Widget 进行更新。   <br/>
<strong>previewImage</strong>：当用户选择添加 Widget 时的预览图片。如果该属性没有定义，则展示 application 的 launcher icon。<font color="#B72712">该属性是在 3.0 以后引入的。</font>    <br/>
<strong>initialLayout</strong>：Widget 的布局 Layout 文件。    <br/>
<strong>configure</strong>：定义了用户在添加 Widget 时弹出的配置页面的 Activity，用户可以在此进行 Widget 的一些配置，该 Activity 是可选的，如果不需要可以不进行声明。   <br/>
<strong>resizeMode</strong>：Widget 在水平和垂直方向是否可以调整大小，值可以为：horizontal（水平方向可以调整大小），vertical（垂直方向可以调整大小），none（不可以调整大小），也可以 horizontal|vertical 组合表示水平和垂直方向均可以调整大小。    <br/>
<strong>widgetCategory</strong>：表示 Widget 可以显示的位置，包括 home_screen（桌面），keyguard（锁屏），keyguard 属性需要 5.0 或以上 Android 版本才可以。    <br/>
其它更多详细属性可以参考 <a href="http://developer.android.com/intl/zh-cn/reference/android/appwidget/AppWidgetProviderInfo.html">AppWidgetProviderInfo</a>。</p>

<h3>继承 AppWidgetProvider 类</h3>

<p>AppWidgetProvider 继承自 BroadcastReceiver，内部逻辑非常简单，就是在 onReceive() 中处理 Widget 相关的广播事件（ACTION_APPWIDGET_UPDATE, ACTION_APPWIDGET_DELETED, ACTION_APPWIDGET_ENABLED, ACTION_APPWIDGET_DISABLED, ACTION_APPWIDGET_OPTIONS_CHANGED）分发到各个回调函数中（onUpdate(), onDeleted(), onEnabled(), onDisabled, onAppWidgetOptionsChanged()）。</p>

<p><strong>onUpdate()：</strong>是最重要的回调函数，根据 updatePeriodMillis 定义的定期刷新操作会调用该函数，此外当用户添加 Widget 时
也会调用该函数，可以在这里进行必要的初始化操作。但如果在<code>&lt;appwidget-provider&gt;</code>中声明了 android:configure 的 Activity，在用户添加 Widget 时，不会调用 onUpdate()，需要由 configure Activity 去负责去调用 AppWidgetManager.updateAppWidget() 完成 Widget 更新，后续的定时更新还是会继续调用 onUpdate() 的。    <br/>
<strong>onDeleted()：</strong>当 Widget 被删除时调用该方法。   <br/>
<strong>onEnabled()：</strong>当 Widget 第一次被添加时调用，例如用户添加了两个你的 Widget，那么只有在添加第一个 Widget 时该方法会被调用。所以该方法比较适合执行你所有 Widgets 只需进行一次的操作。   <br/>
<strong>onDisabled()：</strong>与 onEnabled 恰好相反，当你的最后一个 Widget 被删除时调用该方法，所以这里用来清理之前在 onEnabled() 中进行的操作。    <br/>
<strong>onAppWidgetOptionsChanged()：</strong>当 Widget 第一次被添加或者大小发生变化时调用该方法，可以在此控制 Widget 元素的显示和隐藏。</p>

<p>示例代码：</p>

<pre><code class="java">public class ExampleAppWidgetProvider extends AppWidgetProvider {

    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
        final int N = appWidgetIds.length;

        // Perform this loop procedure for each App Widget that belongs to this provider
        for (int i=0; i&lt;N; i++) {
            int appWidgetId = appWidgetIds[i];

            // Create an Intent to launch ExampleActivity
            Intent intent = new Intent(context, ExampleActivity.class);
            PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0);

            // Get the layout for the App Widget and attach an on-click listener
            // to the button
            RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.appwidget_provider_layout);
            views.setOnClickPendingIntent(R.id.button, pendingIntent);

            // Tell the AppWidgetManager to perform an update on the current app widget
            appWidgetManager.updateAppWidget(appWidgetId, views);
        }
    }
}
</code></pre>

<h3>创建 App Widget Configuration Activity</h3>

<p>如果你的 Widget 需要用户配置一些选项，你可以为你的 Widget 创建 Configuration Activity，当用户添加 Widget 时会自动弹出该 Activity。Configuration Activity 和普通 Activity 一样需要在 Manifest 中声明，但是需要额外声明一个 intent-filter: APPWIDGET_CONFIGURE，例如：</p>

<pre><code class="xml">&lt;activity android:name=".ExampleAppWidgetConfigure"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.appwidget.action.APPWIDGET_CONFIGURE"/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>

<p>同时还需要在上述的 appwidget-provider 中声明：</p>

<pre><code class="xml">&lt;appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    ...
    android:configure="com.example.android.ExampleAppWidgetConfigure" 
    ... &gt;
&lt;/appwidget-provider&gt;
</code></pre>

<p>有两点需要注意的是：</p>

<ol>
<li>Activity 必须返回带 EXTRA_APPWIDGET_ID 的 result。</li>
<li>声明Configuration Activity 后 onUpdate() 在 Widget 添加时不会被调用，Activity 负责调用 AppWidgetManager.updateAppWidget() 完成 Widget 更新。</li>
</ol>


<pre><code class="java">Intent intent = getIntent();
Bundle extras = intent.getExtras();
if (extras != null) {
    mAppWidgetId = extras.getInt(
        AppWidgetManager.EXTRA_APPWIDGET_ID, 
        AppWidgetManager.INVALID_APPWIDGET_ID);
}

AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
RemoteViews views = new RemoteViews(context.getPackageName(),R.layout.example_appwidget);
appWidgetManager.updateAppWidget(mAppWidgetId, views);

Intent resultValue = new Intent();
resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);
setResult(RESULT_OK, resultValue);
finish();
</code></pre>
]]></content>
  </entry>
  
</feed>
